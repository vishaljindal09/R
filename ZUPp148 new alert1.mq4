//+-------------------------------------------------------------------------+
//|ZigZag универсальный с паттернами                                        |
//|-------------------------------------------------------------------------|
//|                                                                         |
//|               "Parameters for ZigZag"                                   |
//|                                                                         |
//|-------------------------------------------------------------------------|
//|ExtIndicator - выбор варианта индикатора, на основе которого             |
//|               строятся паттерны Песавенто                               |
//|           0 - Zigzag из метатрейдера, стандартный, немного              |
//|               оптимизированный                                          |
//|           1 - Zigzag Алекса,                                            |
//|           2 - индикатор подобный встроенному в Ensign                   |
//|           3 - ZigZag Ensign с переменным значением minBars              |
//|           4 - ZigZag, разработал tauber                                 |
//|           5 - вариация на тему свингов Ганна                            |
//|           6 - DT-ZigZag с внешним ZigZag_new_nen3.mq4. В его основе     |
//|               стандартный ZigZag                                        |
//|           7 - DT-ZigZag с внешним DT_ZZ.mq4 (разработал klot)           |
//|           8 - DT-ZigZag с внешним CZigZag.mq4 (разработал Candid)       |
//|          10 - DT-ZigZag с внешним Swing_zz - это ExtIndicator=5         |
//|               в режиме DT                                               |
//|          11 - включает поиск паттернов Gartley на основе стандартного   |
//|               ZigZag                                                    |
//|          12 - ZigZag, разработал Talex                                  |
//|          13 - SQZZ зигзаг, разработал Товаровед                         |
//|          14 - ZZ_2L_nen, разработал wellx (авторасчет уровней - nen)    |
//|                                                                         |
//|ParametresZZforDMLEWA - задает набор параметров                          |
//|             minBars - ExtBackstep                                       |
//|             для режимов ExtIndicator=0 и ExtIndicator=6,                |
//|             используемых в тактике DML&EWA                              |
//|                                                                         |
//|          1 - minBars=5   ExtBackstep=8                                  |
//|          2 - minBars=8   ExtBackstep=13                                 |
//|          3 - minBars=13  ExtBackstep=21                                 |
//|          4 - minBars=21  ExtBackstep=34                                 |
//|          5 - minBars=34  ExtBackstep=55                                 |
//|          6 - minBars=55  ExtBackstep=89                                 |
//|          7 - minBars=89  ExtBackstep=144                                |
//|          8 - minBars=144 ExtBackstep=233                                |
//|                                                                         |
//|          0 - значение задается параметрами                              |
//|              minBars - ExtBackstep                                      |
//|                                                                         |
//|minBars - фильтр баровый (задается количество баров)                     |
//|minSize - фильтр по количеству пунктов (задается количество пунктов)     |
//|                                                                         |
//|ExtBackstep - параметр оставшийся от ZigZag из MT4                       |
//|noBackstep - выключает из расчетов параметр ExtBackstep в алгоритме      |
//| стандартного зигзага в режимах                                          |
//| ExtIndicator=0, ExtIndicator=6 и ExtIndicator=11                        |
//|                                                                         |
//|RecoverFiltr - задает режим восстановления экстремумов, удаленных        |
//|               параметром ExtBackstep.                                   |
//|                                                                         |
//|GrossPeriod - значение таймфрейма, выраженное в минутах (число минут),   |
//| данные с которого берутся для построения ZigZag в режиме DT-ZigZag      |
//|                                                                         |
//|minPercent - процентный фильтр (задается процент, например 0.5)          |
//|             Если используются проценты - ставим число и                 |
//|             задаем minSize=0                                            |
//|                                                                         |
//|ExtPoint=11 -   количество точек зигзага для зигзага Talex               |
//|                                                                         |
//|StLevel - первый уровень зигзага (wellx)                                 |
//|BigLevel - второй уровень зигзага (wellx)                                |
//|auto - задание автоматического расчета уровней StLevel и BigLevel        |
//|minBar - значение % для расчета StLevel                                  |
//|maxBar - значение % для расчета BigLevel                                 |
//|                                                                         |
//|                                                                         |
//|ExtStyleZZ - = true - задает стиль линий ZigZag через вкладку ЦВЕТА      |
//|             = false - Zigzag выводится точками у экстремумов            |
//|                                                                         |
//|ExtMaxBar - задает количество баров, участвующих в расчете зигзага       |
//|            0 - зигзаги рассчитываются на всей истории                   |
//|ExtMinBar - задает минимальный номер бара, до которого рассчитывается    |
//|            зигзаг                                                       |
//|                                                                         |
//|ExtNumberPeak - включает нумерацию переломов ZigZag начиная с 1          |
//|ExtNumberPeak10 - разрешает вывод номеров только у первых 10 переломов   |
//|ExtNumberPeakLow - вывод чисел только у Low или у High и Low             |
//|ExtNumberPeakColor - цвет чисел                                          |
//|ExtNumberPeakFontSize - размер чисел                                     |
//|-------------------------------------------------------------------------|
//|                                                                         |
//|               "Parameters for fibo Levels"                              |
//|                                                                         |
//|-------------------------------------------------------------------------|
//|ExtFiboDinamic - разрешает вывод днамических уровней фибо.               |
//|                 Динамические уровни фибо выводятся на первом луче       |
//|                 ZigZag-a.                                               |
//|                                                                         |
//|ExtFiboStatic - разрешает вывод статических уровней фибо                 |
//|                                                                         |
//|ExtFiboStaticNum - номер луча ZigZag-a, на котором будут выводиться      |
//|                   статические уровни Фибоначчи. 1<ExtFiboStaticNum<=9   |
//|                                                                         |
//|ExtFiboCorrectionExpansion = false - коррекция Фибоначчи                 |
//|                           = true  - расширение Фибоначчи                |
//|                                                                         |
//|ExtFiboD и ExtFiboS - выбор цвета динамических и статических фиб.        |
//|                                                                         |
//|ExtFiboStyle - устанавливает стиль линий уровней фибо                    |
//|                                                                         |
//|ExtFiboWidth - устанавливает толщину линий уровней фибо                  |
//|-------------------------------------------------------------------------|
//|                                                                         |
//|               "Parameters for Pesavento Patterns"                       |
//|                                                                         |
//|-------------------------------------------------------------------------|
//|ExtPPWithBars - задает, какую информацию выводить инструментом           |
//|                паттерны Песавенто                                       |
//|                                                                         |
//|             0 - показывает значение ретресмента у паттернов Песавенто   |
//|                                                                         |
//|             1 - выводится количество баров между точками, связанными    |
//|                 "ретресментом" (паттерном Песавенто)                    |
//|                                                                         |
//|             2 - выводится количество баров для первого и второго        |
//|                 условного луча зигзага, между которыми построен         |
//|                 "ретресмент" (паттерном Песавенто)                      |
//|                                                                         |
//|             3 - выводится временнОй ретресмент после ценового           |
//|                 ретресмента. ВременнОй ретресмент рассчитывается как    |
//|                 отношение количества баров на втором луче зигзага к     |
//|                 количеству баров на первом луче зигзага                 |
//|                                                                         |
//|             4 - выводится временнОй ретресмент, рассчитанный как        |
//|                 отношение времени развития второго луча к времени       |
//|                 развития первого луча                                   |
//|                                                                         |
//|             7 - выводит значение скорости для первого и второго лучей   |
//|                 Данный параметр также можно использовать для определения|
//|                 значения масштаба. Данное значение используется при     |
//|                 автоматическом масштабировании фибо дуг.                |
//|                                                                         |
//|             8 - выводит отношение длины второгоо луча к длине первого   |
//|                                                                         |
//|             9 - выводит процент изменения цены на первом и              |
//|                 втором лучай                                            |
//|                                                                         |
//|            10 - выводит время и цену экстремума, находящегося справа    |
//|                                                                         |
//|ExtHidden - 0 - линии и числа паттернов Песавенто скрыты.                |
//|            1 - показывает все линии между экстремумами, у которых       |
//|                ретресмент >0.14 и <5.                                   |
//|            2 - показывает только те  линии, где ретресмент              |
//|                равен числам Песавенто (и 0.447, 0.886, 2.236, 3,14,     |
//|                3,618 для построения паттернов Gartley)                  |
//|            3 - показывает числа, перечисленные в пункте 2               |
//|                и соответствующие линии                                  |
//|            4 - показывает числа не Песавенто и соответствующие линии    |
//|            5 - скрывает всю оснастку. Остается только ZigZag            |
//|                и вывод паттернов Gartley                                |
//|                                                                         |
//|ExtFractal - количество экстремумов (максимумов, минимумов),             |
//|             от которых идут линии к другим экстремумам                  |
//|                                                                         |
//|ExtFractalEnd - количество экстремумов, к которым идут линии             |
//|                дальше этого экстремума соединяющих линий не будет       |
//|                Если ExtFractalEnd=0 то последний экстремум равен        |
//|                максимальному числу экстремумов.                         |
//|                Минимальное значение ExtFractalEnd=1                     |
//|                                                                         |
//|ExtFiboChoice - выбор набора чисел для построения паттернов Песавенто.   |
//|                Параметр задается числами от 0 до 11                     |
//|                                                                         |
//|ExtFiboZigZag - разрешает вывод "ZiaZag Fibonacci"                       |
//|                                                                         |
//|ExtDelta - допуск. Если текущий ретресмент отличается от ближайшего      |
//|           значения числа Песавенто не более величины допуска, то        |
//|           то выводится на график число Песавенто. Задает величину       |
//|           потенциальной разворотной зоны. Должно быть 0<ExtDelta<1      |
//|                                                                         |
//|ExtDeltaType -    0 - выводятся проценты восстановления "как есть"       |
//|                      с округлением до 2 цифр после запятой              |
//|                  1 - расчет допуска (%-число Песавенто)<ExtDelta        |
//|                  2 - ((%-число Песавенто)/число Песавенто)<ExtDelta     |
//|                  3 - выводятся проценты восстановления "как есть"       |
//|                      с округлением до 3 цифр после запятой              |
//|                                                                         |
//|ExtSizeTxt - размер шрифта для вывода чисел                              |
//|                                                                         |
//|ExtLine - выбор цвета соединительных линий                               |
//|                                                                         |
//|ExtLine886 - выбор цвета соединительных линий с числами Песавенто        |
//|                                                                         |
//|ExtNotFibo - выбор цвета всех остальных чисел                            |
//|                                                                         |
//|ExtPesavento - выбор цвета чисел Песавенто                               |
//|                                                                         |
//|ExtGartley886 - выбор цвета числа .886 и других дополнительных           |
//|-------------------------------------------------------------------------|
//|                                                                         |
//|               "Parameters for Gartley Patterns"                         |
//|                                                                         |
//|-------------------------------------------------------------------------|
//|                                                                         |
//|AlgorithmSearchPatterns - выбор алгоритма сканера поиска паттернов       |
//|           для режима поиска паттернов ExtIndicator=11                   |
//|           = 0 - соответствует алгоритму ExtIndicator=0 - этот алгоритм  |
//|           применялся до 124 версии ZUP в режиме ExtIndicator=11         |
//|   Значения >0 добавлены начиная со 124 версии                           |
//|           = 1 - соответствует алгоритму ExtIndicator=1 - зигзаг Алекса  |
//|           размер луча задается в пунктах                                |
//|           = 2 - соответствует алгоритму ExtIndicator=1 - зигзаг Алекса  |
//|           размер луча задается в процентах                              |
//|           = 3 - соответствует алгоритму ExtIndicator=2                  |
//|           = 4 - соответствует алгоритму ExtIndicator=4                  |
//|           = 5 - соответствует алгоритму ExtIndicator=5                  |
//|           = 6 - соответствует алгоритму ExtIndicator=12                 |
//|                                                                         |
//|PotencialsLevels_retXD - разрешает вывод уровней ретресмента XD          |
//|           потенциальных пятиточечновных паттернов.                      |
//|           В режиме ExtIndicator=11 применяется только, если найден      |
//|             паттерн и уровни выводятся от точки C найденного паттерна   |
//|           = 0 - отключен вывод потенциальных уровней                    |
//|           = 1 - потенциальные уровни выводятся совместно с паттернами   |
//|           при ExtGartleyOnOff=true                                      |
//|           = 2 - потенциальные уровни выводятся. При этом отключается    |
//|           вывод паттернов                                               |
//|                                                                         |
//|visibleLevelsABCD - задает различные варианты показа уровней             |
//|           потенциальной точки D потенциальных пятиточечных паттернов    |
//|           0 - не показываются дополнительные уровни.                    |
//|           1 - выводятся на график все варианты уровней ретресмента BD   |
//|           2 - выводятся на график все уровни разных вариантов AB=CD     |
//|           3 - выводятся совместно уровни ретресмента BD и варианты AB=CD|
//|                                                                         |
//|maxDepth - максимальное значение Depth (minBars), до которого может      |
//|           изменяться параметр Depth зигзага при активном сканировании   |
//|           для поиска паттернов Gartley                                  |
//|           Применяется при AlgorithmSearchPatterns=0                     |
//|minDepth - задает минимальное значение Depth для поиска паттернов        |
//|           Gartley.                                                      |
//|                                                                         |
//|FiboStep - включает при поиске паттернов вычисление значения параметра   |
//|           Backstep по формуле Backstep=Depth*1.618                      |
//|IterationStepDepth - шаг изменения параметра загзага Depth при поиске    |
//|                паттернов Gartley.                                       |
//|                                                                         |
//|maxSize_  - максимальное значение размера луча в пунктах.                |
//|            Используется в сканере паттернов при значениях параметра     |
//|            AlgorithmSearchPatterns=1                                    |
//|            AlgorithmSearchPatterns=3                                    |
//|            AlgorithmSearchPatterns=4                                    |
//|            AlgorithmSearchPatterns=6                                    |
//|minSize_  - минимальное значение размера луча в пунктах.                 |
//|                                                                         |
//|IterationStepSize - шаг изменения параметра загзага Size при поиске      |
//|                паттернов Gartley.                                       |
//|                                                                         |
//|maxPercent_ - максимальное значение процента для расчета загзага Алекса  |
//|            Используется в сканере паттернов при значениях параметра     |
//|            AlgorithmSearchPatterns=2                                    |
//|minPercent_ - минимальное значение процента для расчета загзага Алекса   |
//|                                                                         |
//|IterationStepPercent - шаг (процент) изменения параметра загзага Percent |
//|                                                                         |
//|DirectionOfSearchMaxMin - задает направление поиска:                     |
//|           false - от minDepth к maxDepth                                |
//|           true - от maxDepth к minDepth                                 |
//|                                                                         |
//|SelectPattern - задает группы 5 точечных паттернов для поиска            |
//|           "размытых" и "точных" паттернов".                             |
//|                                                                         |
//|           0 - поиск всех паттернов                                      |
//|           1 - поиск только классических паттернов - Gartle, Butterfly,  |
//|               Bat, Crab, кроме TOTAL                                    |
//|           2 - поиск классических и антиклассических паттернов,          |
//|               кроме TOTAL                                               |
//|           3 - поиск экзотических паттернов и экзотических антипаттернов,|
//|               кроме TOTAL                                               |
//|           4 - поиск только антипаттернов, кроме TOTAL                   |
//|           5 - поиск всех паттернов, кроме TOTAL                         |
//|           6 - поиск только TOTAL                                        |
//|           7 - произвольный выбор пятиточечных паттернов для поиска      |
//|               с помощью параметра visiblePattern                        |
//|           8 - отключен поиск пятиточечных паттернов                     |
//|                                                                         |
//|visiblePattern - задает, какие паттерны искать.                          |
//|               По умолчанию выключен поиск всех паттернов.               |
//|                                                                         |
//|NumberPattern - номер паттерна, по которому калибруется зигзаг и         |
//|               параметры которого выводятся через InfoTF                 |
//|           0 - выводится зигзаг с параметрами как в режиме               |
//|               ExtIndicator=0                                            |
//|                                                                         |
//|ExtGartleyTypeSearch - режим поиска паттернов                            |
//|           0 - поиск заканчивается после первого найденного паттерна     |
//|           1 - выводятся все паттерны на участке, заданном               |
//|               параметром maxBarToD. Поиск повторяется при каждом        |
//|               пересчете зигзага                                         |
//|           2 - выводятся все паттерны на участке, заданном               |
//|               параметром maxBarToD. Поиск производится только один раз  |
//|                                                                         |
//|ExtHiddenPP - режим отображения зигзага для ExtIndicator==11             |
//|           0 - зигзаг не выводится. Выводятся только точки у             |
//|               вершин зигзага. Паттерны Песавенто не выводятся.          |
//|           1 - выводится зигзаг откалиброванный паттерном, заданным      |
//|               параметром NumberPattern. Паттерны Песавенто выводятся    |
//|               обычным образом.                                          |
//|           2 - зигзаг не выводится. Выводятся только точки у             |
//|               вершин зигзага. Паттерны Песавенто выводятся только       |
//|               для вершин паттернов Gartley                              |
//|                                                                         |
//|ExtGartleyOnOff - включает показ паттернов Gartley. Не в режииме сканера.|
//|                                                                         |
//|maxBarToD - задает максимальное количество баров от нулевого             |
//|            до точки D паттерна                                          |
//|                                                                         |
//|patternInfluence - 0 - выводятся паттерны, у которых от нулевого бара    |
//|                   до бара с точкой D не более maxBarToD баров           |
//|                   1 - учитывается влияние паттерна при этом             |
//|                   отменяется действие параметра maxBarToD               |
//|                   2 - поиск паттернов осуществляется на всей разметке   |
//|                       зигзага                                           |
//|                                                                         |
//|patternTrue = true - выводятся паттерны, удовлетворяющие условию:        |
//|    для медвежьих паттернов на участке от точки D до нулевого бара       |
//|    не должно быть баров, у которых максимум бара выше максимума рамки   |
//|    зоны развития точки D;                                               |
//|    для бычьих паттернов на участке от точки D до нулевого бара          |
//|    не должно быть баров, у которых минимум бара ниже минимума рамки     |
//|    зоны развития точки D.                                               |
//|                                                                         |
//|                                                                         |
//|AllowedBandPatternInfluence - задается коэффицент от величины            |
//|                   расстояния между точками X и D паттерна. Этот         |
//|                   коэффициент задает расстояние от точки D до           |
//|                   точки, где влияние паттерна предположительно          |
//|                   заканчивается                                         |
//|                                                                         |
//|RangeForPointD - разрешает показ зоны развития точки D                   |
//|                                                                         |
//|OldNewRangeForPointD - выбор варианта построения зоны развития точки D   |
//|                       паттерна                                          |
//|                                                                         |
//|ExtColorRangeForPointD - цвет рамки зоны развития точки D                |
//|                                                                         |
//|VectorOfAMirrorTrend  = 1 выводится Вектор тренда                        |
//|VectorOfAMirrorTrend  = 2 выводится Вектор зеркального тренда            |
//|VectorOfAMirrorTrendColor - задает цвет линии обратного тренда           |
//|VectorOfAMirrorTrendStyle - задает стиль линии обратного тренда          |
//|                                                                         |
//|shortNamePatterns - разрешает вывод коротких наименований паттернов      |
//|                                                                         |
//|visibleLineOrTriangle - разрешает вывод паттернов в виде линии или в виде|
//|            треугольников, кроме паттернов AB=CD                         |
//|PatternLineStyle - задает стиль линии пятиточечных паттернов и ABCD      |
//|PatternLineWidth - задает толщину линии пятиточечных паттернов и ABCD    |
//|ExtColorPatterns - цвет паттернов                                        |
//|ExtColorPatternList - задается список цветов для закраски крыльев        |
//|                      паттернов Gartley. Названия цветов перечислены     |
//|                      через запятую. Если какой либо цвет будет          |
//|                      записан с ошибкой, то для этого цвета выбирается   |
//|                      красный цвет                                       |
//|                                                                         |
//|ExtDeltaGartley - допуск на отклонение цены для поиска паттернов         |
//|                  по умолчанию 9% - 0.09                                 |
//|ExtDeltaGartleyPRZ  - специальный допуск для построения рамки развития   |
//|                       точки D паттерна                                  |
//|                                                                         |
//|levelD - включает вывод на график уровней ретресментов XD возможных      |
//|         вариантов точных паттернов для текущей комбинации               |
//|                                                                         |
//|colorLevelD - задает цвет уровней ретресментов XD                        |
//|                                                                         |
//|Equilibrium - включает вывод линий Equilibrium, Reaction1 и Reaction2    |
//|ReactionType - задает тип линий реакции                                  |
//|EquilibriumStyle - задает стиль линий                                    |
//|EquilibriumWidth - задает толщину линий                                  |
//|ColorEquilibrium - задает цвет для Equilibrium                           |
//|ColorReaction - задает цвет для Reaction1 и Reaction2                    |
//|                                                                         |
//|Ext_3Drives - разрешает вывод паттерна 3 Drives                          |
//|Ext_xO - задает коэффициент для поиска 7-точечного паттерна 3 Drives     |
//|                                                                         |
//|Dragon - разрешает вывод паттерна Dragon                                 |
//|PeakZZDragon - задает номер экстремума зигзага, до которого              |
//|               производится поиск паттерна Dragon                        |
//|                                                                         |
//|Ext_4PointPattern - разрешает поиск 4-хточечного паттерна продолжения    |
//|_maxXB - задает максимальное значение ретресмента XB                     |
//| Узнать об этом паттерне можно здесь: http://kanetrading.com/            |
//|                                                                         |
//|ABCD - разрешает поиск паттернов AB=CD                                   |
//|      0 - паттерны AB=CD не выводятся                                    |
//|      1 - выводятся любые AB=CD                                          |
//|      2 - выводятся только гармоничные AB=CD, у которых                  |
//|          соотношения в пределах допуска соответствуют фибо ряду         |
//|searchABCDAlternate - разрешает вывод альтернативных паттернов AB=CD     |
//|ABCDAlternate - задает список альтернативных паттернов ABCD. В данном    |
//|               списке через запятую перечисляются коэффициенты X из      |
//|               формулы X*AB=CD                                           |
//|visibleABCDrayZZ - разрешает вывод паттернов ABCD в виде линии           |
//|                                                                         |
//|Ext_noname - разрешает поиск неизвестных пятиточечных паттернов, у       |
//|             которых все четыре ретресмента равны какой-то "фибе"        |
//|                                                                         |
//|CustomPattern - определяет выводить или нет пользовательские паттерны    |
//|0 - не выводится пользовательский паттерн                                |
//|1 - выводится вместе с другими паттернами                                |
//|2 - выводится только пользовательский паттерн                            |
//|NameCustomPattern - название пользовательского паттерна                  |
//|minXB - задает минимальное значение ретресмента XB                       |
//|maxXB - задает максимальное значение ретресмента XB                      |
//|minAC - задает минимальное значение ретресмента AC                       |
//|maxAC - задает максимальное значение ретресмента AC                      |
//|minBD - задает минимальное значение ретресмента BD                       |
//|maxBD - задает максимальное значение ретресмента BD                      |
//|minXD - задает минимальное значение ретресмента XD                       |
//|maxXD - задает максимальное значениEquilibriumе ретресмента XD           |
//|  Минимум и максимум ретресмента задают диапазон для поиска              |
//|                                                                         |
//|filtrEquilibrium - включает в качестве фильтра линию, проходящую через   |
//|        точки X и B паттерна. Если фильтр включен, то паттерн будет      |
//|        прорисован, когда цена пробьет эту линию при движении от точки C |
//|        паттерна в сторону точки D.                                      |
//|        Работает только с пользовательскими паттернами и паттернами      |
//|        noname.                                                          |
//|                                                                         |
//|readFromFileListPatterns - задает чтение списка паттернов из файла       |
//|       \\ZUP\ListPatterns\listpatterns.csv                               |
//|       0 - чтение списка паттернов из файла запрещено                    |
//|       1 - используется для поиска пятиточечных паттернов только тех     |
//|           паттернов, список которых загружен из файла                   |
//|       2 - к встроенному в ZUP списку пятиточечных паттернов             |
//|           допИсывается список паттернов из файла. В этом случае         |
//|           получается составной список паттернов.                        |
//|                                                                         |
//|NameFileListPatterns - задает название .csv файла из которого читается   |
//|           список параметров паттернов                                   |
//|                                                                         |
//|writeToFileListPatterns - разрешает запись списка пятиточечных паттернов:|
//|       1) если readFromFileListPatterns=0                                |
//|          в файл: \\ZUP\ListPatterns\listpatternsdefault.csv             |
//|       2) если readFromFileListPatterns=1                                |
//|          в файл: \\ZUP\ListPatterns\listpatternscustom.csv              |
//|       3) если readFromFileListPatterns=2                                |
//|          в файл: \\ZUP\ListPatterns\listpatternsmixt.csv                |
//|                                                                         |
//|picture - разрешает вывод в файл картинки графика с паттерном            |
//|                                                                         |
//|writeInfoPatternsToFileXML - разрешает вывод в файл .XML параметров      |
//|       текущего пятиточечного паттерна                                   |
//|       0 - запрещен вывод параметров в файл                              |
//|       1 - параметры времени выводятся в развернутом виде                |
//|       2 - параметры времени выводятся в виде количества секунд          |
//|                                                                         |
//|writeInfoPatternsToFileCSV - разрешает вывод в файл .CSV параметров      |
//|       текущего пятиточечного паттерна                                   |
//|       0 - запрещен вывод параметров в файл                              |
//|       1 - параметры времени выводятся в развернутом виде                |
//|       2 - параметры времени выводятся в виде количества секунд          |
//|                                                                         |
//|namefileSymbolPeriod = true - задается название файлов с картинками      |
//|       паттернов и с параметрами в виде Symbol()+"_"+Period()+"_Patterns |
//|                                                                         |
//|InfoPointD - разрешает вывод информации о точке D паттерна крупным       |
//|             шрифтом                                                     |
//|                                                                         |
//|MonitorPatterns - включает монитор паттернов                             |
//|                                                                         |
//|TextSize - задает размер шрифта в мониторе паттернов                     |
//|                                                                         |
//|ExtGlobalVariableSet - разрешает запись информации о паттернах в         |
//|                       глобальные переменные терминала                   |
//|-------------------------------------------------------------------------|
//|                                                                         |
//|               "Parameters Exp"                                          |
//|                                                                         |
//|-------------------------------------------------------------------------|
//|chHL     = true     - выводит уровни подтверждения для режимов           |
//|                      ExtIdicator=1, ExtIdicator=2, ExtIdicator=3        |
//|                                                                         |
//|PeakDet  = true     - выводит уровни предыдущих максимумов для всех      |
//|                      режимов ExtIndicator                               |
//|                                                                         |
//|chHL_PeakDet - true - По умолчанию разрешает вывод линий                 |
//| подтверждения (ценовой канал) и уровни предыдущих максимумов ZigZag.    |
//|                                                                         |
//|ExtLabel =0 обычный режим вывода зигзагов                                |
//|         =1 вывод меток в расчетном месте появления нового луча          |
//|            для редима DT - в виде полосок символов                      |
//|         =3 вывод меток в расчетном месте появления нового луча          |
//|            для режима DT - в виде одного символа                        |
//|                                                                         |
//|ExtCodLabel - код символа для вывода метки                               |
//|                                                                         |
//|-------------------------------------------------------------------------|
//|                                                                         |
//|               "Common Parameters"                                       |
//|                                                                         |
//|-------------------------------------------------------------------------|
//|ExtFiboType - задает, на какие значения фиб настроены фибо инструменты   |
//|                                                                         |
//|               0 - стандартные фибы                                      |
//|               1 - фибы с числами Песавенто и т.д.                       |
//|               2 - фибы, заданные пользователем                          |
//|                                                                         |
//|ExtFiboTypeFree - задание пользовательских фиб уровней фибо              |
//|                                                                         |
//|ExtObjectColor - задает цвет линии, соединяющей базовые точки объектов   |
//|ExtObjectStyle - задает cтиль линии, соединяющей базовые точки объектов  |
//|ExtObjectWidth - задает толщину линии, соединяющей базовые точки объектов|
//|                                                                         |
//|ExtDinamic - разрешает вывод статических инструментов как динамических   |
//|             при этом при появлении нового луча статические              |
//|             инструменты перемещаются на другие переломы зигзага         |
//|                                                                         |
//|ExtVisibleDinamic - позволяет выделить, какие статические                |
//|             инструменты выводить в динамическом режиме                  |
//|                                                                         |
//|             Перечислю их по порядку следования в списке:                |
//|             1 - нумерация переломов зигзага                             |
//|             2 - статические фибо уровни и первый тип расширений фибо    |
//|                                                                         |
//|             По умолчанию ExtVisibleDinamic = "01"                       |
//|             0 - выводится в статическом режиме                          |
//|             1 - выводится в динамическом режиме                         |
//|                                                                         |
//|RefreshStaticNewRayZZ - разрешает перерисовку статических инструментов   |
//|             в случаев образования вместо трех первых лучей зигзага      |
//|             одного луча.                                                |
//|                                                                         |
//|ZigZagHighLow - задает, от каких точек делать построение                 |
//|                паттернов Песавенто и т.д.                  |
//|            true - от экстремумов баров                                  |
//|            false - от переломов ZigZag, когда они висят в "воздухе"     |
//|                                                                         |
//|ExtSendMail - отправка сообщения на email о появившемся паттерне.        |
//|                                                                         |
//|ExtAlert - разрешает вывод сообщения и звукового сигнала при             |
//|           возникновении нового луча ZigZag                              |
//|                                                                         |
//|ExtPlayAlert - разрешает вывод сообщения и звукового сигнала при         |
//|               появлении нового паттерна                                 |
//|                                                                         |
//|AlertText - текстовое сообщение при появлении нового паттерна            |
//|                                                                         |
//|ExtBack - задает вывод всех объектов в виде фона                         |
//|                                                                         |
//|ExtSave - разрешает сохранение комплекта статических вил и               |
//|          Fibo Time                                                      |
//|                                                                         |
//|info_comment - позволяет выделить группу параметров для вывода этой      |
//|               группы в информационной строке.                           |
//|            Всего 5 групп параметров.                                    |
//|            0 - группа параметров не выводится                           |
//|            1 - группа параметров выводится                              |
//|                                                                         |
//|            Группы параметров:                                           |
//|            1 - информация о свечах со старших таймфреймов               |
//|            2 - % изменения луча для лучевой тактики                     |
//|            3 - параметры зигзагов                                       |
//|            4 - информация о найденном паттерне Gartley                  |
//|                                                                         |
//|infoMerrillPattern - true - выводить информацию о паттернах              |
//|                     false - не выводить информацию о паттернах          |
//|                                                                         |
//|infoTF - включает информацию по 5 старшим таймфреймам.(стакан цен)       |
//|         Выводится наименование таймфрейма. Размер свечи в пунктах.      |
//|         Текущее положение цены относительно минимума.                   |
//|         Также показывает Высоту луча зигзага выраженную в процентах.    |
//|         Показывает режим работы индикатора и параметры зигзагов.        |
//|         Показывает названия паттернов Gartley и ценовой размер зоны     |
//|         возможного развития точки D для паттернов Gartley.              |
//|                                                                         |
//|  Следующая группа параметров выводит наименование паттернов Gartley     |
//|  крупным шрифтом                                                        |
//|bigText - разрешает вывод наименования паттерна крупным шрифтом          |
//|      Также выводится наименование паттернов Меррилла крупным шрифтом    |
//|bigTextSize - задает размер шрифта                                       |
//|bigTextColor - задает цвет шрифта (для Gartley Bullish паттерны)         |
//|bigTextColorBearish - задает цвет шрифта для Gartley Bearish паттернов   |
//|bigTextX - расстояние по горизонтали до места вывода надписи             |
//|bigTextY - расстояние по вертикали до места вывода надписи               |
//|                                                                         |
//|ExtVisible - отключение вывода ZUP без выгрузки из памяти                |
//|ExtComplekt - задает номер индикатора. При выводе на график нескольких   |
//|              индикаторов через этот параметр задается номер копии.      |
//|              При этом все копии индикатора будут работать корректно.    |
//+-------------------------------------------------------------------------+
#property copyright "nen"
#property link      "http://www.onix-trade.net/forum/"
//topic/118-gartley-patterns-%D0%B8-%D0%B8%D1%85-%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8/"
// описание          http://onix-trade.net/forum/index.php?s=&showtopic=373&view=findpost&p=72865

#property stacksize 65535
#property indicator_chart_window
#property indicator_buffers 6
#property indicator_color1 clrMagenta //clrRed 
//#property indicator_width6 5 
#property indicator_color2 clrGreen
#property indicator_color3 clrOrange
#property indicator_color4 clrLightSkyBlue
#property indicator_color5 clrLemonChiffon
//#property indicator_color4 clrChartreuse
//#property indicator_color5 clrRed
#property indicator_color6 clrMagenta //clrYellow

#property version "2.148"
#property description "ZigZag универсальный с паттернами Песавенто"
#property description " "
#property description "Версия для поиска паттернов"

#define pi  3.14159265
#define phi 1.6180339887

//===================================

// Паттерны Gartley
extern string ______________3_____________ = "Parameters for Gartley Patterns";
extern int    AlgorithmSearchPatterns = 0;
extern int    PotencialsLevels_retXD  = 1;
extern int    visibleLevelsABCD       = 3;
// Параметры для зигзага из MT4  и зигзага Talex
extern int    maxDepth                = 55;
extern int    minDepth                = 3;
extern bool   FiboStep                = true; //false;
extern int    IterationStepDepth      = 2;
// Параметры для зигзага Алекса 1 и зигзага Ensign - меняем размер
extern int    maxSize_                = 150;
extern int    minSize_                = 15;
extern int    IterationStepSize       = 3;
// Параметры для зигзага Алекса 2 - меняем процент
extern double maxPercent_             = 10.0;
extern double minPercent_             = 0.4;
extern double IterationStepPercent    = 15;
//
extern bool   DirectionOfSearchMaxMin = true;
extern int    SelectPattern           = 0;
extern string visiblePattern          = "000000000000000000000000000000000";
extern int    NumberPattern           = 1;  // Номер паттерна, по которому калибруется зигзаг и параметры которого выводятся через InfoTF
extern int    ExtGartleyTypeSearch    = 0;
extern int    ExtHiddenPP             = 1;
extern bool   ExtGartleyOnOff         = true;
//extern int    VarDisplay=0;
extern int    maxBarToD               = 15;
extern int    patternInfluence        = 1; //2;
extern bool   patternTrue             = true;
extern double AllowedBandPatternInfluence = 1.618;
extern bool   RangeForPointD          = true;
extern bool   OldNewRangeForPointD    = false;
extern color  ExtColorRangeForPointD  = clrRed;
extern int    VectorOfAMirrorTrend    = 2;
extern color  VectorOfAMirrorTrendColor  = clrLawnGreen;
extern int    VectorOfAMirrorTrendStyle  = STYLE_DASH;
extern bool   shortNamePatterns       = false;
extern bool   visibleLineOrTriangle   = true;
extern int    PatternLineStyle        = 0;
extern int    PatternLineWidth        = 2;
extern color  ExtColorPatterns        = clrBlue;
extern string ExtColorPatternList     = "clrBlue,clrDarkGreen,clrFireBrick,clrDeepPink,clrRoyalBlue,clrSienna,clrDodgerBlue,clrCornflowerBlue,clrTomato,clrSlateBlue,clrMediumSlateBlue,clrSlateGray,clrBlueViolet";
//extern string ExtColorPatternList     = "clrBlue,clrDarkGreen,clrNavy,clrSienna,clrMediumBlue,clrRoyalBlue,clrDodgerBlue,clrCornflowerBlue,clrLightSkyBlue,clrSlateBlue,clrMediumSlateBlue,clrSlateGray,clrLightSteelBlue";
extern double ExtDeltaGartley         = 0.09;
extern double ExtDeltaGartleyPRZ      = 0.02;

extern int    levelD                  = 1;
extern color  colorLevelD             = clrRed;

//---------------
extern bool   Equilibrium             = true;
extern bool   ReactionType            = false;
extern int    EquilibriumStyle        = 1;
extern int    EquilibriumWidth        = 0;
extern color  ColorEquilibrium        = clrRed;
extern color  ColorReaction           = clrTomato;
//--------------- 3 Drives ----------
extern bool   Ext_3Drives             = true;
extern double Ext_xO                  = 1.618;
//--------------- Dragon ------------
extern bool   Dragon                  = true;
extern int    PeakZZDragon            = 7;
//--------------- 4-Point Pattern ---
extern bool   Ext_4PointPattern       = true;
extern double _maxXB                  = 0.618;
//--------------- AB=CD -------------
extern int    ABCD                    = 2; 
extern bool   searchABCDAlternate     = false;
extern string ABCDAlternate           = "0.618,0.786,0.886,1.128,1.272,1.618,2.618";
extern bool   visibleABCDrayZZ        = true;
//---------------
extern bool   Ext_noname              = false;
//---------------
extern int    CustomPattern           = 0; // 0 - не выводится пользовательский паттерн 
                                           // 1 - выводится вместе с основной группой паттернов
                                           // 2 - выводится только custom паттерн
extern string NameCustomPattern       = "Custom";
extern double minXB                   = 0.67; // 0.382;  //0.5;
extern double maxXB                   = 0.67; // 0.942;  //0.618;
extern double minAC                   = 0.618; // 0.447;  //0.382;
extern double maxAC                   = 0.618; // 0.942;  //0.618;
extern double minBD                   = 2.46; // 1.144;  //1.128;
extern double maxBD                   = 2.46; // 2.128;  //1.272;
extern double minXD                   = 1.272; // 0.5;    //0.618;
extern double maxXD                   = 1.272; // 0.942;  //0.886;

extern bool   filtrEquilibrium           = true;

// Вывод в файлы информации о паттернах. Чтение из файла списка паттернов
extern int    readFromFileListPatterns   = 0;
extern string NameFileListPatterns       = "listpatterns";
extern bool   writeToFileListPatterns    = false;
extern bool   picture                    = false;
extern int    writeInfoPatternsToFileXML = 0;
extern int    writeInfoPatternsToFileCSV = 0;
extern bool   namefileSymbolPeriod       = false;

extern bool   InfoPointD                 = false;

extern bool   MonitorPatterns            = true;
extern int    TextSize                   = 10;

extern bool   ExtGlobalVariableSet       = false;
//---- indicator parameters
extern string ______________0_____________ = "Parameters for ZigZag";
extern int    ExtIndicator            = 11; 
extern int    ParametresZZforDMLEWA   = 6;
extern int    minBars                 = 8;
extern int    minSize                 = 50;
// Переменные от ZigZag из МТ
extern int    ExtDeviation            = 5;
extern int    ExtBackstep             = 3;
extern bool   noBackstep              = false;
extern bool   RecoverFiltr            = false;
// Переменная для nen-ZigZag
extern int    GrossPeriod             = 240;
//----
extern double minPercent              = 0.0;      // 0.08
extern int    ExtPoint=11; // количество точек зигзага для зигзага Talex 
// Параметры для зигзага, разработанного wellx
extern int    StLevel                 = 28;
extern int    BigLevel                = 32; 
extern bool   auto                    = true;
extern double minBar=38.2, maxBar=61.8;

extern bool   ExtStyleZZ              = true;

extern int    ExtMaxBar               = 1400;     // Количество баров обсчёта (0-все)
extern int    ExtMinBar               = 0;
// вывод номеров переломов зигзагов
extern bool   ExtNumberPeak           = false;
extern bool   ExtNumberPeak10         = true;
extern bool   ExtNumberPeakLow        = true;
extern color  ExtNumberPeakColor      = clrRed;
extern int    ExtNumberPeakFontSize   = 11;

extern string ______________1_____________ = "Parameters for fibo Levels";
extern bool   ExtFiboDinamic          = false;
extern bool   ExtFiboStatic           = false;
extern int    ExtFiboStaticNum        = 2;
extern bool   ExtFiboCorrectionExpansion = false;
extern color  ExtFiboD                = clrSienna;
extern color  ExtFiboS                = clrTeal;
extern int    ExtFiboStyle            = 2;
extern int    ExtFiboWidth            = 0;
//-------------------------------------

extern string ______________2_____________ = "Parameters for Pesavento Patterns";
extern int    ExtPPWithBars           = 0;
extern int    ExtHidden               = 1;
extern int    ExtFractal              = 7;
extern int    ExtFractalEnd           = 7;
extern int    ExtFiboChoice           = 2;
extern bool   ExtFiboZigZag           = false;
extern double ExtDelta                = 0.04;
extern int    ExtDeltaType            = 2;
extern int    ExtSizeTxt              = 12;
extern color  ExtLine                 = clrDarkBlue;
extern color  ExtLine886              = clrPurple;
extern color  ExtNotFibo              = clrBlack;
extern color  ExtPesavento            = clrBlack; // Yellow; Цвета для белого фона. Убрал цвета для черного фона 
extern color  ExtGartley886           = clrBlack; // GreenYellow;
       color  colorPPattern;

extern string ______________4_____________ = "Parameters Exp";
extern bool   chHL                = false;
extern bool   PeakDet             = false;
extern bool   chHL_PeakDet        = true;
extern int    ExtLabel            = 0;
extern int    ExtCodLabel         = 116;

extern string ______________5_____________ = "Common Parameters";
//--------------------------------------
extern int    ExtFiboType       = 1;
extern string ExtFiboTypeFree  = "0,0.382,0.618,0.764,1,1.236,1.618"; // пользовательские уровни фибо 
extern color  ExtObjectColor    = clrNONE;
extern int    ExtObjectStyle    = 1;
extern int    ExtObjectWidth    = 0; 
// вывод статических объектов в режиме динамических
extern bool   ExtDinamic        = false; //true; //
extern string ExtVisibleDinamic = "01";
extern bool   RefreshStaticNewRayZZ =true;

extern bool   ZigZagHighLow     = true;
// --------------------------------
// Дополнительные функции
extern bool   ExtSendMail       = false;
extern bool   ExtAlert          = false;
extern bool   ExtPlayAlert      = false;
extern string AlertText         = "появился новый Паттерн";
// Вывод объектов в виде фона
extern bool   ExtBack           = true;
// Сохранение статических вил Эндрюса, Fibo Time и т.д.
extern bool   ExtSave           = false;
extern string info_comment      = "0011";
extern bool   infoMerrillPattern= false;
extern bool   infoTF            = true;
// Вывод вертикальной линии на нулевом баре
// Вывод названий паттернов крупным шрифтом
extern bool   bigText           = true;
extern int    bigTextSize       = 16;
extern color  bigTextColor      = clrBlue;
extern color  bigTextColorBearish = clrRed;
extern int    bigTextX          = 50;
extern int    bigTextY          = 50;
extern bool   ExtVisible        = true;
extern int    ExtComplekt       = 3;
//===================================

// Массивы для ZigZag 
// Массив для отрисовки ZigZag
double zz[];
// Массив минимумов ZigZag
double zzL[];
// Массив максимумов ZigZag
double zzH[];
// Массивы для nen-ZigZag
double nen_ZigZag[];

int    _maxbarZZ; // количество баров, участвующих в расчете зигзагов.

// переменные для хранения параметров стандартного зигзага
int _ExtBackstep, _minBars, _minSize;

// Массив чисел, заданных пользователем
double fi[];
string fitxt[];
string fitxt100[];
int    Sizefi=0,Sizefi_1=0;

color  ExtLine_;

double number[64];
string numbertxt[64];
int    numberFibo[64];
int    numberPesavento[64];
int    numberGartley[64];
int    numberMix[64];
int    numberGilmorQuality[64];
int    numberGilmorGeometric[64];
int    numberGilmorHarmonic[64];
int    numberGilmorArithmetic[64];
int    numberGilmorGoldenMean[64];
int    numberSquare[64];
int    numberCube[64];
int    numberRectangle[64];
int    numberExt[64];

string nameObj="", nameObjtxt="", save="";
// 
bool descript_b=false;
// PPWithBars - текст, выводимый у соединительной линии
// descript - описание объектов
string PPWithBars="", descript="";
// Матрица для поиска исчезнувших баров afr - массив значений времени пяти последних фракталов и отрисовки динамических и статических фиб
// afrl - минимумы, afrh - максимумы
int afr[]={0,0,0,0,0,0,0,0,0,0};
double afrl[]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}, afrh[]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}, afrx[]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
// Параметры таймфрймов
double openTF[]={0.0,0.0,0.0,0.0,0.0}, closeTF[]={0.0,0.0,0.0,0.0,0.0}, lowTF[]={0.0,0.0,0.0,0.0,0.0}, highTF[]={0.0,0.0,0.0,0.0,0.0};
string TF[]={"MN","W1","D1","H4","H1","m30","m15","m5","m1"};
string Period_tf="";
bool   afrm=true;
double ExtHL;
double HL,HLp,kk,kj,Angle;
// LowPrim,HighPrim,LowLast,HighLast - значения минимумов и максимумов баров
double LowPrim,HighPrim,LowLast,HighLast;
// numLowPrim,numHighPrim,numLowLast,numHighLast -номера баров
int numLowPrim,numHighPrim,numLowLast,numHighLast,k1,k2,countLow1,countHigh1,shift1,shift2,shift3;
string txtkk="", txtRet="";
// Время бара с первым, вторым и третьим от нулевого бара фракталом
int timeFr1new,timeFr2new,timeFr3new;
// Счетчик фракталов
int countFr;
// Бар, до которого надо рисовать соединительные линии от нулевого бара
int countBarEnd=0,TimeBarEnd;
// Бар, до которого надо пересчитывать от нулевого бара
int numBar=0;
// Номер объекта
int numOb;
// flagFrNew=true - образовался новый фрактал или первый фрактал сместился на другой бар. =false - по умолчанию.
bool flagFrNew=false;
// идентификатор нового луча
bool newRay=true;
// flagGartley - появление нового паттерна Gartley или исчезновение паттерна Gartley
bool flagGartley=false;
// Период текущего графика
int perTF;
bool Demo;
// Переменные для зигзага, разработанного wellx
bool   first=true;
int    NewBarTime=0, countbars=0;
int    realcnt=0;

double int_to_d=0, int_to_d1=0, int_to_d2=0;

int counted_bars, cbi, iBar;

// Переменные для ZigZag Алекса и индикатора подобного встроенному в Ensign
double ha[],la[],hi,li,si,sip,di,hm,lm,ham[],lam[],him,lim,lLast=0,hLast=0;
int fs=0,fsp,countBar;
int ai,bi,ai0,bi0,aim,bim;
datetime tai,tbi,ti,tmh,tml;
// fcount0 - при обнулении счетчика пропущенных баров на 0 баре fcount0=true.
// На следующем баре =false и можно определять точку перелома
bool fh=false,fl=false,fcount0,PeakDetIni;

/*
// Переменные для Свингов Ганна
double lLast_m=0, hLast_m=0;
int countBarExt; // счетчик внешних баров
int countBarl,countBarh;
*/
// Переменные для nen-ZigZag
bool hi_nen;
bool init_zz=true;

// Переменные для расширенного режима работы индикатора
int mFibo[]={0,0};

double   hBar, lBar;
datetime tiZZ;

// Переменные для паттернов Gartley
string   vBullBear    = ""; // переменная для обозначения бычий или медвежий паттерн
string   vNamePattern = ""; // переменная для обозначения наименования паттерна
string   vBullBearToNumberPattern    = "";
string   vNamePatternToNumberPattern = "";
string   _InfoPointD                 = "";
bool     vPatOnOff = false, vPatNew = false, saveParametersZZ=false;
bool     vWriteToFilePattern = false, vpicture=false;

datetime TimeForDmin  = 0, TimeForDminToNumberPattern;
datetime TimeForDmax  = 0, TimeForDmaxToNumberPattern;
double   LevelForDmin = 0, LevelForDminToNumberPattern;
double   LevelForDmax = 0, LevelForDmaxToNumberPattern;
double   save_cenaPointD;
datetime save_timePointD_0;
double   PeakCenaX[1],PeakCenaA[1],PeakCenaB[1],PeakCenaC[1],PeakCenaD[1];
datetime PeakTimeX[1],PeakTimeA[1],PeakTimeB[1],PeakTimeC[1],PeakTimeD[1];
string   __NamePatterns[1][2];
int      __D[1][4];
color    __PatColor[1];
int      countGartley = 0;      // Счетчик паттернов
int      minBarsToNumberPattern;
int      minSizeToNumberPattern;
int      vBackstepToNumberPattern;
double   minPercentToNumberPattern;
color    ColorList[];
int      ColorSize;
int      countColor   = 0;
bool     flagExtGartleyTypeSearch2=false; // сигнал выключения поиска паттернов в режиме китайская игрушка
int      minBarsSave, minBarsX;

bool     CustomPat_[33];

//string   namepatterns[];
string namepatterns[33]=
{"Gartley","Bat","Alternate Bat","Butterfly","Crab","Deep Crab","Leonardo","Shark","Cypher","Nen STAR","5-0",
"A Gartley","A Bat","A Alternate Bat","A Butterfly","A Crab","A Deep Crab","A Leonardo","A Shark","A Cypher","A Nen STAR","A 5-0",
"Black Swan","White Swan","Navarro 200","max Bat","max Gartley","max Butterfly","TOTAL 1","TOTAL 2","TOTAL 3","TOTAL 4","TOTAL"};

int countPat;
int typepatterns[33];
//  0    1     2     3     4     5     6     7     8      9      10     11     12     13     14      15
//minXB,maxXB,minAC,maxAC,minBD,maxBD,minXD,maxXD,minXXA,maxXXA,minXCD,maxXCD,minXAB,maxXDC,TimeXXB,lineXB
//double pp[,16];                                                   // priznakipatterns=pp

double pp[33][16]=                                                 // priznakipatterns=pp
{0.618,0.618,0.382,0.886,1.128,1.618,0.786,0.786,0,0,0,0,0,0,0,1,
0.382,0.5,0.382,0.886,1.618,2.618,0.886,0.886,0,0,0,0,1.272,0,0,1,
0.382,0.382,0.382,0.886,2.0,4.236,1.128,1.128,0,0,0,0,1.618,0,0,1,
0.786,0.786,0.382,0.886,1.618,2.618,1.272,1.618,0,0,0,0,1.272,0,0,1,
0.382,0.618,0.382,0.886,2.236,4.236,1.618,1.618,0,0,0,0,0,0,0,1,
0.886,0.886,0.382,0.886,2.618,4.236,1.618,1.618,0,0,0,0,0,0,0,1,
0.5,0.5,0.382,0.886,1.128,2.618,0.786,0.786,0,0,0,0,0,0,0,1,
0,0,1.128,1.618,1.618,2.236,0.886,1.128,0,0,0,0,0,0,0,1,
0.382,0.618,0,0,0,0,0.786,0.786,1.272,1.414,0,0,0,0,0,1,
0.382,0.618,0,0,0,0,1.272,1.272,1.272,1.414,0,0,0,0,0,1,
1.128,1.618,1.618,2.236,0.5,0.5,0,0,0,0,0,0,0,0,0,0,
0.618,0.886,1.128,2.618,1.618,1.618,1.272,1.272,0,0,0,0,0,0,0,1,
0.382,0.618,1.128,2.618,2.0,2.618,1.128,1.128,0,0,0,0,0,0.786,0,1,
0.236,0.5,1.128,2.618,2.618,2.618,0.886,0.886,0,0,0,0,0,0.618,0,1,
0.382,0.618,1.128,2.618,1.272,1.272,0.618,0.786,0,0,0,0,0,0.786,0,1,
0.236,0.447,1.128,2.618,1.128,2.618,0.618,0.618,0,0,0,0,0,0,0,1,
0.236,0.382,1.128,2.618,1.128,1.128,0.618,0.618,0,0,0,0,0,0,0,1,
0.382,0.886,1.128,2.618,2.0,2.0,1.272,1.272,0,0,0,0,0,0,0,1,
0.447,0.618,0.618,0.886,0,0,0.886,1.128,0,0,0,0,0,0,0,1,
0,0,0,0,1.618,2.618,1.272,1.272,0,0,1.272,1.414,0,0,0,0,
0,0,0,0,1.618,2.618,0.786,0.786,0,0,1.272,1.414,0,0,0,1,
2.0,2.0,0.447,0.618,0.618,0.886,0,0,0,0,0,0,0,0,0,0,
1.382,2.618,0.236,0.5,1.128,2.0,1.128,2.618,0,0,0,0,0,0,0,0,
0.382,0.724,2.0,4.236,0.5,0.886,0.382,0.886,0,0,0,0,0,0,0,0,
0.786,0.786,0.886,1.128,0,0,0.886,1.128,0,0,0,0,0,0,1,0,
0.382,0.618,0.382,0.886,1.272,2.618,0.886,0.886,0,0,0,0,1.272,0,0,1,
0.382,0.618,0.382,0.886,1.128,2.236,0.618,0.786,0,0,0,0,0,0,0,1,
0.618,0.886,0.382,0.886,1.272,2.618,1.272,1.618,0,0,0,0,1.272,0,0,1,
0.382,0.786,0.382,0.886,1.272,2.618,0.786,0.886,0,0,0,0,0,0,0,1,
0.382,0.786,0.382,0.886,1.618,4.236,1.128,1.618,0,0,0,0,0,0,0,1,
0.236,0.618,1.128,2.618,1.272,2.618,0.618,0.886,0,0,0,0,0,0,0,1,
0.382,0.786,1.128,2.618,1.618,2.618,1.128,1.272,0,0,0,0,0,0,0,1,
0.236,0.786,0.382,2.618,1.272,4.236,0.618,1.618,0,0,0,0,0,0,0,1};

int retresmentXD[][2], retresmentBD[][2], arrXD_BD[2];

double minXB_[33], maxXB_[33], minAC_[33], maxAC_[33], minBD_[33], maxBD_[33], minXD_[33], maxXD_[33], minXXA_[33], maxXXA_[33], minXCD_[33], maxXCD_[33], minXAB_[33], maxXDC_[33];

int      levelXD[32,2];   // номер паттерна, код уровня
double   level_D[32];     // значение цены потенциального уровня точки D паттерна
string   level_nameD[32]; // наименование потенциального уровня точки D паттерна

double   deltapatterns[3][20][2];
//                          0      1     2     3    4   5      6     7    8    9    10   11    12     13   14   15    16    17    18    19
double   retpatterns[20]={0.146,0.236,0.382,0.447,0.5,0.618,0.707,0.786,0.886,1.0,1.128,1.272,1.414,1.618,2.0,2.236,2.618,3.1416,3.618,4.236};
string   retpatternstxt[20]={".146",".236",".382",".447",".5",".618",".707",".786",".886","1.0","1.128","1.272","1.414","1.618","2.0","2.236","2.618","3.14","3.618","4.236"};
double   min_DeltaGartley, max_DeltaGartley;
int      ret[5][2]; // XD-XB-AC-BD, во втором измерении для ExtDeltaGartley - 2, для ExtDelta - 1, для ExtDeltaGartleyPRZ - 0

double   _ABCDtype[];
string   _ABCDtypetxt[];
int      _ABCDsize;

int f=1; // для alerta

// Переменные для Merrill Patterns
double   mPeak0[5][2]={0,5,0,4,0,3,0,2,0,1}, mPeak1[5][2]={0,5,0,4,0,3,0,2,0,1};
string   mMerrillPatterns[32][3]=
{"21435", "M1", "DownTrend",
"21453", "M2", "InvertedHeadAndShoulders",
"24135", "M3", "DownTrend",
"24153", "M4", "InvertedHeadAndShoulders",
"42135", "M5", "Broadening",
"42153", "M6", "InvertedHeadAndShoulders",
"24315", "M7", "*",
"24513", "M8", "InvertedHeadAndShoulders",
"42315", "M9", "*",
"42513", "M10", "InvertedHeadAndShoulders",
"45213", "M11", "InvertedHeadAndShoulders",
"24351", "M12", "*",
"24531", "M13", "Triangle",
"42351", "M14", "*",
"42531", "M15", "UpTrend",
"45231", "M16", "UpTrend",
"13245", "W1", "DownTrend",
"13524", "W2", "DownTrend",
"15324", "W3", "*",
"13224", "W4", "Triangle",
"15342", "W5", "*",
"31254", "W6", "HeadAndShoulders",
"42513", "W7", "HeadAndShoulders",
"51324", "W8", "*",
"31542", "W9", "HeadAndShoulders",
"51324", "W10", "*",
"35124", "W11", "HeadAndShoulders",
"53124", "W12", "Broadening",
"35142", "W13", "HeadAndShoulders",
"53142", "W14", "UpTrend",
"35412", "W15", "HeadAndShoulders",
"53412", "W16", "UpTrend"};

// Переменные для зигзага Talex
static int    endbar = 0;
static double endpr  = 0;
// Переменные для построения вил Эндрюса от произвольных свечей
bool   tik1 = true;

//+------------------------------------------------------------------+
//| Custom indicator initialization function. Начало.                |
//+------------------------------------------------------------------+
int init()
  {
   if (!ExtVisible) return(-1);

   string aa="", aa1="", txt="";
   int i, j, k, m;
   int bb=0,bb1=-1;

   if (ParametresZZforDMLEWA>0 && (ExtIndicator==0 || ExtIndicator==6 || (NumberPattern==0 && ExtIndicator==11)))
     {
      switch (ParametresZZforDMLEWA)
        {
         case 1:
           _minBars=5; _ExtBackstep=8;
           break;
         case 2:
           _minBars=8; _ExtBackstep=13;
           break;
         case 3:
           _minBars=13; _ExtBackstep=21;
           break;
         case 4:
           _minBars=21; _ExtBackstep=34;
           break;
         case 5:
           _minBars=34; _ExtBackstep=55;
           break;
         case 6:
           _minBars=55; _ExtBackstep=89;
           break;
         case 7:
           _minBars=89; _ExtBackstep=144;
           break;
         case 8:
           _minBars=144; _ExtBackstep=233;
        }
     }
   else
     {
      _minBars=minBars; _ExtBackstep=ExtBackstep;
     }
   minBarsToNumberPattern=_minBars; vBackstepToNumberPattern=_ExtBackstep;
   minBarsSave=minBars;

   IndicatorBuffers(8);

   if (ExtIndicator==14)
     {
      if (auto)
        {
         double wrmassiv[];

         if (minBar>=100) minBar=61.8;
         if (minBar<=0)   minBar=61.8;
         if (maxBar>=100) maxBar=38.2;
         if (minBar<=0)   minBar=38.2;

         ArrayResize(wrmassiv,Bars-1);
         for (i=Bars-1;i>0;i--) {wrmassiv[i]=High[i]-Low[i]+Point;}
         ArraySort (wrmassiv);
         i=MathFloor(minBar*Bars/100);
         StLevel=MathFloor(wrmassiv[i]/Point);
         i=MathFloor(maxBar*Bars/100);
         BigLevel=MathFloor(wrmassiv[i]/Point);
        }
     }

   if (ExtMaxBar>Bars) ExtMaxBar=Bars;
   if (ExtMaxBar>0) _maxbarZZ=ExtMaxBar; else _maxbarZZ=Bars;

// -------
// Gartley Patterns

   if ((ExtIndicator==11 && ExtGartleyTypeSearch>0) || PotencialsLevels_retXD<0 || (ExtIndicator!=11 && ExtGartleyOnOff==false)) PotencialsLevels_retXD=0;
   if (PotencialsLevels_retXD>2) PotencialsLevels_retXD=2;

   if (ExtIndicator==11 || ExtGartleyOnOff || PotencialsLevels_retXD>0)
     {
      ArrayInitialize(PeakCenaX,0);
      ArrayInitialize(PeakCenaA,0);
      ArrayInitialize(PeakCenaB,0);
      ArrayInitialize(PeakCenaC,0);
      ArrayInitialize(PeakCenaD,0);

      ArrayInitialize(PeakTimeX,0);
      ArrayInitialize(PeakTimeA,0);
      ArrayInitialize(PeakTimeB,0);
      ArrayInitialize(PeakTimeC,0);
      ArrayInitialize(PeakTimeD,0);

//      ArrayInitialize(__NamePatterns,"");
      ArrayInitialize(__D,0);
      ArrayInitialize(__PatColor,0);

      if (writeInfoPatternsToFileXML<0) writeInfoPatternsToFileXML=0;
      if (writeInfoPatternsToFileXML>2) writeInfoPatternsToFileXML=2;
      if (writeInfoPatternsToFileCSV<0) writeInfoPatternsToFileCSV=0;
      if (writeInfoPatternsToFileCSV>2) writeInfoPatternsToFileCSV=2;

      min_DeltaGartley = (1 - ExtDeltaGartley);
      max_DeltaGartley = (1 + ExtDeltaGartley);

      for (i=0;i<20;i++)
        {
         deltapatterns[2][i][0]=retpatterns[i]*min_DeltaGartley;
         deltapatterns[2][i][1]=retpatterns[i]*max_DeltaGartley;

         deltapatterns[1][i][0]=retpatterns[i]*(1 - ExtDelta);
         deltapatterns[1][i][1]=retpatterns[i]*(1 + ExtDelta);

         deltapatterns[0][i][0]=retpatterns[i]*(1 - ExtDeltaGartleyPRZ);
         deltapatterns[0][i][1]=retpatterns[i]*(1 + ExtDeltaGartleyPRZ);
        }

      if (CustomPattern>0)
        {
         minAC = min_DeltaGartley * minAC;
         minBD = min_DeltaGartley * minBD;
         minXB = min_DeltaGartley * minXB;
         minXD = min_DeltaGartley * minXD;

         maxAC = max_DeltaGartley * maxAC;
         maxBD = max_DeltaGartley * maxBD;
         maxXB = max_DeltaGartley * maxXB;
         maxXD = max_DeltaGartley * maxXD;
        }

//      countPat=33;
      countPat=ArraySize(namepatterns);

      if (readFromFileListPatterns<0) readFromFileListPatterns=0;
      if (readFromFileListPatterns>2) readFromFileListPatterns=2;
      if (readFromFileListPatterns>0) mreadFromFileListPatterns();
      if (writeToFileListPatterns) mwriteToFileListPatterns();

      ArrayResize(namepatterns,countPat);

      ArrayResize(CustomPat_,countPat);
      ArrayResize(typepatterns,countPat);
      ArrayInitialize(typepatterns,-1);
      ArrayResize(minXB_,countPat);
      ArrayResize(maxXB_,countPat);
      ArrayResize(minAC_,countPat);
      ArrayResize(maxAC_,countPat);
      ArrayResize(minBD_,countPat);
      ArrayResize(maxBD_,countPat);
      ArrayResize(minXD_,countPat);
      ArrayResize(maxXD_,countPat);
      ArrayResize(minXXA_,countPat);
      ArrayResize(maxXXA_,countPat);
      ArrayResize(minXCD_,countPat);
      ArrayResize(maxXCD_,countPat);
      ArrayResize(minXAB_,countPat);
      ArrayResize(maxXDC_,countPat);
/*
      namepatterns[countPat]=
      {"Gartley","Bat","Alternate Bat","Butterfly","Crab","Deep Crab","Leonardo","Shark","Cypher","Nen STAR","5-0",
      "A Gartley","A Bat","A Alternate Bat","A Butterfly","A Crab","A Deep Crab","A Leonardo","A Shark","A Cypher","A Nen STAR","A 5-0",
      "Black Swan","White Swan","Navarro","TOTAL 1","TOTAL 2","TOTAL 3","TOTAL 4","TOTAL"};

//  0    1     2     3     4     5     6     7     8      9      10     11     12     13     14      15
//minXB,maxXB,minAC,maxAC,minBD,maxBD,minXD,maxXD,minXXA,maxXXA,minXCD,maxXCD,minXAB,maxXDC,TimeXXB,lineXB
*/
      
//  0    1     2     3     4     5     6     7     8      9      10     11     12     13     14     
//minXB,maxXB,minAC,maxAC,minBD,maxBD,minXD,maxXD,minXXA,maxXXA,minXCD,maxXCD,minXAB,maxXDC,TimeXXB
      double max_ = 1000000; k=0; m=0;
      for (i=0;i<countPat;i++)
        {
         minXB_[i] = min_DeltaGartley * pp[i][0];
         maxXB_[i] = max_DeltaGartley * pp[i][1];

         minAC_[i] = min_DeltaGartley * pp[i][2];
         maxAC_[i] = max_DeltaGartley * pp[i][3];

         minBD_[i] = min_DeltaGartley * pp[i][4];
         maxBD_[i] = max_DeltaGartley * pp[i][5];

         minXD_[i] = min_DeltaGartley * pp[i][6];
         maxXD_[i] = max_DeltaGartley * pp[i][7];

         minXXA_[i] = min_DeltaGartley * pp[i][8];
         maxXXA_[i] = max_DeltaGartley * pp[i][9];
         minXCD_[i] = min_DeltaGartley * pp[i][10];
         maxXCD_[i] = max_DeltaGartley * pp[i][11];
         minXAB_[i] = min_DeltaGartley * pp[i][12];
         maxXDC_[i] = max_DeltaGartley * pp[i][13];

         // классика и А классика typepatterns[i] = 0
         if (maxXB_[i]>0 && maxAC_[i]>0 && maxBD_[i]>0 && maxXD_[i]>0 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]==0 && pp[i][13]==0 && pp[i][14]==0) typepatterns[i] = 0;
         // Bat & Butterfly typepatterns[i] = 1
         else if (maxXB_[i]>0 && maxAC_[i]>0 && maxBD_[i]>0 && maxXD_[i]>0 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]>0 && pp[i][13]==0 && pp[i][14]==0) typepatterns[i] = 1;
         // A Bat & A Butterfly typepatterns[i] = 2
         else if (maxXB_[i]>0 && maxAC_[i]>0 && maxBD_[i]>0 && maxXD_[i]>0 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]==0 && pp[i][13]>0 && pp[i][14]==0) typepatterns[i] = 2;
         // 5-0 и A 5-0 typepatterns[i] = 3
         else if (maxXB_[i]>0 && maxAC_[i]>0 && maxBD_[i]>0 && maxXD_[i]<0.0001 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]==0 && pp[i][13]==0 && pp[i][14]==0) typepatterns[i] = 3;
         // Cypher typepatterns[i] = 4
         else if (maxXB_[i]>0 && maxAC_[i]<0.0001 && maxBD_[i]<0.0001 && maxXD_[i]>0 && pp[i][8]>0 && pp[i][9]>0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]==0 && pp[i][13]==0 && pp[i][14]==0) typepatterns[i] = 4;
         // A Cypher typepatterns[i] = 5
         else if (maxXB_[i]<0.0001 && maxAC_[i]<0.0001 && maxBD_[i]>0 && maxXD_[i]>0 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]>0 && pp[i][11]>0 && pp[i][12]==0 && pp[i][13]==0 && pp[i][14]==0) typepatterns[i] = 5;
         // Shark typepatterns[i] = 6
         else if (maxXB_[i]<0.0001 && maxAC_[i]>0 && maxBD_[i]>0 && maxXD_[i]>0 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]==0 && pp[i][13]==0 && pp[i][14]==0) typepatterns[i] = 6;
         // A Shark typepatterns[i] = 7
         else if (maxXB_[i]>0 && maxAC_[i]>0 && maxBD_[i]<0.0001 && maxXD_[i]>0 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]==0 && pp[i][13]==0 && pp[i][14]==0) typepatterns[i] = 7;
         // Navarro typepatterns[i] = 8
         else if (maxXB_[i]>0 && maxAC_[i]>0 && maxXD_[i]>0 && pp[i][8]==0 && pp[i][9]==0 && pp[i][10]==0 && pp[i][11]==0 && pp[i][12]==0 && pp[i][13]==0 && pp[i][14]>0) typepatterns[i] = 8;

         if (pp[i][6]>0 && pp[i][7]>0)
           {
            for (j=0;j<20;j++)
              {
               if (retpatterns[j]>=pp[i][6] && retpatterns[j]<=pp[i][7])
                 {
                  k++; ArrayResize(retresmentXD,k);
                  retresmentXD[k-1][0]=i; // номер паттерна в списке
                  retresmentXD[k-1][1]=j; // номера возможных ретресментов XD для данного паттерна
                 }
               if (retpatterns[j]>pp[i][7]) break;
              }
           }

         if (pp[i][4]>0 && pp[i][5]>0)
           {
            for (j=0;j<20;j++)
              {
               if (retpatterns[j]>=pp[i][4] && retpatterns[j]<=pp[i][5])
                 {
                  m++; ArrayResize(retresmentBD,m);
                  retresmentBD[m-1][0]=i; // номер паттерна в списке
                  retresmentBD[m-1][1]=j; // номера возможных ретресментов XB для данного паттерна
                 }
               if (retpatterns[j]>pp[i][5]) break;
              }
           }
        }

      arrXD_BD[0]=ArraySize(retresmentXD)/2; // размер массива retresmentXD
      arrXD_BD[1]=ArraySize(retresmentBD)/2; // размер массива retresmentBD

      if (ExtGartleyTypeSearch<0) ExtGartleyTypeSearch=0;
      if (ExtGartleyTypeSearch>2) ExtGartleyTypeSearch=2;

      if (ExtIndicator==11)
        {
         if (ExtHiddenPP<0) ExtHiddenPP=0;
         if (ExtHiddenPP>2) ExtHiddenPP=2;

         if (IterationStepDepth<1) IterationStepDepth=1;
         if (IterationStepDepth>maxDepth-minDepth) IterationStepDepth=maxDepth-minDepth;

         if (IterationStepSize<1) IterationStepSize=1;
         if (IterationStepSize>maxSize_-minSize_) IterationStepSize=maxSize_-minSize_;

         if (IterationStepPercent<1) IterationStepPercent=1;
        }

      if (NumberPattern<0) NumberPattern=0;

      if (ExtIndicator==11 && (ExtHiddenPP==0 || ExtHiddenPP==2)) {ExtHidden=0; ExtStyleZZ=false;}

      if (ExtGartleyTypeSearch>0)
        {
         if (patternInfluence==0)
           {
            if (ExtMaxBar>0)
              {
               if (maxBarToD==0 || maxBarToD>ExtMaxBar) maxBarToD=ExtMaxBar-15;
              }
            else if (maxBarToD==0) maxBarToD=Bars-15;
           }

         ColorSize=0;
         _stringtocolorarray (ExtColorPatternList, ColorList, ColorSize); // Подготовка списка значений цвета для бабочек Gartley, заданных пользователем
        }

      if (CustomPattern<0) CustomPattern=0;
      if (CustomPattern>2) CustomPattern=2;

      if (readFromFileListPatterns!=1)
        {
         switch(SelectPattern)
           {
            case 1: // только классические
               ArrayInitialize(CustomPat_,false);
               CustomPat_[0]=true;
               CustomPat_[1]=true;
               CustomPat_[2]=true;
               CustomPat_[3]=true;
               CustomPat_[4]=true;
               CustomPat_[5]=true;
               CustomPat_[6]=true;
               CustomPat_[7]=true;
               CustomPat_[10]=true;
               CustomPat_[25]=true;
               CustomPat_[26]=true;
               CustomPat_[27]=true;
               break;
            case 2: // классические и антиклассические
               ArrayInitialize(CustomPat_,false);
               CustomPat_[0]=true;
               CustomPat_[1]=true;
               CustomPat_[2]=true;
               CustomPat_[3]=true;
               CustomPat_[4]=true;
               CustomPat_[5]=true;
               CustomPat_[6]=true;
               CustomPat_[7]=true;
               CustomPat_[10]=true;

               CustomPat_[11]=true;
               CustomPat_[12]=true;
               CustomPat_[13]=true;
               CustomPat_[14]=true;
               CustomPat_[15]=true;
               CustomPat_[16]=true;
               CustomPat_[17]=true;
               CustomPat_[18]=true;
               CustomPat_[21]=true;

               CustomPat_[25]=true;
               CustomPat_[26]=true;
               CustomPat_[27]=true;
               break;
            case 3: // экзотика
               ArrayInitialize(CustomPat_,false);
               CustomPat_[8]=true;
               CustomPat_[9]=true;
               CustomPat_[19]=true;
               CustomPat_[20]=true;
               CustomPat_[22]=true;
               CustomPat_[23]=true;
               CustomPat_[24]=true;
               break;
            case 4: // только антипаттерны
               ArrayInitialize(CustomPat_,false);
               CustomPat_[11]=true;
               CustomPat_[12]=true;
               CustomPat_[13]=true;
               CustomPat_[14]=true;
               CustomPat_[15]=true;
               CustomPat_[16]=true;
               CustomPat_[17]=true;
               CustomPat_[18]=true;
               CustomPat_[19]=true;
               CustomPat_[20]=true;
               CustomPat_[21]=true;
               break;
            case 5: // все кроме TOTAL
               ArrayInitialize(CustomPat_,true);
               CustomPat_[28]=false;
               CustomPat_[29]=false;
               CustomPat_[30]=false;
               CustomPat_[31]=false;
               CustomPat_[32]=false;
               break;
            case 6: // только TOTAL
               ArrayInitialize(CustomPat_,false);
               CustomPat_[28]=true;
               CustomPat_[29]=true;
               CustomPat_[30]=true;
               CustomPat_[31]=true;
               CustomPat_[32]=true;
               break;
            case 7: // произвольный выбор пятиточечных паттернов для поиска
               j=StringLen(visiblePattern);
               for(i=0;i<j;i++)
                 {
                  if (StringSubstr(visiblePattern,i,1)=="1") CustomPat_[i]=true; else CustomPat_[i]=false;
                 }
           }

         if (readFromFileListPatterns==2 && SelectPattern!=8)
           {
            for (i=countPat-1;i>32;i--) CustomPat_[i]=true;
           }
        }
      else if (SelectPattern!=8) SelectPattern=0;

      if (SelectPattern==0) ArrayInitialize(CustomPat_,true); // все

      if (searchABCDAlternate)
        {
         _stringtodoublearray (ABCDAlternate, _ABCDtype, _ABCDtypetxt, _ABCDsize, false);
        }

      if (ABCD>2) ABCD=2;
     }

// Gartley Patterns
// -------

   if (ExtStyleZZ) {SetIndexStyle(0,DRAW_SECTION);}
   else {SetIndexStyle(0,DRAW_ARROW); SetIndexArrow(0,158);}

   if (ExtLabel>0)
     {
      SetIndexStyle(3,DRAW_ARROW); SetIndexArrow(3,ExtCodLabel);
      SetIndexStyle(4,DRAW_ARROW); SetIndexArrow(4,ExtCodLabel);
     }
   else
     {
      SetIndexStyle(3,DRAW_LINE,STYLE_DOT);
      SetIndexStyle(4,DRAW_LINE,STYLE_DOT);
     }

   SetIndexLabel(0,StringConcatenate("ZUP",ExtComplekt," (zz",ExtIndicator,")"));
   if (ExtIndicator==6)
     {
      if (noBackstep)
        {
         SetIndexLabel(5,StringConcatenate("ZUP",ExtComplekt," DT6_",minBars,"/GP=",GrossPeriod));
        }
      else
        {
          SetIndexLabel(5,StringConcatenate("ZUP",ExtComplekt," DT6_",minBars+"/",ExtBackstep,"/GP=",GrossPeriod));
        }
     }
   else if (ExtIndicator==7) SetIndexLabel(5,StringConcatenate("ZUP",ExtComplekt," DT7_",minBars,"/GP=",GrossPeriod));
   else if (ExtIndicator==8) SetIndexLabel(5,StringConcatenate("ZUP",ExtComplekt," DT8_",minBars,"/",ExtDeviation,"/GP=",GrossPeriod));

   if (ExtLabel>0)
     {
      SetIndexLabel(1,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," H_PeakDet"));
      SetIndexLabel(2,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," L_PeakDet"));
      SetIndexLabel(3,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," UpTrend"));
      SetIndexLabel(4,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," DownTrend"));
     }
   else
     {
      if (chHL_PeakDet)
        {
         PeakDetIni=true;
         SetIndexLabel(1,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," H_PeakDet"));
         SetIndexLabel(2,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," L_PeakDet"));
         SetIndexLabel(3,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," H_chHL"));
         SetIndexLabel(4,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," L_chHL"));
        }
     }

// Уровни предыдущих пиков
   SetIndexStyle(1,DRAW_LINE,STYLE_DOT);
   SetIndexStyle(2,DRAW_LINE,STYLE_DOT); 
   SetIndexBuffer(1,ham);
   SetIndexBuffer(2,lam);
// Уровни подтверждения
   SetIndexBuffer(3,ha);
   SetIndexBuffer(4,la);

   SetIndexBuffer(0,zz);
   SetIndexBuffer(5,nen_ZigZag);
   SetIndexBuffer(6,zzL);
   SetIndexBuffer(7,zzH);

   SetIndexStyle(5,DRAW_ARROW);
   SetIndexArrow(5,159);

   SetIndexEmptyValue(0,0.0);
   SetIndexEmptyValue(1,0.0);
   SetIndexEmptyValue(2,0.0);
   SetIndexEmptyValue(3,0.0);
   SetIndexEmptyValue(4,0.0);
   SetIndexEmptyValue(5,0.0);
   SetIndexEmptyValue(6,0.0);
   SetIndexEmptyValue(7,0.0);

   if (ExtIndicator<6 || ExtIndicator>10)
     {
      switch (Period())
        {
         case 1     : {Period_tf=TF[8];break;}
         case 5     : {Period_tf=TF[7];break;}
         case 15    : {Period_tf=TF[6];break;}
         case 30    : {Period_tf=TF[5];break;}
         case 60    : {Period_tf=TF[4];break;}
         case 240   : {Period_tf=TF[3];break;}
         case 1440  : {Period_tf=TF[2];break;}
         case 10080 : {Period_tf=TF[1];break;}
         case 43200 : {Period_tf=TF[0];break;}
        }
     }
   else
     {
      switch (GrossPeriod)
        {
         case 1     : {Period_tf=TF[8];break;}
         case 5     : {Period_tf=TF[7];break;}
         case 15    : {Period_tf=TF[6];break;}
         case 30    : {Period_tf=TF[5];break;}
         case 60    : {Period_tf=TF[4];break;}
         case 240   : {Period_tf=TF[3];break;}
         case 1440  : {Period_tf=TF[2];break;}
         case 10080 : {Period_tf=TF[1];break;}
         case 43200 : {Period_tf=TF[0];break;}
        }

      if (GrossPeriod>43200)
        {
         if (MathMod(GrossPeriod,43200)>0) Period_tf=GrossPeriod; else Period_tf=TF[0]+GrossPeriod/43200 + ""; 
        }
      else if (GrossPeriod<43200)
        {
         if (GrossPeriod>10080)
           { 
            if (MathMod(GrossPeriod,10080)>0) Period_tf=GrossPeriod; else Period_tf="W"+GrossPeriod/10080 + ""; 
           }
         else if (GrossPeriod<10080)
           {
            if (GrossPeriod>1440)
              { 
               if (MathMod(GrossPeriod,1440)>0) Period_tf=GrossPeriod; else Period_tf="D"+GrossPeriod/1440 + ""; 
              }
            else if (GrossPeriod<1440)
              {
               if (GrossPeriod!=60)
                 { 
                  if (MathMod(GrossPeriod,60)>0) Period_tf=GrossPeriod; else Period_tf="H"+GrossPeriod/60 + ""; 
                 }
              }
           }
        }
     }
      if (minSize==0 && minPercent!=0) di=minPercent*Close[i]/2/100;

   if (ExtIndicator==1) if (minSize!=0) di=minSize*Point/2;
   if (ExtIndicator==2) {di=minSize*Point; countBar=minBars;}
   if (ExtIndicator==3) {countBar=minBars;}

   if (ExtIndicator>5 && ExtIndicator<11 && GrossPeriod>Period())
     {
      if (GrossPeriod==43200 && Period()==10080) maxBarToD=maxBarToD*5; else maxBarToD=maxBarToD*GrossPeriod/Period();
     }
   
   if (ExtIndicator<6 ||ExtIndicator>10) GrossPeriod=Period();

   if (ExtFiboType<0) ExtFiboType=0;
   if (ExtFiboType>2) ExtFiboType=2;

   if (ExtFiboType==2) // Подготовка списка фиб, заданных пользователем
     {
      _stringtodoublearray (ExtFiboTypeFree, fi, fitxt, Sizefi, true);
     }
// -------
 
// Проверка правильности введенных внешних переменных
   if (ExtDelta<=0) ExtDelta=0.001;
   if (ExtDelta>1) ExtDelta=0.999;

   if (ExtHidden<0) ExtHidden=0;
   if (ExtHidden>5) ExtHidden=5;
 
   if (ExtDeltaType<0) ExtDeltaType=0;
   if (ExtDeltaType>3) ExtDeltaType=3;

   if (ExtFiboChoice<0) ExtFiboChoice=0;
   if (ExtFiboChoice>11) ExtFiboChoice=11;

   if (ExtFractalEnd>0)
     {
      if (ExtFractalEnd<1) ExtFractalEnd=1;
     }

   if (ExtFiboStaticNum<2) ExtFiboStaticNum=2;

   if (ExtFiboStaticNum>9)
     {
      aa=DoubleToStr(ExtFiboStaticNum,0);
      aa1=StringSubstr(aa,0,1);
      mFibo[0]=StrToInteger(aa1);
      aa1=StringSubstr(aa,1,1);
      mFibo[1]=StrToInteger(aa1);
     }
   else
     {
      mFibo[0]=ExtFiboStaticNum;
      mFibo[1]=ExtFiboStaticNum-1;
     }

   if (ExtSave)
     {
      MathSrand(LocalTime());
      save=MathRand();
     }
   
   array_();
   perTF=Period();
   Demo=IsDemo();
   delete_objects1();

   return(0);
  }
//+------------------------------------------------------------------+
//| Custom indicator initialization function. Конец.                 |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| Деинициализация. Удаление всех трендовых линий и текстовых объектов. Начало.
//+------------------------------------------------------------------+
int deinit()
  {
   ObjectDelete(StringConcatenate("fiboS",ExtComplekt,"_"));

   ObjectDelete(StringConcatenate("LinePivotZZ","1",ExtComplekt,"_"));
   ObjectDelete(StringConcatenate("LinePivotZZ","2",ExtComplekt,"_"));
   ObjectDelete(StringConcatenate("#_TextPattern_#",ExtComplekt,"_"));
   ObjectDelete(StringConcatenate("#_TextPatternMP_#",ExtComplekt,"_"));

   // Соблюдать порядок следования строк при удалении объектов
   delete_objects_dinamic();
   delete_objects1();
   delete_objects3();
   delete_objects4();
   delete_objects_number();
   delete_objects_monitor();

   if (infoTF) Comment("");
   return(0);
  }
//+------------------------------------------------------------------+
//| Деинициализация. Удаление всех трендовых линий и текстовых объектов. Коннец.
//+------------------------------------------------------------------+

// НАЧАЛО
int start()
  {
   int k, shift; // для расчета красной зоны
   string txt="";

   if ((ExtIndicator==6 || ExtIndicator==7 || ExtIndicator==8 || ExtIndicator==10) && Period()>GrossPeriod) 
     {
      ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);ArrayInitialize(nen_ZigZag,0);
      init_zz=true;
      return(0);
     }

   counted_bars=IndicatorCounted();
  
   if (perTF!=Period())
     {
      delete_objects1();  
      perTF=Period();
     }

   if (Demo!=IsDemo())
     {
      delete_objects1();  
      Demo=IsDemo();
      counted_bars=0;
     }

//-----------------------------------------
// Блок заполнения буферов. Начало. 
//-----------------------------------------   
// zz[] - буфер, данные из которого берутся для отрисовки самого ZigZag-a
// zzL[] - массив минимумов черновой
// zzH[] - массив максимумов черновой
//-----------------------------------------   

   if (Bars-IndicatorCounted()>2)
     {
      if (ExtMaxBar>0) cbi=ExtMaxBar; else cbi=Bars-1;
      lLast=0; hLast=0;
      ti=0; ai=0; bi=0; tai=0; tbi=0; fs=0; si=0; sip=0; 
      lBar=iLow(NULL,GrossPeriod,0); hBar=iHigh(NULL,GrossPeriod,0); tiZZ=iTime(NULL,GrossPeriod,0);
      fh=false; fl=false;
      ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);ArrayInitialize(nen_ZigZag,0);
      init_zz=true; afrm=true; delete_objects_dinamic(); delete_objects1(); delete_objects3();
      flagExtGartleyTypeSearch2=false; vPatOnOff=false;
      countBarEnd=0; TimeBarEnd=0;
      save_cenaPointD=0;
      save_timePointD_0=0;
      vWriteToFilePattern=true; vpicture=true;
      if (chHL_PeakDet) PeakDetIni=true;
     }
   else
     {
      if (ExtIndicator==1) cbi=Bars-IndicatorCounted()-1;
      else cbi=Bars-IndicatorCounted();

      if (ExtMinBar>0)
        {
         if ((ExtIndicator==0||ExtIndicator==1||ExtIndicator==2||ExtIndicator==3||ExtIndicator==5||ExtIndicator==6||ExtIndicator==7||ExtIndicator==8||ExtIndicator==10||ExtIndicator==11) && tiZZ==iTime(NULL,GrossPeriod,0))
         return (0);
        }

      if (lBar<=iLow(NULL,GrossPeriod,0) && hBar>=iHigh(NULL,GrossPeriod,0) && tiZZ==iTime(NULL,GrossPeriod,0)) return(0);
      else
        {
         if (tiZZ<iTime(NULL,GrossPeriod,0)) 
           {
            vWriteToFilePattern=true; vpicture=true;
           }
         lBar=iLow(NULL,GrossPeriod,0); hBar=iHigh(NULL,GrossPeriod,0); tiZZ=iTime(NULL,GrossPeriod,0);
        }
     }

   switch (ExtIndicator)
     {
      case 0  : {ZigZag_();        break;}
      case 1  : {ang_AZZ_();       break;}
      case 2  : {Ensign_ZZ();      break;}
      case 3  : {Ensign_ZZ();      break;}
      case 4  : {ZigZag_tauber();  break;}
      case 5  : {GannSwing();      break;}
      case 6  : {nenZigZag();      break;} // DT-ZigZag - с исправленным, оптимизированным зигзагом ZigZag_nen.mq4
      case 7  : {nenZigZag();      break;} // DT-ZigZag - вариант зигзага, который любезно предоставил klot - DT_ZZ.mq4
      case 8  : {nenZigZag();      break;} // DT-ZigZag - вариант зигзага, который любезно предоставил Candid - CZigZag.mq4
      case 10 : {nenZigZag();      break;} // DT-ZigZag - вариант зигзага ExtIndicator=5 в режиме DT - внешний зигзаг Swing_zz.mq4
      // Поиск паттернов
      case 11 : 
       {
        if (ExtGartleyTypeSearch<2)
          {
           vPatOnOff = false; 
           countGartley = 0;

           ArrayResize(PeakCenaX,1);
           ArrayResize(PeakCenaA,1);
           ArrayResize(PeakCenaB,1);
           ArrayResize(PeakCenaC,1);
           ArrayResize(PeakCenaD,1);

           ArrayResize(PeakTimeX,1);
           ArrayResize(PeakTimeA,1);
           ArrayResize(PeakTimeB,1);
           ArrayResize(PeakTimeC,1);
           ArrayResize(PeakTimeD,1);

           ArrayResize(__NamePatterns,1);
           ArrayResize(__D,1);
           ArrayResize(__PatColor,1);

           ArrayInitialize(PeakCenaX,0);
           ArrayInitialize(PeakCenaA,0);
           ArrayInitialize(PeakCenaB,0);
           ArrayInitialize(PeakCenaC,0);
           ArrayInitialize(PeakCenaD,0);

           ArrayInitialize(PeakTimeX,0);
           ArrayInitialize(PeakTimeA,0);
           ArrayInitialize(PeakTimeB,0);
           ArrayInitialize(PeakTimeC,0);
           ArrayInitialize(PeakTimeD,0);

           __NamePatterns[0][0]="";
           __NamePatterns[0][1]="";
           ArrayInitialize(__D,0);
           ArrayInitialize(__PatColor,0);
          }
        countColor   = 0;
        if (!flagExtGartleyTypeSearch2) {delete_objects3(); vPatOnOff = false; if (ExtHiddenPP==2) delete_objects4();}

        switch (AlgorithmSearchPatterns)
          {
           case 0  : {ZigZag_();       break;}
           case 1  : {ang_AZZ_();      break;}
           case 2  : {ang_AZZ_();      break;}
           case 3  : {Ensign_ZZ();     break;}
           case 4  : {ZigZag_tauber(); break;}
           case 5  : {GannSwing();     break;}
           case 6  : {ZZTalex();       break;}
          }

        if (ExtGartleyTypeSearch==2 && vPatOnOff) flagExtGartleyTypeSearch2=true;

        if (vPatOnOff && !vPatNew)
          {
           vPatNew=true; flagGartley=true;
           if(ExtPlayAlert) 
           {
            Alert (Symbol() + " " + Period() + " pattern " + vBullBear + " " + vNamePattern + " " );// новый алерт тут (2) поручик 3.07.14
            PlaySound("alert.wav");
           }
           if (ExtSendMail) _SendMail("There was a pattern",StringConcatenate("on  ",Symbol()," ",Period()," pattern ",vBullBear," ",vNamePattern));
          }
        else if (!vPatOnOff && vPatNew)
          {
           vPatNew=false; flagGartley=true;
          }

        if (minBarsSave!=minBarsX)
          {
           afrm=true; delete_objects_dinamic(); delete_objects1(); counted_bars=0; minBarsSave=minBarsX; PeakDetIni=true; countBarEnd=0; TimeBarEnd=0;
          }
        break;
       } 

      case 12 : {ZZTalex();        break;}
      case 13 : {ZigZag_SQZZ();    break;}  // ZigZag товароведа     
      case 14 : {ZZ_2L_nen();      break;}  // ZigZag wellx     
     }

   _Monitor();

   bigTextPattern_etc();

   if (ExtHidden<5) // Разрешение на вывод оснастки. Начало.
     {
      if(chHL_PeakDet && PeakDetIni && PeakDet)
        {
         PeakDetIni=false;
         double kl=0,kh=0;  // kl - min; kh - max

         for (shift=Bars; shift>0; shift--)
           {
            if (zzH[shift]>0) {kh=zzH[shift];}
            if (zzL[shift]>0) {kl=zzL[shift];}

            lam[shift]=kl;
            ham[shift]=kh;
           }
        }

//-----------------------------------------
// Блок заполнения буферов. Конец.
//-----------------------------------------   

      // Инициализация матрицы
      matriza();

      if (Bars - counted_bars>2 || flagFrNew)
        {
         // Поиск времени и номера бара, до которого будут рисоваться соединительные линии 
         if (countBarEnd==0)
           {
            if (ExtFractalEnd>0)
              {
               k=ExtFractalEnd;
               for (shift=0; shift<Bars && k>0; shift++) 
                 { 
                  if (zz[shift]>0 && zzH[shift]>0) {countBarEnd=shift; TimeBarEnd=Time[shift]; k--;}
                 }
              }
            else 
              {
               countBarEnd=Bars-3;
               TimeBarEnd=Time[Bars-3];
              }
           }
         else
           {
            countBarEnd=iBarShift(Symbol(),Period(),TimeBarEnd); 
           }
        }

//-----------------------------------------
// Блок проверок и удаления линий, 
// потерявших актуальность. Начало.
//-----------------------------------------   
// Коррекция соединяющих линий и чисел. Начало.

      if (Bars - counted_bars<3 || tik1)
        {
         tik1 = false;
         timeFr1new=0; timeFr2new=0; timeFr3new=0;

         // Поиск времени бара первого экстремума, считая от нулевого бара
         for (shift1=0; shift1<Bars; shift1++) 
           {
            if (zz[shift1]>0.0 && (zzH[shift1]==zz[shift1] || zzL[shift1]==zz[shift1])) 
              {
               timeFr1new=Time[shift1];
               break;
              }
           }

         // Поиск времени бара второго экстремума, считая от нулевого бара
         for (shift2=shift1+1; shift2<Bars; shift2++) 
           {
            if (zz[shift2]>0.0 && (zzH[shift2]==zz[shift2] || zzL[shift2]==zz[shift2])) 
              {
               timeFr2new=Time[shift2];
               break;
              }
           }

         // Поиск времени бара третього экстремума, считая от нулевого бара
         for (shift3=shift2+1; shift3<Bars; shift3++) 
           {
            if (zz[shift3]>0.0 && (zzH[shift3]==zz[shift3] || zzL[shift3]==zz[shift3])) 
              {
               timeFr3new=Time[shift3];
               break;
              }
           }
 
         // Появился новый луч ZigZag
         //if ((zzH[shift1]>0 && afrl[0]>0) || (zzL[shift1]>0 && afrh[0]>0) || 
         if (timeFr2new!=afr[1] || (timeFr3new!=afr[2] && timeFr2new==afr[1]) || timeFr2new<afr[2])
           {
            newRay=true;
            if (!ExtDinamic)
              {
               if (!(RefreshStaticNewRayZZ && timeFr2new<afr[2]))
                 {
                  ExtNumberPeak=false;
                  ExtFiboStatic=false;
                 }
              }
            else
              {
               if (StringSubstr(ExtVisibleDinamic,0,1)!="1")  ExtNumberPeak=false;
               if (StringSubstr(ExtVisibleDinamic,1,1)!="1")  ExtFiboStatic=false;
              }

            if (ExtAlert)
              {
               Alert (Symbol(),"  ",Period(),"  появился новый луч ZigZag");
               PlaySound("alert.wav");
              }
            afrm=true;
           }

         // Поиск бара, на котором первый экстремум был ранее.
         shift=iBarShift(Symbol(),Period(),afr[0]); 

         // Сравнение текущего значения экстремума с тем, который был ранее

         // Образовался новый экстремум
         if (timeFr1new!=afr[0])
           {
            flagFrNew=true;
            if (shift>=shift1) numBar=shift; else  numBar=shift1;
            afrm=true;
           }

         // Экстремум на максимуме сдвинулся на другой бар
         if (afrh[0]>0 && zz[shift]==0.0)
           {
            flagFrNew=true;
            if (numBar<shift) numBar=shift;
            afrm=true;
           }

         // Экстремум на минимуме сдвинулся на другой бар
         if (afrl[0]>0 && zz[shift]==0.0)
           {
            flagFrNew=true;
            if (numBar<shift) numBar=shift;
            afrm=true;
           }

         // Сместился максимум или минимум, но остался на том же баре. Начало.

         // сместился максимум. Начало.
         if (afrh[0]-High[shift]!=0 && afrh[0]>0)
           {
            flagFrNew=true;
            numBar=0;
            delete_objects2(afr[0]);
            afrx[0]=High[shift];
            afrh[0]=High[shift];
            if (mFibo[1]==0 && ExtFiboStatic) screenFiboS();
            if (ExtFiboDinamic) screenFiboD();

            // Поиск паттернов Gartley
            search_Gartley();
           }
         // сместился максимум. Конец.

         // сместился минимум. Начало.
         if (afrl[0]-Low[shift]!=0 && afrl[0]>0)
           {
            flagFrNew=true;
            numBar=0;
            delete_objects2(afr[0]);
            afrx[0]=Low[shift];
            afrl[0]=Low[shift];
            if (mFibo[1]==0 && ExtFiboStatic) screenFiboS();
            if (ExtFiboDinamic) screenFiboD();

            // Поиск паттернов Gartley
            search_Gartley();
           }
         //1 сместился минимум. Конец.

         // Сместился максимум или минимум, но остался на том же баре. Конец.

         // Поиск исчезнувших фракталов и удаление линий, исходящих от этих фракталов. Начало.
         for (k=0; k<10; k++)
           {
            // Проверка максимумов.
            if (afrh[k]>0)
              {
               // Поиск бара, на котором был этот фрактал
               shift=iBarShift(Symbol(),Period(),afr[k]); 
               if (zz[shift]==0)
                 {
                  flagFrNew=true;
                  if (shift>numBar) numBar=shift;
                  afrm=true;
                  for (k1=ObjectsTotal()-1; k1>=0; k1--)
                    {
                     if (StringFind(ObjectName(k1),StringConcatenate("_",ExtComplekt,"ph",Time[shift],"_"))>-1)
                       {
                        ObjectDelete (ObjectName(k1)); 
                        continue;
                       }

                     if (StringFind(ObjectName(k1),StringConcatenate("_",ExtComplekt,"phtxt",Time[shift],"_"))>-1) ObjectDelete (ObjectName(k1));
                    }
                 }
              }

            // Проверка минимумов.
            if (afrl[k]>0)
              {
               // Поиск бара, на котором был этот фрактал
               shift=iBarShift(Symbol(),Period(),afr[k]); 
               if (zz[shift]==0)
                 {
                  flagFrNew=true;
                  if (shift>numBar) numBar=shift;
                  afrm=true;
                  for (k1=ObjectsTotal()-1; k1>=0; k1--)
                    {
                     if (StringFind(ObjectName(k1),StringConcatenate("_",ExtComplekt,"pl",Time[shift],"_"))>-1)
                       {
                        ObjectDelete (ObjectName(k1)); 
                        continue;
                       }

                     if (StringFind(ObjectName(k1),StringConcatenate("_",ExtComplekt,"pltxt",Time[shift],"_"))>-1) ObjectDelete (ObjectName(k1));
                    }
                 }
              }
           }
         // Поиск исчезнувших фракталов и удаление линий, исходящих от этих фракталов. Конец.

         // Перезапись матрицы. Начало.
         matriza();

         if (infoTF) info_TF();

         if (picture && StringLen(vNamePatternToNumberPattern)>0 && ExtGartleyTypeSearch==0 && vpicture) {writepicture(); vpicture=false;}
        }
// Коррекция соединяющих линий и чисел. Конец.
//-----------------------------------------
// Блок проверок и удаления линий, 
// потерявших актуальность. Конец.
//-----------------------------------------   

     // Подсчет количества фракталов. Начало.
     countFractal();
     // Подсчет количества фракталов. Конец.

//-----------------------------------------
// Блок вывода соединительных линий. Начало.
//-----------------------------------------   
      if (Bars - counted_bars>2 && ExtHidden>0)
        {
//-----------1 Отрисовка максимумов. Начало.
//+--------------------------------------------------------------------------+
//| Вывод соединяющих линий и чисел Песавенто и 0.886 для максимумов ZigZag-a
//| Отрисовка начинается от нулевого бара
//+--------------------------------------------------------------------------+

         numLowPrim=0; numLowLast=0;
         numHighPrim=0; numHighLast=0;

         LowPrim=0.0; LowLast=0.0;
         HighPrim=0.0; HighLast=0.0;

         Angle=-100;
   
         if (flagFrNew && !flagGartley) countFr=1;
         else countFr=ExtFractal;

         for (k=0; (k<Bars-1 && countHigh1>0 && countFr>0); k++)
           {
            if (zzL[k]>0.0 && (zzL[k]<LowPrim || LowPrim==0.0) && HighPrim>0 && zzL[k]==zz[k])
              {
               if (ZigZagHighLow) LowPrim=Low[k]; else LowPrim=zzL[k]; 
               numLowPrim=k;
              }

            if (zzH[k]>0.0 && zzH[k]==zz[k])
              {
               if (HighPrim>0) 
                 {
                 if (ZigZagHighLow) HighLast=High[k]; else HighLast=zzH[k];
                  numHighLast=k;

                  HL=HighLast-LowPrim;
                  kj=(HighPrim-HighLast)*1000/(numHighLast-numHighPrim);
                  if (HL>0 && (Angle>=kj || Angle==-100))  // Проверка угла наклона линии
                    {
                     Angle=kj;
                     // Создание линии и текстового объекта
                     HLp=HighPrim-LowPrim;
                     k1=MathCeil((numHighPrim+numHighLast)/2);
                     kj=HLp/HL;
               
                     if (ExtPPWithBars==0) PPWithBars="";
                     else if (ExtPPWithBars==1) PPWithBars=StringConcatenate(" (",(numHighLast-numHighPrim),")");
                     else if (ExtPPWithBars==2) PPWithBars=StringConcatenate(" (",(numHighLast-numLowPrim),"-",(numLowPrim-numHighPrim),")");
                     else if (ExtPPWithBars==3)
                       {
                        int_to_d1=(numLowPrim-numHighPrim);
                        int_to_d2=(numHighLast-numLowPrim);
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==4)
                       {
                        int_to_d1=(Time[numLowPrim]-Time[numHighPrim]);
                        int_to_d2=(Time[numHighLast]-Time[numLowPrim]);
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==5)
                       {
                        int_to_d1=(numLowPrim-numHighPrim)*(High[numHighPrim]-Low[numLowPrim]);
                        int_to_d2=(numHighLast-numLowPrim)*(High[numHighLast]-Low[numLowPrim]);
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==7)
                       {
                        int_to_d1=((High[numHighLast]-Low[numLowPrim])/Point)/(numHighLast-numLowPrim);
                        int_to_d2=((High[numHighPrim]-Low[numLowPrim])/Point)/(numLowPrim-numHighPrim);
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d1,3),"/",DoubleToStr(int_to_d2,3),")");
                       }
                     else if (ExtPPWithBars==8)
                       {
                        int_to_d1=MathSqrt((numLowPrim-numHighPrim)*(numLowPrim-numHighPrim) + ((High[numHighPrim]-Low[numLowPrim])/Point)*((High[numHighPrim]-Low[numLowPrim])/Point));
                        int_to_d2=MathSqrt((numHighLast-numLowPrim)*(numHighLast-numLowPrim) + ((High[numHighLast]-Low[numLowPrim])/Point)*((High[numHighLast]-Low[numLowPrim])/Point));
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==9)
                       {
                        int_to_d1=100-100*Low[numLowPrim]/High[numHighLast];
                        int_to_d2=100*High[numHighPrim]/Low[numLowPrim]-100;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d1,1),"/"+DoubleToStr(int_to_d2,1),")");
                       }
                     else if (ExtPPWithBars==10)
                       {
                        PPWithBars=StringConcatenate(" ",TimeToStr(Time[numHighPrim],TIME_DATE|TIME_MINUTES)," / ",DoubleToStr(High[numHighPrim],Digits)," ");
                       }

// ExtPPWithBars=6 Вычисляется количество пунктов и процент отклонения от ретресмента "Песавенто"

                     ExtLine_=ExtLine;
                     if (kj>0.1 && kj<9.36)
                       {
                        // Создание текстового объекта (числа Песавенто). % восстановления между максимумами
                        kk=kj;
                        k2=1;
                        Pesavento_patterns();
                        if (k2<0)
                          // процент восстановления числа Песавенто и 0.886
                          {
                           ExtLine_=ExtLine886;
                           if (ExtHidden!=4)
                             {
                              nameObj=StringConcatenate("_",ExtComplekt,"phtxt",Time[numHighPrim],"_",Time[numHighLast]);
                              ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(HighPrim+HighLast)/2);

                              if (ExtPPWithBars==6)
                                {
                                 int_to_d=MathAbs((kk-kj)/kk)*100;
                                 PPWithBars=StringConcatenate(" (",DoubleToStr((LowPrim+(HighLast-LowPrim)*kk-HighPrim)/Point,0),"/",DoubleToStr(int_to_d,2),"%)");
                                }
                              descript=txtkk;
                              if (ExtPPWithBars==10)
                                {
                                 ObjectSetText(nameObj,PPWithBars,ExtSizeTxt,"Arial", colorPPattern);
                                }
                              else
                                {
                                 ObjectSetText(nameObj,txtkk+PPWithBars,ExtSizeTxt,"Arial", colorPPattern);
                                }
                              if (ExtPPWithBars==6) PPWithBars="";
                             }
                          }
                        else
                          // процент восстановления (не Песавенто и не 0.886)
                          {
                           if (ExtHidden==1 || ExtHidden==4)
                             {
                              nameObj=StringConcatenate("_",ExtComplekt,"phtxt",Time[numHighPrim],"_",Time[numHighLast]);

                              ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(HighPrim+HighLast)/2);

                              descript=DoubleToStr(kk,3);
                              if (ExtPPWithBars==10)
                                {
                                 ObjectSetText(nameObj,StringConcatenate("",PPWithBars),ExtSizeTxt,"Arial",colorPPattern);
                                }
                              else
                                {
                                 if (ExtDeltaType==3) txtRet=DoubleToStr(kk,3); else txtRet=DoubleToStr(kk,2);
                                 if (kk<1) txtRet=StringSubstr(txtRet,1);
                                 ObjectSetText(nameObj,StringConcatenate(txtRet,PPWithBars),ExtSizeTxt,"Arial",colorPPattern);
                                }
                             }
                          }

                        if ((ExtHidden==2 && k2<0) || ExtHidden!=2)
                          {
                           nameObj=StringConcatenate("_",ExtComplekt,"ph",Time[numHighPrim],"_",Time[numHighLast]);
                           ObjectCreate(nameObj,OBJ_TREND,0,Time[numHighLast],HighLast,Time[numHighPrim],HighPrim);

                           if (descript_b) ObjectSetText(nameObj,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," PPesavento ","Line High ",descript));
                           ObjectSet(nameObj,OBJPROP_RAY,false);
                           ObjectSet(nameObj,OBJPROP_STYLE,STYLE_DOT);
                           ObjectSet(nameObj,OBJPROP_COLOR,ExtLine_);
                           ObjectSet(nameObj,OBJPROP_BACK,ExtBack);
                          }
                        if (ExtFiboZigZag) k=countBarEnd;
                       }
                    }
                 }
               else 
                 {
                  if (ZigZagHighLow) HighPrim=High[k]; else HighPrim=zzH[k];
                  numHighPrim=k;
                 }
              }
            // Переход на следующий экстремум
            if (k>countBarEnd) 
              {
               k=numHighPrim+1; countHigh1--; countFr--;

               numLowPrim=0; numLowLast=0;
               numHighPrim=0; numHighLast=0;

               LowPrim=0.0; LowLast=0.0;
               HighPrim=0.0; HighLast=0.0;
   
               Angle=-100;
              }
           }
//-----------1 Отрисовка максимумов. Конец.

//-----------2 Отрисовка минимумов. Начало.
//+-------------------------------------------------------------------------+
//| Вывод соединяющих линий и чисел Песавенто и 0.886 для минимумов ZigZag-a
//| Отрисовка идет от нулевого бара
//+-------------------------------------------------------------------------+

         numLowPrim=0; numLowLast=0;
         numHighPrim=0; numHighLast=0;

         LowPrim=0.0; LowLast=0.0;
         HighPrim=0.0; HighLast=0.0;
   
         Angle=-100;

         if (flagFrNew && !flagGartley) countFr=1;
         else countFr=ExtFractal;
         flagFrNew=false;
         flagGartley=false;

         for (k=0; (k<Bars-1 && countLow1>0 && countFr>0); k++)
           {
            if (zzH[k]>HighPrim && LowPrim>0)
              {
               if (ZigZagHighLow) HighPrim=High[k]; else HighPrim=zzH[k];
               numHighPrim=k;
              }

            if (zzL[k]>0.0 && zzL[k]==zz[k]) 
              {
               if (LowPrim>0) 
                 {
                  if (ZigZagHighLow) LowLast=Low[k]; else LowLast=zzL[k];
                  numLowLast=k;

                  // вывод соединяющих линий и процентов восстановления(чисел Песавенто)
                  HL=HighPrim-LowLast;
                  kj=(LowPrim-LowLast)*1000/(numLowLast-numLowPrim);
                  if (HL>0 && (Angle<=kj || Angle==-100))  // Проверка угла наклона линии
                    {
                     Angle=kj;

                     HLp=HighPrim-LowPrim;
                     k1=MathCeil((numLowPrim+numLowLast)/2);
                     kj=HLp/HL;

                     if (ExtPPWithBars==0) PPWithBars="";
                     else if (ExtPPWithBars==1) PPWithBars=StringConcatenate(" (",(numLowLast-numLowPrim),")");
                     else if (ExtPPWithBars==2) PPWithBars=StringConcatenate(" (",(numLowLast-numHighPrim),"-",(numHighPrim-numLowPrim),")");
                     else if (ExtPPWithBars==3)
                       {
                        int_to_d1=(numHighPrim-numLowPrim);
                        int_to_d2=(numLowLast-numHighPrim);
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==4)
                       {
                        int_to_d1=(Time[numHighPrim]-Time[numLowPrim]);
                        int_to_d2=(Time[numLowLast]-Time[numHighPrim]);
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==5)
                       {
                        int_to_d1=(numHighPrim-numLowPrim)*(High[numHighPrim]-Low[numLowPrim]);
                        int_to_d2=(numLowLast-numHighPrim)*(High[numHighPrim]-Low[numLowLast]);
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==7)
                       {
                        int_to_d1=((High[numHighPrim]-Low[numLowLast])/Point)/(numLowLast-numHighPrim);
                        int_to_d2=((High[numHighPrim]-Low[numLowPrim])/Point)/(numHighPrim-numLowPrim);
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d1,3),"/",DoubleToStr(int_to_d2,3),")");
                       }
                     else if (ExtPPWithBars==8)
                       {
                        int_to_d1=MathSqrt((numHighPrim-numLowPrim)*(numHighPrim-numLowPrim) + ((High[numHighPrim]-Low[numLowPrim])/Point)*((High[numHighPrim]-Low[numLowPrim])/Point));
                        int_to_d2=MathSqrt((numLowLast-numHighPrim)*(numLowLast-numHighPrim) + ((High[numHighPrim]-Low[numLowLast])/Point)*((High[numHighPrim]-Low[numLowLast])/Point));
                        int_to_d=int_to_d1/int_to_d2;
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d,2),")");
                       }
                     else if (ExtPPWithBars==9)
                       {
                        int_to_d1=100*High[numHighPrim]/Low[numLowLast]-100;
                        int_to_d2=100-100*Low[numLowPrim]/High[numHighPrim];
                        PPWithBars=StringConcatenate(" (",DoubleToStr(int_to_d1,1),"/",DoubleToStr(int_to_d2,1),")");
                       }
                     else if (ExtPPWithBars==10)
                       {
                        PPWithBars=StringConcatenate(" ",TimeToStr(Time[numLowPrim],TIME_DATE|TIME_MINUTES)," / ",DoubleToStr(Low[numLowPrim],Digits)," ");
                       }

// ExtPPWithBars=6 Вычисляется количство пунктов и процент отклонения от ретресмента "Песавенто"

                     ExtLine_=ExtLine;
                     if ( kj>0.1 && kj<9.36)
                       {
                        // Создание текстового объекта (числа Песавенто). % восстановления между минимумами
                        kk=kj;
                        k2=1;
                        Pesavento_patterns();
                        if (k2<0)
                        // процент восстановления числа Песавенто и 0.886
                          {
                           ExtLine_=ExtLine886;
                           if (ExtHidden!=4)                  
                             {
                              nameObj=StringConcatenate("_",ExtComplekt,"pltxt",Time[numLowPrim],"_",Time[numLowLast]);
                              ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(LowPrim+LowLast)/2);

                              if (ExtPPWithBars==6)
                                {
                                 int_to_d=MathAbs((kk-kj)/kk)*100;
                                 PPWithBars=StringConcatenate(" (",DoubleToStr((HighPrim-(HighPrim-LowLast)*kk-LowPrim)/Point,0),"/",DoubleToStr(int_to_d,2),"%)");
                                }
                              descript=txtkk;
                              if (ExtPPWithBars==10)
                                {
                                 ObjectSetText(nameObj,PPWithBars,ExtSizeTxt,"Arial", colorPPattern);
                                }
                              else
                                {
                                 ObjectSetText(nameObj,StringConcatenate(txtkk,PPWithBars),ExtSizeTxt,"Arial", colorPPattern);
                                }
                              if (ExtPPWithBars==6) PPWithBars="";
                             }
                          }
                        else 
                          // процент восстановления (не Песавенто и не 0.886)
                          { 
                           if (ExtHidden==1 || ExtHidden==4)
                             {
                              nameObj=StringConcatenate("_",ExtComplekt,"pltxt",Time[numLowPrim],"_",Time[numLowLast]);

                              ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(LowPrim+LowLast)/2);
      
                              descript=DoubleToStr(kk,3);
                              if (ExtPPWithBars==10)
                                {
                                 ObjectSetText(nameObj,PPWithBars,ExtSizeTxt,"Arial",colorPPattern);
                                }
                              else
                                {
                                 if (ExtDeltaType==3) txtRet=DoubleToStr(kk,3); else txtRet=DoubleToStr(kk,2);
                                 if (kk<1) txtRet=StringSubstr(txtRet,1);
                                 ObjectSetText(nameObj,StringConcatenate(txtRet,PPWithBars),ExtSizeTxt,"Arial",colorPPattern);
                                }
                             }
                           }

                         if ((ExtHidden==2 && k2<0) || ExtHidden!=2)
                           {
                            nameObj=StringConcatenate("_",ExtComplekt,"pl",Time[numLowPrim],"_",Time[numLowLast]);

                            ObjectCreate(nameObj,OBJ_TREND,0,Time[numLowLast],LowLast,Time[numLowPrim],LowPrim);

                            if (descript_b) ObjectSetText(nameObj,StringConcatenate("ZUP",ExtComplekt," zz",ExtIndicator," PPesavento ","Line Low ",descript));
                            ObjectSet(nameObj,OBJPROP_RAY,false);
                            ObjectSet(nameObj,OBJPROP_STYLE,STYLE_DOT);
                            ObjectSet(nameObj,OBJPROP_COLOR,ExtLine_);
                            ObjectSet(nameObj,OBJPROP_BACK,ExtBack);
                           }
                         if (ExtFiboZigZag) k=countBarEnd;
                        }
                     }
                 }
               else
                 {
                  numLowPrim=k; 
                  if (ZigZagHighLow) LowPrim=Low[k]; else LowPrim=zzL[k];
                 }
              }
            // Переход на следующий экстремум
            if (k>countBarEnd) 
              {
               k=numLowPrim+1; countLow1--; countFr--;

               numLowPrim=0; numLowLast=0;
               numHighPrim=0; numHighLast=0;

               LowPrim=0.0; LowLast=0.0;
               HighPrim=0.0; HighLast=0.0;
  
               Angle=-100;
              }
           }

//-----------2 Отрисовка минимумов. Конец.

        }
//-----------------------------------------
// Блок вывода соединительных линий. Конец.
//-----------------------------------------   
     } // Разрешение на вывод оснастки. Конец.

// КОНЕЦ
   return(0);
  } // start

//----------------------------------------------------
//  Подпрограммы и функции
//----------------------------------------------------

//--------------------------------------------------------
// Подсчет количества экстремумов. Минимумов и максимумов. Начало.
//--------------------------------------------------------
void countFractal()
  {
   int shift;
   countLow1=0;
   countHigh1=0;
   if (flagFrNew && !flagGartley)
     {
      for(shift=0; shift<=numBar; shift++)
        {
         if (zzL[shift]>0.0) {countLow1++;}
         if (zzH[shift]>0.0) {countHigh1++;}    
        }

      numBar=0;  
      counted_bars=Bars-4;
     }
   else
     {
      if (flagGartley)  {counted_bars=0;}
      for(shift=0; shift<=countBarEnd; shift++)
        {
         if (zzL[shift]>0.0) {countLow1++;}
         if (zzH[shift]>0.0) {countHigh1++;}
        }
     }
  }
//--------------------------------------------------------
// Подсчет количества экстремумов. Минимумов и максимумов. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Формирование матрицы. Начало.
//
// Выводятся статические и динамические фибы и вееры Фибоначчи,
// вилы Эндрюса...
//------------------------------------------------------
void matriza()
  {
   if (afrm && ExtHidden<5)
     {
      afrm=false;

      int shift,k,m;
      double kl=0,kh=0;

      if (ExtMaxBar>0) cbi=ExtMaxBar; else cbi=Bars;

      k=0; m=0;
      for (shift=0; shift<cbi && k<10; shift++)
        {
         if (zz[shift]>0)
           {
            afrx[k]=zz[shift];
            afr[k]=Time[shift];
            if (zz[shift]==zzL[shift])
              {
               kl=zzL[shift];
               if (ZigZagHighLow) afrl[k]=Low[shift]; 
               else
                 {
                  if (k==0) afrl[k]=Low[shift]; else  afrl[k]=zzL[shift];
                 }
               afrh[k]=0.0;
              }

            if (zz[shift]==zzH[shift])
              {
               kh=zzH[shift];
               if (ZigZagHighLow) afrh[k]=High[shift]; 
               else
                 {
                  if (k==0) afrh[k]=High[shift]; else afrh[k]=zzH[shift];
                 }
               afrl[k]=0.0;
              }
            k++;

            if (infoMerrillPattern)
              {
               if (m<6)
                 {
                  if (m<5)
                    {
                     mPeak0[m][0]=zz[shift];
                    }
                  if (m>0)
                    {
                     mPeak1[m-1][0]=zz[shift];
                    }
                  m++;
                 }
              }
           }
        }

      if (infoMerrillPattern)
        {
         ArraySort(mPeak1,5,0,MODE_ASCEND);
         ArraySort(mPeak0,5,0,MODE_ASCEND);
        }

      if (PeakDet && chHL_PeakDet)
        {
         // kl - min; kh - max
         for (k=shift; k>0; k--)
           {
            if (zzH[k]>0) {kh=zzH[k];}
            if (zzL[k]>0) {kl=zzL[k];}

            if (kl>0) lam[k]=kl;
            if (kh>0) ham[k]=kh;
           }
        }

      // Вывод статических и динамических фиб.
      if (ExtFiboStatic)
        {
         if (newRay && mFibo[1]>0) screenFiboS();
         if (mFibo[1]==0) screenFiboS();
        }
      if (ExtFiboDinamic) screenFiboD();

      // Поиск паттернов Gartley
      search_Gartley();

     _Monitor();

      bigTextPattern_etc();

      ExtSave=false;
     }
   if (newRay && ExtNumberPeak) NumberPeak();
   newRay=false;
  }
//--------------------------------------------------------
// Формирование матрицы. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Поиск паттернов Gartley. Начало.
//--------------------------------------------------------
void search_Gartley()
  {
   if (ExtGartleyOnOff || PotencialsLevels_retXD>0)
     {
      switch (ExtIndicator )
        {
         case 0     : {_Gartley(StringConcatenate("ExtIndicator=0_",_minBars,"/",_ExtBackstep),_minBars);break;}
         case 1     : {_Gartley(StringConcatenate("ExtIndicator=1_",minSize,"/",minPercent),0);break;}
         case 2     : {_Gartley(StringConcatenate("ExtIndicator=2_",minBars,"/",minSize),minSize);break;}
         case 3     : {_Gartley(StringConcatenate("ExtIndicator=3_",minBars),0);break;}
         case 4     : {_Gartley(StringConcatenate("ExtIndicator=4_",minSize),0);break;}
         case 5     : {_Gartley(StringConcatenate("ExtIndicator=5_",minBars),0);break;}
         case 6     : {_Gartley(StringConcatenate("ExtIndicator=6_",minBars,"/",ExtBackstep),0);break;}
         case 7     : {_Gartley(StringConcatenate("ExtIndicator=7_",minBars),0);break;}
         case 8     : {_Gartley(StringConcatenate("ExtIndicator=8_",minBars,"/",ExtDeviation),0);break;}
         case 10    : {_Gartley(StringConcatenate("ExtIndicator=10_",minBars),0);break;}
         case 12    : {_Gartley(StringConcatenate("ExtIndicator=12_",minBars),0);break;}
         case 13    : {_Gartley(StringConcatenate("ExtIndicator=13_",minBars,"/",minSize),0);break;}
         case 14    : {_Gartley(StringConcatenate("ExtIndicator=14_",minBars),0);break;}
        }

      if (vPatOnOff && !vPatNew)
        {
         vPatNew=true;
         if (ExtSendMail) _SendMail("There was a pattern",StringConcatenate("on  ",Symbol()," ",Period()," pattern ",vBullBear," ",vNamePattern));
        }
      else if (!vPatOnOff && vPatNew) vPatNew=false;
     }
  }
//--------------------------------------------------------
// Поиск паттернов Gartley. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод номеров переломов зигзагов. Начало.
//--------------------------------------------------------
void NumberPeak()
  {
   int n=0,i,endNumber;
   string txt="";
   if (ExtNumberPeak10) endNumber=iBarShift(Symbol(),Period(),afr[9]); else endNumber=Bars-minBars;
   
   delete_objects_number();

   for (i=iBarShift(Symbol(),Period(),afr[0])+1;i<endNumber;i++)
     {
      if (zz[i]>0)
        {
         n++;
         if (ExtNumberPeakLow)
           {
            if (zzL[i]>0)
              {
               txt=DoubleToStr(n,0);
               nameObj=StringConcatenate("NumberPeak_",ExtComplekt,"_",n);
               ObjectCreate(nameObj,OBJ_TEXT,0,Time[i],zz[i]);
               ObjectSetText(nameObj,txt,ExtNumberPeakFontSize,"Arial",ExtNumberPeakColor);
              }
           }
         else
           {
            txt=DoubleToStr(n,0);
            nameObj=StringConcatenate("NumberPeak_",ExtComplekt,"_",n);
            ObjectCreate(nameObj,OBJ_TEXT,0,Time[i],zz[i]);
            ObjectSetText(nameObj,txt,ExtNumberPeakFontSize,"Arial",ExtNumberPeakColor);
           }
        }
     }
   }
//--------------------------------------------------------
// Вывод номеров переломов зигзагов. Конец
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод фиб статических. Начало.
//--------------------------------------------------------
void screenFiboS()
  {
   nameObj=StringConcatenate("fiboS",ExtComplekt,"_");
   if (mFibo[1]>0)
     {
      if (ExtSave)
        {
         nameObj=StringConcatenate(nameObj,save);
        }
     }

   screenFibo_(ExtFiboS, "                             ", mFibo[0], mFibo[1], nameObj);
  }
//--------------------------------------------------------
// Вывод фиб статических. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод фиб динамических. Начало.
//--------------------------------------------------------
void screenFiboD()
  {
   nameObj=StringConcatenate("fiboD",ExtComplekt,"_");
   screenFibo_(ExtFiboD, "", 1, 0, nameObj);
  }
//--------------------------------------------------------
// Вывод фиб динамических. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Создание фиб. Начало.
//--------------------------------------------------------
void screenFibo_(color colorFibo, string otstup, int a1, int a2, string _nameObj)
  {
   double fibo_0, fibo_100, fiboPrice, fiboPrice1;

   ObjectDelete(_nameObj);

   if (!ExtFiboCorrectionExpansion)
     {
      fibo_0=afrx[a1];fibo_100=afrx[a2];
      fiboPrice=afrx[a1]-afrx[a2];fiboPrice1=afrx[a2];
     }
   else
     {
      fibo_100=afrx[a1];fibo_0=afrx[a2];
      fiboPrice=afrx[a2]-afrx[a1];fiboPrice1=afrx[a1];
     }

   if (!ExtFiboCorrectionExpansion)
     {
      ObjectCreate(_nameObj,OBJ_FIBO,0,afr[a1],fibo_0,afr[a2],fibo_100);
     }
   else
     {
      ObjectCreate(_nameObj,OBJ_FIBO,0,afr[a2],fibo_0,afr[a1],fibo_100);
     }

   ObjectSet(_nameObj,OBJPROP_LEVELCOLOR,colorFibo);

   ObjectSet(_nameObj,OBJPROP_COLOR,ExtObjectColor);
   ObjectSet(_nameObj,OBJPROP_STYLE,ExtObjectStyle);
   ObjectSet(_nameObj,OBJPROP_WIDTH,ExtObjectWidth);
   ObjectSet(_nameObj,OBJPROP_LEVELSTYLE,ExtFiboStyle);
   ObjectSet(_nameObj,OBJPROP_LEVELWIDTH,ExtFiboWidth);
   ObjectSet(_nameObj,OBJPROP_BACK,ExtBack);

   if (ExtFiboType==0)
     {
      fibo_standart(fiboPrice, fiboPrice1,"-"+Period_tf+otstup);
     }
   else if (ExtFiboType==1)
     {
      fibo_patterns(fiboPrice, fiboPrice1,"-"+Period_tf+otstup);
     }
   else if (ExtFiboType==2)
     {
      fibo_custom(fiboPrice, fiboPrice1,"-"+Period_tf+otstup);
     }
  }
//--------------------------------------------------------
// Создание фиб. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Фибы стандартные. Начало.
//--------------------------------------------------------
void fibo_standart(double fiboPrice,double fiboPrice1,string fibo)
  {
   double   fi_1[]={0, 0.146, 0.236, 0.382, 0.5, 0.618, 0.764, 0.854, 1.0, 1.236, phi, 2.618, 4.236, 6.854};
   string   fitxt100_1[]={"0.0", "14.6", "23.6", "38.2", "50.0", "61.8", "76.4", "85.4", "100.0", "123.6", "161.8", "2.618", "423.6", "685.4"};
   int i;
   Sizefi_1=14;

   if (!ExtFiboCorrectionExpansion)
     {   
      ObjectSet(nameObj,OBJPROP_FIBOLEVELS,Sizefi_1);
      for (i=0;i<Sizefi_1;i++)
        {
         ObjectSet(nameObj,OBJPROP_FIRSTLEVEL+i,fi_1[i]);
         ObjectSetFiboDescription(nameObj, i, fitxt100_1[i]+" "+"  %$"+fibo); 
        }
     }
   else
     {
      ObjectSet(nameObj,OBJPROP_FIBOLEVELS,Sizefi_1+2);

      ObjectSet(nameObj,OBJPROP_FIRSTLEVEL,0);
      ObjectSetFiboDescription(nameObj, 0, "Fe 1 "+"  %$"+fibo); 

      ObjectSet(nameObj,OBJPROP_FIRSTLEVEL,1);
      ObjectSetFiboDescription(nameObj, 1, "Fe 0 "+"  %$"+fibo); 

      for (i=1;i<Sizefi_1;i++)
        {
         ObjectSet(nameObj,OBJPROP_FIRSTLEVEL+i+2,1+fi_1[i]);
         ObjectSetFiboDescription(nameObj, i+2, "Fe "+fitxt100_1[i]+" "+"  %$"+fibo); 
        }
     }
  }
//--------------------------------------------------------
// Фибы стандартные. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Фибы с паттернами. Начало.
//--------------------------------------------------------
void fibo_patterns(double fiboPrice,double fiboPrice1,string fibo)
  {
   double   fi_1[]={0.0, 0.382, 0.447, 0.5, 0.618, 0.707, 0.786, 0.854, 0.886, 1.0, 1.128, 1.272, 1.414, phi, 2.0, 2.618, 4.236};
   string   fitxt100_1[]={"0.0", "38.2", "44.7", "50.0", "61.8", "70.7", "78.6", "85.4", "88.6", "100.0", "112.8", "127.2", "141.4", "161.8", "200.0", "261.8", "423.6"};
   int i;
   Sizefi_1=17;

   if (!ExtFiboCorrectionExpansion)
     {   
      ObjectSet(nameObj,OBJPROP_FIBOLEVELS,Sizefi_1);
      for (i=0;i<Sizefi_1;i++)
        {
         ObjectSet(nameObj,OBJPROP_FIRSTLEVEL+i,fi_1[i]);
         ObjectSetFiboDescription(nameObj, i, fitxt100_1[i]+" "+"  %$"+fibo); 
        }
     }
   else
     {
      ObjectSet(nameObj,OBJPROP_FIBOLEVELS,Sizefi_1+2);

      ObjectSet(nameObj,OBJPROP_FIRSTLEVEL,0);
      ObjectSetFiboDescription(nameObj, 0, "Fe 1 "+"  %$"+fibo); 

      ObjectSet(nameObj,OBJPROP_FIRSTLEVEL,1);
      ObjectSetFiboDescription(nameObj, 1, "Fe 0 "+"  %$"+fibo); 

      for (i=1;i<Sizefi_1;i++)
        {
         ObjectSet(nameObj,OBJPROP_FIRSTLEVEL+i+2,1+fi_1[i]);
         ObjectSetFiboDescription(nameObj, i+2, "Fe "+fitxt100_1[i]+" "+"  %$"+fibo); 
        }
     }
  }
//--------------------------------------------------------
// Фибы с паттернами. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Фибы пользовательские. Начало.
//--------------------------------------------------------
void fibo_custom(double fiboPrice,double fiboPrice1,string fibo)
  {
   int i;

   if (!ExtFiboCorrectionExpansion)
     {   
      ObjectSet(nameObj,OBJPROP_FIBOLEVELS,Sizefi);
      for (i=0;i<Sizefi;i++)
        {
         ObjectSet(nameObj,OBJPROP_FIRSTLEVEL+i,fi[i]);
         ObjectSetFiboDescription(nameObj, i, fitxt100[i]+" "+"  %$"+fibo); 
        }
     }
   else
     {
      ObjectSet(nameObj,OBJPROP_FIBOLEVELS,Sizefi+2);

      ObjectSet(nameObj,OBJPROP_FIRSTLEVEL,0);
      ObjectSetFiboDescription(nameObj, 0, "Fe 1 "+"  %$"+fibo); 

      ObjectSet(nameObj,OBJPROP_FIRSTLEVEL,1);
      ObjectSetFiboDescription(nameObj, 1, "Fe 0 "+"  %$"+fibo); 

      for (i=0;i<Sizefi;i++)
        {
         if (fi[i]>0)
           {
            ObjectSet(nameObj,OBJPROP_FIRSTLEVEL+i+2,1+fi[i]);
            ObjectSetFiboDescription(nameObj, i+2, "Fe "+fitxt100[i]+" "+"  %$"+fibo); 
           }
        }
     }
  }
//--------------------------------------------------------
// Фибы пользовательские. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление объектов. Начало.
// Удаление соединительных линий и чисел.
//--------------------------------------------------------
void delete_objects1()
  {
   int i;
   string txt="";
   counted_bars=0;

   for (i=ObjectsTotal()-1; i>=0; i--)
     {
      txt=ObjectName(i);
      if (StringFind(txt,"_" + ExtComplekt + "pl")>-1) ObjectDelete (txt);
      if (StringFind(txt,"_" + ExtComplekt + "ph")>-1) ObjectDelete (txt);
     }
  }
//--------------------------------------------------------
// Удаление объектов. Конец.
// Удаление соединительных линий и чисел.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление объектов. Начало.
// Удаление соединительных линий и чисел.
//--------------------------------------------------------
void delete_objects2(string txt1)
  {
   int i;
   string txt="";

   for (i=ObjectsTotal()-1; i>=0; i--)
     {
      txt=ObjectName(i);
      if (StringFind(txt,txt1)>-1)ObjectDelete (txt);
     }
  }
//--------------------------------------------------------
// Удаление объектов. Конец.
// Удаление соединительных линий и чисел.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление объектов. Начало.
// Удаление объектов паттернов Gartley.
//--------------------------------------------------------
void delete_FiboStrongPattern()
  {
   int i;
   string txt="";
   for (i=ObjectsTotal()-1; i>=0; i--)
     {
      txt=ObjectName(i);
      if (StringFind(txt,"_"+ExtComplekt+"StrongPattern_")>-1) ObjectDelete (txt);
     }
  }
//--------------------------------------------------------
// Удаление объектов. Конец.
// Удаление объектов паттернов Gartley.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление объектов. Начало.
// Удаление объектов паттернов Gartley.
//--------------------------------------------------------
void delete_objects3()
  {
   int i;
   string txt="";

   for (i=ObjectsTotal()-1; i>=0; i--)
     {
      txt=ObjectName(i);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"StrongPattern_"))>-1) ObjectDelete (txt);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"Triangle"))>-1) ObjectDelete (txt);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"ABCDzz"))>-1) ObjectDelete (txt);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"Line"))>-1) ObjectDelete (txt);
      if (RangeForPointD)
        {
         if (StringFind(txt,StringConcatenate("_",ExtComplekt,"PointD"))>-1) ObjectDelete (txt);
        }

      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"Equilibrium"))>-1) ObjectDelete (txt);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"Reaction"))>-1) ObjectDelete (txt);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"pg"))>-1) ObjectDelete (txt);
      if (bigText)
        {
         if (StringFind(txt,StringConcatenate("#_TextPattern_#",ExtComplekt,"_"))>-1) ObjectDelete (txt);
        }
      vBullBearToNumberPattern="";
      vNamePatternToNumberPattern="";
      if (VectorOfAMirrorTrend>0) if (StringFind(txt,StringConcatenate("_",ExtComplekt,"VectorOfAMirrorTrend"))>-1) ObjectDelete (txt);

      if (ExtGartleyTypeSearch>0)
        {
         ArrayInitialize(PeakCenaX,0);
         ArrayInitialize(PeakCenaA,0);
         ArrayInitialize(PeakCenaB,0);
         ArrayInitialize(PeakCenaC,0);
         ArrayInitialize(PeakCenaD,0);

         ArrayInitialize(PeakTimeX,0);
         ArrayInitialize(PeakTimeA,0);
         ArrayInitialize(PeakTimeB,0);
         ArrayInitialize(PeakTimeC,0);
         ArrayInitialize(PeakTimeD,0);

         __NamePatterns[0][0]="";
         __NamePatterns[0][1]="";
         ArrayInitialize(__D,0);
         ArrayInitialize(__PatColor,0);
        }
     }
  }
//--------------------------------------------------------
// Удаление объектов. Конец.
// Удаление объектов паттернов Gartley.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление объектов. Начало.
// Удаление соединительных линий и чисел.
//--------------------------------------------------------
void delete_objects4()
  {
   int i;
   string txt="";

   for (i=ObjectsTotal()-1; i>=0; i--)
     {
      txt=ObjectName(i);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"pg"))>-1) ObjectDelete (txt);
     }
  }
//--------------------------------------------------------
// Удаление объектов. Конец.
// Удаление соединительных линий и чисел.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление объектов. Начало.
// Удаление спирали.
//--------------------------------------------------------
void delete_objects_monitor()
  {
   int i;
   string txt="";

   for (i=ObjectsTotal()-1; i>=0; i--)
     {
      txt=ObjectName(i);
      if (StringFind(txt,StringConcatenate("_",ExtComplekt,"_","MonitorPatterns_"))>-1) ObjectDelete(txt);
     }
  }
//--------------------------------------------------------
// Удаление объектов. Конец.
// Удаление спирали.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление объектов. Начало.
// Удаление номеров переломов зигзага.
//--------------------------------------------------------
void delete_objects_number()
  {
   int i;
   string txt="";

   for (i=ObjectsTotal()-1; i>=0; i--)
     {
      txt=ObjectName(i);
      if (StringFind(txt,StringConcatenate("NumberPeak_",ExtComplekt,"_"))>-1) ObjectDelete (txt);
     }
  }
//--------------------------------------------------------
// Удаление объектов. Конец.
// Удаление номеров переломов зигзага.
//--------------------------------------------------------

//--------------------------------------------------------
// Удаление динамических объектов. Начало.
//--------------------------------------------------------
void delete_objects_dinamic()
  {
   ObjectDelete(StringConcatenate("fiboD",ExtComplekt,"_"));
  }
//--------------------------------------------------------
// Удаление динамических объектов. Конец.
//--------------------------------------------------------

//----------------------------------------------------
//  ZigZag Алекса немного измененный. Начало.
//----------------------------------------------------
void ang_AZZ_()
 {
   int    i,n;
   bool   endCyklDirection=true;
   bool   endSearchPattern=false;
   int    vSize;
   double vPercent_, vPercent;

   if (ExtMaxBar>0) cbi=ExtMaxBar; else cbi=Bars-1;

   if (ExtIndicator==11)
     {
      if (AlgorithmSearchPatterns==1)
        {
         if (DirectionOfSearchMaxMin) vSize = maxSize_; else vSize = minSize_;
        }
      else
        {
         if (DirectionOfSearchMaxMin) vPercent_ = maxPercent_; else vPercent_ = minPercent_;
        }
     }

   while (endCyklDirection)
     {
      if (ExtIndicator==11)
        {
         if (ExtLabel>0) {ArrayInitialize(la,0.0); ArrayInitialize(ha,0.0);}
         ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);
         ti=0; fs=0; fsp=0; tbi=0; tai=0; si=0;

         if (AlgorithmSearchPatterns==1)
           {
            if (DirectionOfSearchMaxMin)
              {
               if (vSize < minSize_)
                 {
                  if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vSize=minSizeToNumberPattern;
                  else vSize=minSize_;
                  endSearchPattern=true;
                 }

               di=vSize*Point/2;
               vSize-=IterationStepSize;
              }
            else
              {
               if (vSize > maxSize_)
                 {
                  if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vSize=minSizeToNumberPattern;
                  else vSize=minSize_;
                  endSearchPattern=true;
                 }

               di=vSize*Point/2;
               vSize+=IterationStepSize;
              }
           }
         else
           {
            if (DirectionOfSearchMaxMin)
              {
               if (vPercent_ < minPercent_)
                 {
                  if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vPercent_=minPercentToNumberPattern;
                  else vPercent_=minPercent_;
                  endSearchPattern=true;
                 }

               vPercent=vPercent_;
               vPercent_=vPercent_*(1-IterationStepPercent/100);
              }
            else
              {
               if (vPercent_ > maxPercent_)
                 {
                  if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vPercent_=minPercentToNumberPattern;
                  else vPercent_=minPercent;
                  endSearchPattern=true;
                 }

               vPercent=vPercent_;
               vPercent_=vPercent_*(1+IterationStepPercent/100);
              }
           }

         if (flagExtGartleyTypeSearch2)
           {
            endSearchPattern=true; 

            if (AlgorithmSearchPatterns==1)
              {
               vSize=minSizeToNumberPattern;
              }
            else
              {
               vPercent_=minPercentToNumberPattern;
              }
           }
        }
      else
        {
         endCyklDirection=false;
         endSearchPattern=true;
        }

      for (i=cbi; i>=ExtMinBar; i--) 
        {
         // запоминаем значение направления тренда fs и средней цены si на предыдущем баре
         if (ti<Time[i]) {fsp=fs; sip=si;} ti=Time[i];
         // Вычисляем значение ценового фильтра от процента отклонения
         if (ExtIndicator==11)
           {
            if (AlgorithmSearchPatterns==2) di=vPercent*Close[i]/2/100;
           }
         else if (minSize==0 && minPercent!=0) di=minPercent*Close[i]/2/100;

         // Корректировка средней цены
         if (High[i]>si+di && Low[i]<si-di) // Внешний бар по отношению к ценовому фильтру di
           {
//        if (High[i]-si>si-Low[i]) si=High[i]-di;  // Отклонение хая от средней цены больше отклонения лова
//        else if (High[i]-si<si-Low[i]) si=Low[i]+di;  // соответственно, меньше

            if (fs==1) si=High[i]-di;  // 
            if (fs==2) si=Low[i]+di;  // 
           } 
         else  // Не внешний бар
           {
            if (fs==1)
              {
               if (High[i]>=si+di) si=High[i]-di;   // 
               else if (Low[i]<si-di) si=Low[i]+di;   // 
              }
            if (fs==2)
              {
               if (Low[i]<=si-di) si=Low[i]+di;   // 
               else if (High[i]>si+di) si=High[i]-di;   //
              }
           }

         // Вычисление начального значения средней цены

         if (i>cbi-1) {si=(High[i]+Low[i])/2;}
         // Определяем направление тренда для расчетного бара
         if (si>sip) fs=1; // Тренд восходящий
         if (si<sip) fs=2; // Тренд нисходящий

         //-------------------------------------------------
         if (fs==1 && fsp==2) // Тренд сменился с нисходящего на восходящий
           {
            hm=High[i];

            bi=iBarShift(Symbol(),Period(),tbi);
            zz[bi]=Low[bi];
            zzL[bi]=Low[bi];
            tai=Time[i];
            fsp=fs;
            si=High[i]-di;
            sip=si;

            if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
              {
               ha[i]=High[i]; la[bi]=Low[bi]; la[i]=0;
               tmh=Time[i]; ha[i]=High[i]; la[i]=0; // простановка метки на восходящем луче
              }
           }

         if (fs==2 && fsp==1) // Тредн сменился с восходящего на нисходящий
           {
            lm=Low[i]; 

            ai=iBarShift(Symbol(),Period(),tai); 
            zz[ai]=High[ai];
            zzH[ai]=High[ai];
            tbi=Time[i];
            si=Low[i]+di;
            fsp=fs;
            sip=si;

            if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
              {
               ha[ai]=High[ai]; ha[i]=0; la[i]=Low[i];
               tml=Time[i]; ha[i]=0; la[i]=Low[i]; // простановка метки на нисходящем луче
              }
           }

         // Продолжение tренда. Отслеживание тренда.
         if (fs==1 && High[i]>hm) {hm=High[i]; tai=Time[i]; si=High[i]-di;}
         if (fs==2 && Low[i]<lm)  {lm=Low[i]; tbi=Time[i]; si=Low[i]+di;}

         if ((ExtIndicator!=11 || endSearchPattern))
           {
            // Заполняем буферы для уровней подтверждения
            if (chHL && chHL_PeakDet && ExtLabel==0) {ha[i]=si+di; la[i]=si-di;} 

            //===================================================================================================
            // Нулевой бар. Расчет первого луча ZigZag-a
            if (i==0) 
              {
               ai0=iBarShift(Symbol(),Period(),tai); 
               bi0=iBarShift(Symbol(),Period(),tbi);
               if (fs==1)
                 {
                  for (n=bi0-1; n>=0; n--) {zzH[n]=0; zz[n]=0; if (ExtLabel>0) ha[n]=0;}
                  zz[ai0]=High[ai0]; zzH[ai0]=High[ai0]; zzL[ai0]=0; if (ExtLabel>0) ha[ai0]=High[ai0];
                 }
               if (fs==2)
                 {
                  for (n=ai0-1; n>=0; n--) {zzL[n]=0; zz[n]=0; if (ExtLabel>0) la[n]=0;}
                  zz[bi0]=Low[bi0]; zzL[bi0]=Low[bi0]; zzH[bi0]=0; if (ExtLabel>0) la[bi0]=Low[bi0];
                 }

               if (ExtLabel>0)
                 {
                  if (fs==1) {aim=iBarShift(Symbol(),0,tmh); if (aim<bi0) ha[aim]=High[aim];}
                  else if (fs==2) {bim=iBarShift(Symbol(),0,tml); if (bim<ai0) la[bim]=Low[bim];}
                 }
              }
            //====================================================================================================
           }
        }

      if (ExtIndicator==11)
        {
         // поиск паттернов

         if (endSearchPattern) return;

         _Gartley(StringConcatenate("ExtIndicator=11_",vSize,"/",vPercent), 0);

         if (saveParametersZZ)
           {
            saveParametersZZ=false;

            if (AlgorithmSearchPatterns==1) minSizeToNumberPattern=vSize;
            else minPercentToNumberPattern=vPercent;
           }

         if (ExtGartleyTypeSearch==0 && vPatOnOff) return;

        }
     }
 }
//--------------------------------------------------------
// ZigZag Алекса. Конец. 
//--------------------------------------------------------

//----------------------------------------------------
// Свинги Ганна. Начало.
//----------------------------------------------------
void GannSwing()
 {
   int    i,n;
   int    vBars  = minBars;
   bool   endCyklDirection=true;
   bool   endSearchPattern=false;

   // Переменные для Свингов Ганна
   double lLast_m=0, hLast_m=0;
   int    countBarExt=0; // счетчик внешних баров
   int    countBarl=0,countBarh=0;
   fs=0; ti=0;

// lLast, hLast - минимум и максимум активного бара
// lLast_m, hLast_m - минимум и максимум "промежуточных" баров

//   cbi=Bars-IndicatorCounted()-1;
//---------------------------------
//   cbi=Bars-1; 
   if (ExtMaxBar>0) cbi=ExtMaxBar; else cbi=Bars-1;

   if (ExtIndicator==11)
     {
      if (DirectionOfSearchMaxMin) vBars = minBars; else vBars = 0;
     }

   while (endCyklDirection)
     {
      if (ExtLabel>0) {ArrayInitialize(la,0.0); ArrayInitialize(ha,0.0);}
      ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);

      if (ExtIndicator==11)
        {
         lLast=0; lLast_m=0; hLast_m=0; fs=0; ti=0;

         if (DirectionOfSearchMaxMin)
           {
            if (vBars < 0)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vBars=minBarsToNumberPattern;
               else vBars=minBars;
               endSearchPattern=true;
              }

            vBars--;
           }
         else
           {
            if (vBars > minBars)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vBars=minBarsToNumberPattern;
               else vBars=minBars;
               endSearchPattern=true;
              }

            vBars++;
           }

         if (flagExtGartleyTypeSearch2)
           {
            endSearchPattern=true; 
            vBars=minSizeToNumberPattern;
           }
        }
      else
        {
         vBars=minBars;
         endCyklDirection=false;
         endSearchPattern=true;
        }

      for (i=cbi; i>=ExtMinBar; i--) 
        {
//-------------------------------------------------
         // Устанавливаем начальные значения минимума и максимума бара
         if (lLast==0) {lLast=Low[i]; hLast=High[i]; ai=i; bi=i;}
         if (ti!=Time[i])
           {
            ti=Time[i];
            if (lLast_m==0 && hLast_m==0)
              {
               if (lLast>Low[i] && hLast<High[i]) // Внешний бар
                 {
                  lLast=Low[i];hLast=High[i];lLast_m=Low[i];hLast_m=High[i];countBarExt++;
                  if (fs==1) {countBarl=countBarExt; ai=i; tai=Time[i];}
                  else if (fs==2) {countBarh=countBarExt; bi=i; tbi=Time[i];}
                  else {countBarl++;countBarh++;}
                 }
               else if (lLast<=Low[i] && hLast<High[i]) // Тенденция на текущем баре восходящая
                 {
                  lLast_m=0;hLast_m=High[i];countBarl=0;countBarExt=0;
                  if (fs!=1) countBarh++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; ai=i; tai=Time[i];}
                 }
               else if (lLast>Low[i] && hLast>=High[i]) // Тенденция на текущем баре нисходящая
                 {
                  lLast_m=Low[i];hLast_m=0;countBarh=0;countBarExt=0;
                  if (fs!=2) countBarl++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; bi=i; tbi=Time[i];}
                 }
              }
            else  if (lLast_m>0 && hLast_m>0) // Внешний бар (предыдущий)
              {
               if (lLast_m>Low[i] && hLast_m<High[i]) // Внешний бар
                 {
                  lLast=Low[i];hLast=High[i];lLast_m=Low[i];hLast_m=High[i];countBarExt++;
                  if (fs==1) {countBarl=countBarExt; ai=i; tai=Time[i];}
                  else if (fs==2) {countBarh=countBarExt; bi=i; tbi=Time[i];}
                  else {countBarl++;countBarh++;}
                 }
               else if (lLast_m<=Low[i] && hLast_m<High[i]) // Тенденция на текущем баре восходящая
                 {
                  lLast_m=0;hLast_m=High[i];countBarl=0;countBarExt=0;
                  if (fs!=1) countBarh++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; ai=i; tai=Time[i];}
                 }
               else if (lLast_m>Low[i] && hLast_m>=High[i]) // Тенденция на текущем баре нисходящая
                 {
                  lLast_m=Low[i];hLast_m=0;countBarh=0;countBarExt=0;
                  if (fs!=2) countBarl++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; bi=i; tbi=Time[i];}
                 }
              }
            else  if (lLast_m>0)
              {
               if (lLast_m>Low[i] && hLast<High[i]) // Внешний бар
                 {
                  lLast=Low[i];hLast=High[i];lLast_m=Low[i];hLast_m=High[i];countBarExt++;
                  if (fs==1) {countBarl=countBarExt; ai=i; tai=Time[i];}
                  else if (fs==2) {countBarh=countBarExt; bi=i; tbi=Time[i];}
                  else {countBarl++;countBarh++;}
                 }
               else if (lLast_m<=Low[i] && hLast<High[i]) // Тенденция на текущем баре восходящая
                 {
                  lLast_m=0;hLast_m=High[i];countBarl=0;countBarExt=0;
                  if (fs!=1) countBarh++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; ai=i; tai=Time[i];}
                 }
               else if (lLast_m>Low[i] && hLast>=High[i]) // Тенденция на текущем баре нисходящая
                 {
                  lLast_m=Low[i];hLast_m=0;countBarh=0;countBarExt=0;
                  if (fs!=2) countBarl++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; bi=i; tbi=Time[i];}
                 }
              }
            else  if (hLast_m>0)
              {
               if (lLast>Low[i] && hLast_m<High[i]) // Внешний бар
                 {
                  lLast=Low[i];hLast=High[i];lLast_m=Low[i];hLast_m=High[i];countBarExt++;
                  if (fs==1) {countBarl=countBarExt; ai=i; tai=Time[i];}
                  else if (fs==2) {countBarh=countBarExt; bi=i; tbi=Time[i];}
                  else {countBarl++;countBarh++;}
                 }
               else if (lLast<=Low[i] && hLast_m<High[i]) // Тенденция на текущем баре восходящая
                 {
                  lLast_m=0;hLast_m=High[i];countBarl=0;countBarExt=0;
                  if (fs!=1) countBarh++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; ai=i; tai=Time[i];}
                 }
               else if (lLast>Low[i] && hLast_m>=High[i]) // Тенденция на текущем баре нисходящая
                 {
                  lLast_m=Low[i];hLast_m=0;countBarh=0;countBarExt=0;
                  if (fs!=2) countBarl++;
                  else {lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0; bi=i; tbi=Time[i];}
                 }
              }

            // Определяем направление тренда. 
            if (fs==0)
              {
               if (lLast<lLast_m && hLast>hLast_m) // внутренний бар
                 {
                  lLast=Low[i]; hLast=High[i]; ai=i; bi=i; countBarl=0;countBarh=0;countBarExt=0;
                 }

               if (countBarh>countBarl && countBarh>countBarExt && countBarh>vBars)
                 {
                  lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0;
                  fs=1;countBarh=0;countBarl=0;countBarExt=0;
                  zz[bi]=Low[bi];
                  zzL[bi]=Low[bi];
                  zzH[bi]=0;
                  ai=i;
                  tai=Time[i];
                 }
               else if (countBarl>countBarh && countBarl>countBarExt && countBarl>vBars)
                 {
                  lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0;
                  fs=2;countBarl=0;countBarh=0;countBarExt=0;
                  zz[ai]=High[ai];
                  zzH[ai]=High[ai];
                  zzL[ai]=0;
                  bi=i;
                  tbi=Time[i];
                 }
              }
            else
              {
               if (lLast_m==0 && hLast_m==0)
                 {
                  countBarl=0;countBarh=0;countBarExt=0;
                 }

               // Тенденция восходящая
               if (fs==1)
                 {
                  if (countBarl>countBarh && countBarl>countBarExt && countBarl>vBars) // Определяем точку смены тенденции.
                    {
                     // запоминаем значение направления тренда fs на предыдущем баре
                     ai=iBarShift(Symbol(),Period(),tai); 
                     fs=2;
                     countBarl=0;

                     zz[ai]=High[ai];
                     zzH[ai]=High[ai];
                     zzL[ai]=0;
                     bi=i;
                     if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
                       {
                        ha[ai]=High[ai]; la[ai]=0; // простановка меток на максимумах
                        tml=Time[i]; ha[i]=0; la[i]=Low[i]; // простановка метки на нисходящем луче
                       }
                     tbi=Time[i];

                     lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0;

                     for (n=0;countBarExt<vBars;n++) 
                       {
                        if (lLast<Low[i+n+1] && hLast>High[i+n+1]) {countBarExt++; countBarh++; lLast=Low[i+n+1]; hLast=High[i+n+1]; hLast_m=High[i];}
                        else break;
                       }

                     lLast=Low[i]; hLast=High[i];

                    }
                 }

               // Тенденция нисходящая
               if (fs==2)
                 {
                  if (countBarh>countBarl && countBarh>countBarExt && countBarh>vBars) // Определяем точку смены тенденции.
                    {
                     // запоминаем значение направления тренда fs на предыдущем баре
                     bi=iBarShift(Symbol(),Period(),tbi);
                     fs=1;
                     countBarh=0;

                     zz[bi]=Low[bi];
                     zzL[bi]=Low[bi];
                     zzH[bi]=0;
                     ai=i;
                     if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
                       {
                        ha[bi]=0; la[bi]=Low[bi];  // простановка меток на минимумах
                        tmh=Time[i]; ha[i]=High[i]; la[i]=0; // простановка метки на восходящем луче
                       }
                     tai=Time[i];

                     lLast=Low[i]; hLast=High[i]; lLast_m=0; hLast_m=0;

                     for (n=0;countBarExt<vBars;n++) 
                       {
                        if (lLast<Low[i+n+1] && hLast>High[i+n+1]) {countBarExt++; countBarl++; lLast=Low[i+n+1]; hLast=High[i+n+1]; lLast_m=Low[i];}
                        else break;
                       }

                     lLast=Low[i]; hLast=High[i];

                    }
                 }
              } 
           } 

         if ((ExtIndicator!=11 || endSearchPattern))
           {
            if (i==0)
              {
               if (hLast<High[i] && fs==1) // Тенденция на текущем баре восходящая
                 {
                  ai=i; tai=Time[i]; zz[ai]=High[ai]; zzH[ai]=High[ai]; zzL[ai]=0;
                  if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0) {ha[ai]=High[ai]; la[ai]=0;} // гуляющая метка
                 }
               else if (lLast>Low[i] && fs==2) // Тенденция на текущем баре нисходящая
                 {
                  bi=i; tbi=Time[i]; zz[bi]=Low[bi]; zzL[bi]=Low[bi]; zzH[bi]=0;
                  if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0) {la[bi]=Low[bi]; ha[bi]=0;} // гуляющая метка
                 }
              //===================================================================================================

              // Нулевой бар. Расчет первого луча ZigZag-a
               ai0=iBarShift(Symbol(),Period(),tai); 
               bi0=iBarShift(Symbol(),Period(),tbi);

               if (bi0>1) if (fs==1)
                 {
                  for (n=bi0-1; n>=0; n--) {zzH[n]=0.0; zz[n]=0.0; if (ExtLabel>0) ha[n]=0;}
                  zz[ai0]=High[ai0]; zzH[ai0]=High[ai0]; zzL[ai0]=0.0; if (ExtLabel>0) ha[ai0]=High[ai0];
                 }
               if (ai0>1) if (fs==2)
                 {
                  for (n=ai0-1; n>=0; n--) {zzL[n]=0.0; zz[n]=0.0; if (ExtLabel>0) la[n]=0;} 
                  zz[bi0]=Low[bi0]; zzL[bi0]=Low[bi0]; zzH[bi0]=0.0; if (ExtLabel>0) la[bi0]=Low[bi0];
                 }

               if (ExtLabel>0)
                 {
                  if (fs==1) {aim=iBarShift(Symbol(),0,tmh); if (aim<bi0) ha[aim]=High[aim];}
                  else if (fs==2) {bim=iBarShift(Symbol(),0,tml); if (bim<ai0) la[bim]=Low[bim];}
                 }

               if (ti<Time[1]) i=2;

               //====================================================================================================
              }
           }
        }

      if (ExtIndicator==11)
        {
         // поиск паттернов

         if (endSearchPattern) return;

         _Gartley(StringConcatenate("ExtIndicator=11_",vBars), 0);

         if (saveParametersZZ)
           {
            saveParametersZZ=false;
            minBarsToNumberPattern=vBars;
           }

         if (ExtGartleyTypeSearch==0 && vPatOnOff) return;

        }
     }
//--------------------------------------------
 }
//--------------------------------------------------------
// Свинги Ганна. Конец. 
//--------------------------------------------------------

/*------------------------------------------------------------------+
|  ZigZag_Talex, ищет точки перелома на графике. Количество точек   |
|  задается внешним параметром ExtPoint.                            |
+------------------------------------------------------------------*/
void ZZTalex()
  {
   int    i,j,k,zzbarlow,zzbarhigh,curbar,curbar1,curbar2,EP,Mbar[];
   double curpr,Mprice[];
   bool   flag,fd;
   int    vBars  = minBars;
   bool   endCyklDirection=true;
   bool   endSearchPattern=false;
   
   if (DirectionOfSearchMaxMin) vBars = maxDepth; else vBars = minDepth;
   ArrayResize(Mbar,ExtPoint);
   ArrayResize(Mprice,ExtPoint);

   while (endCyklDirection)
     {
      ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);
      ArrayInitialize(Mbar,0);ArrayInitialize(Mprice,0);
      if (ExtIndicator==11)
        {
         if (DirectionOfSearchMaxMin)
           {
            if (vBars < 0)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vBars=minBarsToNumberPattern;
               else vBars=minBars;
               endSearchPattern=true;
              }

            vBars-=IterationStepDepth;
           }
         else
           {
            if (vBars > minBars)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vBars=minBarsToNumberPattern;
               else vBars=minBars;
               endSearchPattern=true;
              }

            vBars+=IterationStepDepth;
           }

         if (flagExtGartleyTypeSearch2)
           {
            endSearchPattern=true; 
            vBars=minSizeToNumberPattern;
           }
        }
      else
        {
         vBars=minBars;
         endCyklDirection=false;
         endSearchPattern=true;
        }

      EP=ExtPoint;
      zzbarlow=iLowest(NULL,0,MODE_LOW,vBars,0);        
      zzbarhigh=iHighest(NULL,0,MODE_HIGH,vBars,0);     

      if(zzbarlow<zzbarhigh) {curbar=zzbarlow; curpr=Low[zzbarlow];}
      if(zzbarlow>zzbarhigh) {curbar=zzbarhigh; curpr=High[zzbarhigh];}
      if(zzbarlow==zzbarhigh){curbar=zzbarlow;curpr=funk1(zzbarlow, vBars);}

      j=0;
      endpr=curpr;
      endbar=curbar;
      Mbar[j]=curbar;
      Mprice[j]=curpr;

      EP--;
      if(curpr==Low[curbar]) flag=true;
      else flag=false;
      fl=flag;
 
      i=curbar+1;
      while(EP>0)
        {
         if(flag)
           {
            while(i<=Bars-1)
              {
               curbar1=iHighest(NULL,0,MODE_HIGH,vBars,i); 
               curbar2=iHighest(NULL,0,MODE_HIGH,vBars,curbar1); 
               if(curbar1==curbar2){curbar=curbar1;curpr=High[curbar];flag=false;i=curbar+1;j++;break;}
               else i=curbar2;
              }

            Mbar[j]=curbar;
            Mprice[j]=curpr;
            EP--;
           }

         if(EP==0) break;

         if(!flag) 
           {
            while(i<=Bars-1)
              {
               curbar1=iLowest(NULL,0,MODE_LOW,vBars,i); 
               curbar2=iLowest(NULL,0,MODE_LOW,vBars,curbar1); 
               if(curbar1==curbar2){curbar=curbar1;curpr=Low[curbar];flag=true;i=curbar+1;j++;break;}
               else i=curbar2;
              }

            Mbar[j]=curbar;
            Mprice[j]=curpr;
            EP--;
           }
        }

      /* исправление вершин */
      if(Mprice[0]==Low[Mbar[0]])fd=true; else fd=false;
      for(k=0;k<=ExtPoint-1;k++)
        {
         if(k==0)
           {
            if(fd==true)
              {
               Mbar[k]=iLowest(NULL,0,MODE_LOW,Mbar[k+1]-Mbar[k],Mbar[k]);Mprice[k]=Low[Mbar[k]];endbar=vBars;
              }
            if(fd==false)
              {
               Mbar[k]=iHighest(NULL,0,MODE_HIGH,Mbar[k+1]-Mbar[k],Mbar[k]);Mprice[k]=High[Mbar[k]];endbar=vBars;
              }
           }
         if(k<ExtPoint-2)
           {
            if(fd==true)
              {
               Mbar[k+1]=iHighest(NULL,0,MODE_HIGH,Mbar[k+2]-Mbar[k]-1,Mbar[k]+1);Mprice[k+1]=High[Mbar[k+1]];
              }
            if(fd==false)
              {
               Mbar[k+1]=iLowest(NULL,0,MODE_LOW,Mbar[k+2]-Mbar[k]-1,Mbar[k]+1);Mprice[k+1]=Low[Mbar[k+1]];
              }
           }
         if(fd==true)fd=false;else fd=true;

         /* постройка ZigZag'a */
         zz[Mbar[k]]=Mprice[k];
         if (k==0)
           {
            if (Mprice[k]>Mprice[k+1])
              {
               zzH[Mbar[k]]=Mprice[k];
              }
            else
              {
               zzL[Mbar[k]]=Mprice[k];
              }
           }
         else
           {
            if (Mprice[k]>Mprice[k-1])
              {
               zzH[Mbar[k]]=Mprice[k];
              }
            else
              {
               zzL[Mbar[k]]=Mprice[k];
              }

           }
        }

      if (ExtIndicator==11)
        {
         // поиск паттернов

         if (endSearchPattern) return;

         _Gartley(StringConcatenate("ExtIndicator=11_",vBars), 0);

         if (saveParametersZZ)
           {
            saveParametersZZ=false;
            minBarsToNumberPattern=vBars;
          }

         if (ExtGartleyTypeSearch==0 && vPatOnOff) return;

        }
     }
  
  } 
//------------------------------------------------------------------
//  ZigZag_Talex конец                                              
//------------------------------------------------------------------

/*-------------------------------------------------------------------+
/ Фунция для поиска у первого бара (если он внешний) какой экстремум |
/ будем использовать в качестве вершины. Для ZigZag_Talex.           |
/-------------------------------------------------------------------*/
double funk1(int zzbarlow, int ExtDepth)
{
 double pr;
 int fbarlow,fbarhigh;
 
 fbarlow=iLowest(NULL,0,MODE_LOW,ExtDepth,zzbarlow);  
 fbarhigh=iHighest(NULL,0,MODE_HIGH,ExtDepth,zzbarlow);
 
 if(fbarlow>fbarhigh) pr=High[zzbarlow];
 if(fbarlow<fbarhigh) pr=Low[zzbarlow];
 if(fbarlow==fbarhigh)
 {
  fbarlow=iLowest(NULL,0,MODE_LOW,2*ExtDepth,zzbarlow);  
  fbarhigh=iHighest(NULL,0,MODE_HIGH,2*ExtDepth,zzbarlow);
  if(fbarlow>fbarhigh) pr=High[zzbarlow];
  if(fbarlow<fbarhigh) pr=Low[zzbarlow];
  if(fbarlow==fbarhigh)
  {
   fbarlow=iLowest(NULL,0,MODE_LOW,3*ExtDepth,zzbarlow);  
   fbarhigh=iHighest(NULL,0,MODE_HIGH,3*ExtDepth,zzbarlow);
   if(fbarlow>fbarhigh) pr=High[zzbarlow];
   if(fbarlow<fbarhigh) pr=Low[zzbarlow];
  }
 }
 return(pr);
}
//--------------------------------------------------------
// Конец. Для ZigZag_Talex.
//--------------------------------------------------------

//----------------------------------------------------
//  ZigZag tauber. Начало.
//----------------------------------------------------
void ZigZag_tauber()
  {
   int    shift, lasthighpos,lastlowpos;
   double res;
   double curlow,curhigh,lasthigh,lastlow;
   int    vSize;
   bool   endCyklDirection=true;
   bool   endSearchPattern=false;

   int    metka=0; // =0 - до первого перелома ZZ. =1 - ищем метки максимумов. =2 - ищем метки минимумов.
   double peak, wrpeak;

   if (ExtIndicator==11)
     {
      if (DirectionOfSearchMaxMin) vSize = maxSize_; else vSize = minSize_;
     }

   while (endCyklDirection)
     {
      if (ExtLabel>0) {ArrayInitialize(la,0.0); ArrayInitialize(ha,0.0);}
      ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);

      if (ExtIndicator==11)
        {
         if (DirectionOfSearchMaxMin)
           {
            if (vSize < minSize_)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vSize=minSizeToNumberPattern;
               else vSize=minSize_;
               endSearchPattern=true;
              }

            di=minSize*Point;
            vSize-=IterationStepSize;
           }
         else
           {
            if (vSize > maxSize_)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vSize=minSizeToNumberPattern;
               else vSize=minSize_;
               endSearchPattern=true;
              }

            di=minSize*Point;
            vSize+=IterationStepSize;
           }

         if (flagExtGartleyTypeSearch2)
           {
            endSearchPattern=true; 
            vSize=minSizeToNumberPattern;
           }
        }
      else
        {
         vSize=minSize;
         endCyklDirection=false;
         endSearchPattern=true;
        }

      GetHigh(0,Bars,0.0,0,vSize);

      // final cutting 
      lasthigh=-1; lasthighpos=-1;
      lastlow=-1;  lastlowpos=-1;

      for(shift=Bars; shift>=0; shift--)
        {
         curlow=zzL[shift];
         curhigh=zzH[shift];
         if((curlow==0)&&(curhigh==0)) continue;
         //---
         if(curhigh!=0)
           {
           if(lasthigh>0) 
              {
               if(lasthigh<curhigh) zzH[lasthighpos]=0;
               else zzH[shift]=0;
              }
           //---
            if(lasthigh<curhigh || lasthigh<0)
              {
               lasthigh=curhigh;
               lasthighpos=shift;
              }
            lastlow=-1;
           }
         //----
         if(curlow!=0)
           {
            if(lastlow>0)
              {
               if(lastlow>curlow) zzL[lastlowpos]=0;
               else zzL[shift]=0;
             }
            //---
            if((curlow<lastlow)||(lastlow<0))
              {
               lastlow=curlow;
               lastlowpos=shift;
              } 
            lasthigh=-1;
           }
        }

      for(shift=Bars-1; shift>=0; shift--)
        {
         zz[shift]=zzL[shift];
         res=zzH[shift];
         if(res!=0.0) zz[shift]=res;
        }

      if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)  // расставляем метки
        {
         for(shift=Bars-1; shift>=0; shift--)
           {

            if (zz[shift]>0)
              {
               if (zzH[shift]>0)
                 {
                  peak=High[shift]; wrpeak=Low[shift];
                  ha[shift]=High[shift]; la[shift]=0;
                  metka=2; shift--;
                 }
               else
                 {
                  peak=Low[shift]; wrpeak=High[shift];
                  la[shift]=Low[shift]; ha[shift]=0;
                  metka=1; shift--;
                 }
              }

            if (metka==1)
              {
               if (wrpeak<High[shift])
                 {
                  if (High[shift]-peak>minSize*Point) {metka=0;  ha[shift]=High[shift];}
                 }
               else
                 {
                  wrpeak=High[shift];
                 }
              }
            else if (metka==2)
              {
               if (wrpeak>Low[shift])
                 {
                  if (peak-Low[shift]>minSize*Point) {metka=0;  la[shift]=Low[shift];}
                 }
               else
                 {
                  wrpeak=Low[shift];
                 }
              }
           }
        }

      if (ExtIndicator==11)
        {
         // поиск паттернов

         if (endSearchPattern) return;

         _Gartley(StringConcatenate("ExtIndicator=11_",AlgorithmSearchPatterns), 0);

         if (saveParametersZZ)
           {
            saveParametersZZ=false;
            minSizeToNumberPattern=vSize;
           }

         if (ExtGartleyTypeSearch==0 && vPatOnOff) return;
        }
     }
  }

void GetHigh(int start, int end, double price, int step, int vSize)
  {
   int count=end-start;
   if (count<=0) return;
   int i=iHighest(NULL,0,MODE_HIGH,count+1,start);
   double val=High[i];
   if ((val-price)>(vSize*Point))
     { 
      zzH[i]=val;
      if (i==start) {GetLow(start+step,end-step,val,1-step,vSize); if (zzL[start-1]>0) zzL[start]=0; return;}     
      if (i==end) {GetLow(start+step,end-step,val,1-step,vSize); if (zzL[end+1]>0) zzL[end]=0; return;} 
      GetLow(start,i-1,val,0,vSize);
      GetLow(i+1,end,val,0,vSize);
     }
  }

void GetLow(int start, int end, double price, int step, int vSize)
  {
   int count=end-start;
   if (count<=0) return;
   int i=iLowest(NULL,0,MODE_LOW,count+1,start);
   double val=Low[i];
   if ((price-val)>(vSize*Point))
     {
      zzL[i]=val; 
      if (i==start) {GetHigh(start+step,end-step,val,1-step,vSize); if (zzH[start-1]>0) zzH[start]=0; return;}     
      if (i==end) {GetHigh(start+step,end-step,val,1-step,vSize); if (zzH[end+1]>0) zzH[end]=0; return;}   
      GetHigh(start,i-1,val,0,vSize);
      GetHigh(i+1,end,val,0,vSize);
     }
  }
//--------------------------------------------------------
// ZigZag tauber. Конец. 
//--------------------------------------------------------

//----------------------------------------------------
// Индикатор подобный встроенному в Ensign. Начало.
//----------------------------------------------------
void Ensign_ZZ()
 {
   int  i,n;
   int  vSize;
   bool endCyklDirection=true;
   bool endSearchPattern=false;

   if (ExtMaxBar>0) cbi=ExtMaxBar; else cbi=Bars-1;

   if (ExtIndicator==11)
     {
      if (DirectionOfSearchMaxMin) vSize = maxSize_; else vSize = minSize_;
     }

   while (endCyklDirection)
     {
      if (ExtIndicator==11)
        {
         if (ExtLabel>0) {ArrayInitialize(la,0.0); ArrayInitialize(ha,0.0);}
         ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);
         ti=0; fs=0; tbi=0; tai=0; si=0;

         if (DirectionOfSearchMaxMin)
           {
            if (vSize < minSize_)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vSize=minSizeToNumberPattern;
               else vSize=minSize_;
               endSearchPattern=true;
              }

            di=vSize*Point;
            vSize-=IterationStepSize;
           }
         else
           {
            if (vSize > maxSize_)
              {
               if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) vSize=minSizeToNumberPattern;
               else vSize=minSize_;
               endSearchPattern=true;
              }

            di=vSize*Point;
            vSize+=IterationStepSize;
           }

         if (flagExtGartleyTypeSearch2)
           {
            endSearchPattern=true; 
            vSize=minSizeToNumberPattern;
           }
        }
      else
        {
         endCyklDirection=false;
         endSearchPattern=true;
        }
 
      for (i=cbi; i>=ExtMinBar; i--) 
        {
         // Устанавливаем начальные значения минимума и максимума бара
         if (lLast==0) {lLast=Low[i];hLast=High[i]; if (ExtIndicator==3) di=hLast-lLast;}

         // Определяем направление тренда до первой точки смены тренда.
         // Или до точки начала первого луча за левым краем.
         if (fs==0)
           {
            if (lLast<Low[i] && hLast<High[i]) {fs=1; hLast=High[i]; si=High[i]; ai=i; tai=Time[i]; if (ExtIndicator==3) di=High[i]-Low[i];}  // тренд восходящий
            if (lLast>Low[i] && hLast>High[i]) {fs=2; lLast=Low[i]; si=Low[i]; bi=i; tbi=Time[i]; if (ExtIndicator==3) di=High[i]-Low[i];}  // тренд нисходящий
           }

//      if (ti<Time[i])
           {
            // запоминаем значение направления тренда fs на предыдущем баре
            ti=Time[i];

            ai0=iBarShift(Symbol(),Period(),tai); 
            bi0=iBarShift(Symbol(),Period(),tbi);

            fcount0=false;
            if ((fh || fl) && countBar>0) {countBar--; if (i==0 && countBar==0) fcount0=true;}
            // Остановка. Определение дальнейшего направления тренда.
            if (fs==1)
              {
               if (hLast>High[i] && !fh) fh=true;

               if (i==0)
                 {
                  if (Close[i+1]<lLast && fh) {fs=2; countBar=minBars; fh=false;}
                  if (countBar==0 && si-di>Low[i+1] && High[i+1]<hLast && ai0>i+1 && fh && !fcount0) {fs=2; countBar=minBars; fh=false;}

                  if (fs==2) // Тредн сменился с восходящего на нисходящий на предыдущем баре
                    {
                     zz[ai0]=High[ai0];
                     zzH[ai0]=High[ai0];
                     lLast=Low[i+1];
                     if (ExtIndicator==3) di=High[i+1]-Low[i+1];
                     si=Low[i+1];
                     bi=i+1;
                     tbi=Time[i+1];
                     if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
                       {
                        ha[ai0]=High[ai0];
                        tml=Time[i+1]; ha[i+1]=0; la[i+1]=Low[i+1]; // простановка метки на нисходящем луче
                       }
//                  else if (chHL && chHL_PeakDet) {ha[i+1]=si+di; la[i+1]=si;}
                    }
                 }
               else
                 {
                  if (Close[i]<lLast && fh) {fs=2; countBar=minBars; fh=false;}
                  if (countBar==0 && si-di>Low[i] && High[i]<hLast && fh) {fs=2; countBar=minBars; fh=false;}

                  if (fs==2) // Тредн сменился с восходящего на нисходящий
                    {
                     zz[ai]=High[ai];
                     zzH[ai]=High[ai];
                     lLast=Low[i];
                     if (ExtIndicator==3) di=High[i]-Low[i];
                     si=Low[i];
                     bi=i;
                     tbi=Time[i];
                     if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
                       {
                        ha[ai]=High[ai];
                        tml=Time[i]; ha[i]=0; la[i]=Low[i]; // простановка метки на нисходящем луче
                       }
//                  else if (chHL && chHL_PeakDet) {ha[i]=si+di; la[i]=si;}
                    }
                 }
              }
            else // fs==2
              {
               if (lLast<Low[i] && !fl) fl=true;

               if (i==0)
                 {
                  if (Close[i+1]>hLast && fl) {fs=1; countBar=minBars; fl=false;}
                  if (countBar==0 && si+di<High[i+1] && Low[i+1]>lLast && bi0>i+1 && fl && !fcount0) {fs=1; countBar=minBars; fl=false;}

                  if (fs==1) // Тредн сменился с нисходящего на восходящий на предыдущем баре
                    {
                     zz[bi0]=Low[bi0];
                     zzL[bi0]=Low[bi0];
                     hLast=High[i+1];
                     if (ExtIndicator==3) di=High[i+1]-Low[i+1];
                     si=High[i+1];
                     ai=i+1;
                     tai=Time[i+1];
                     if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
                       {
                        la[bi0]=Low[bi0];
                        tmh=Time[i+1]; ha[i+1]=High[i+1]; la[i+1]=0; // простановка метки на восходящем луче
                       }
//                  else if (chHL && chHL_PeakDet) {ha[i+1]=si; la[i+1]=si-di;}
                    }
                 }
               else
                 {
                  if (Close[i]>hLast && fl) {fs=1; countBar=minBars; fl=false;}
                  if (countBar==0 && si+di<High[i] && Low[i]>lLast && fl) {fs=1; countBar=minBars; fl=false;}

                  if (fs==1) // Тредн сменился с нисходящего на восходящий
                    {
                     zz[bi]=Low[bi];
                     zzL[bi]=Low[bi];
                     hLast=High[i];
                     if (ExtIndicator==3) di=High[i]-Low[i];
                     si=High[i];
                     ai=i;
                     tai=Time[i];
                     if ((ExtIndicator!=11 || endSearchPattern) && ExtLabel>0)
                       {
                        la[bi]=Low[bi];
                        tmh=Time[i]; ha[i]=High[i]; la[i]=0; // простановка метки на восходящем луче
                       }
//                  else if (chHL && chHL_PeakDet==1) {ha[i]=si; la[i]=si-di;}
                    }
                 }
              }
           } 

         // Продолжение тренда
         if (fs==1 && High[i]>si) {ai=i; tai=Time[i]; hLast=High[i]; si=High[i]; countBar=minBars; fh=false; if (ExtIndicator==3) di=High[i]-Low[i];}
         if (fs==2 && Low[i]<si) {bi=i; tbi=Time[i]; lLast=Low[i]; si=Low[i]; countBar=minBars; fl=false; if (ExtIndicator==3) di=High[i]-Low[i];}

         if ((ExtIndicator!=11 || endSearchPattern))
           {
            // Заполняем буферы для уровней подтверждения
            if (chHL && chHL_PeakDet && ExtLabel==0)
              {
               if (fs==1) {ha[i]=si; la[i]=si-di;}
               if (fs==2) {ha[i]=si+di; la[i]=si;}
              } 

            //===================================================================================================
            // Нулевой бар. Расчет первого луча ZigZag-a
            if (i==0) 
              {
               ai0=iBarShift(Symbol(),Period(),tai); 
               bi0=iBarShift(Symbol(),Period(),tbi);

               if (fs==1)
                 {
                  for (n=bi0-1; n>=0; n--) {zzH[n]=0; zz[n]=0; if (ExtLabel>0) ha[n]=0;} 
                  zz[ai0]=High[ai0]; zzH[ai0]=High[ai0]; zzL[ai0]=0; if (ExtLabel>0) ha[ai0]=High[ai0];
                 }
               if (fs==2)
                 {
                  for (n=ai0-1; n>=0; n--) {zzL[n]=0; zz[n]=0; if (ExtLabel>0) la[n]=0;} 
                  zz[bi0]=Low[bi0]; zzL[bi0]=Low[bi0]; zzH[bi0]=0; if (ExtLabel>0) la[bi0]=Low[bi0];
                 }

               if (ExtLabel>0)
                 {
                  if (fs==1) {aim=iBarShift(Symbol(),0,tmh); if (aim<bi0) ha[aim]=High[aim];}
                  else if (fs==2) {bim=iBarShift(Symbol(),0,tml); if (bim<ai0) la[bim]=Low[bim];}
                 }
              }
            //====================================================================================================
           }
        }

      if (ExtIndicator==11)
        {
         // поиск паттернов

         if (endSearchPattern) return;

         _Gartley(StringConcatenate("ExtIndicator=11_",minBars,"/",vSize), 0);

         if (saveParametersZZ)
           {
            saveParametersZZ=false;
            minSizeToNumberPattern=vSize;
          }

         if (ExtGartleyTypeSearch==0 && vPatOnOff) return;
        }
     }
 }
//--------------------------------------------------------
// Индикатор подобный встроенному в Ensign. Конец. 
//--------------------------------------------------------

//----------------------------------------------------
//  ZigZag (из МТ4 немного измененный). Начало.
//----------------------------------------------------
void ZigZag_()
  {
//  ZigZag из МТ. Начало.
   int    shift, back, lasthighpos, lastlowpos,lastpos;
   double val;
   double curlow,curhigh,lasthigh,lastlow;
   int    vDepth = 0, Depth;
   int    vBackstep = ExtBackstep; 
   bool   endCyklDirection=true;
   bool   endSearchPattern=false;
   int    i;

   if (ExtMaxBar>0) _maxbarZZ=ExtMaxBar; else _maxbarZZ=Bars;

   if (ExtIndicator==11)
     {
      Depth    = minDepth;
//      vBackstep = ExtBackstep;
     }
   else
     {
      Depth    = _minBars;
      minDepth = _minBars;
      maxDepth = _minBars;
      vBackstep = _ExtBackstep;
     }

   if (DirectionOfSearchMaxMin) vDepth = maxDepth; else vDepth = minDepth;

   while (endCyklDirection)
     {
      if (ExtIndicator==11)
        {
         if (ExtLabel>0) {ArrayInitialize(la,0.0); ArrayInitialize(ha,0.0);}
         ArrayInitialize(zz,0);ArrayInitialize(zzL,0);ArrayInitialize(zzH,0);

         if (DirectionOfSearchMaxMin)
           {
            if (vDepth < minDepth || endSearchPattern)
              {
               if (NumberPattern==0) {vDepth=_minBars; vBackstep=_ExtBackstep;}
               else
                 {
                  if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) {vDepth=minBarsToNumberPattern; vBackstep=vBackstepToNumberPattern;}
                  else {vDepth+=IterationStepDepth; if (FiboStep && vBackstep!=ExtBackstep) {vBackstep=vDepth*1.618;}}
                 }
               endSearchPattern=true;
              }

            Depth = vDepth;
            vDepth-=IterationStepDepth;
           }
         else
           {
            if (vDepth > maxDepth || endSearchPattern)
              {
               if (NumberPattern==0) {vDepth=_minBars; vBackstep=_ExtBackstep;}
               else
                 {
                  if (ExtGartleyTypeSearch>0 && ExtIndicator==11 && vPatOnOff) {vDepth=minBarsToNumberPattern; vBackstep=vBackstepToNumberPattern;}
                  else {vDepth-=IterationStepDepth; if (FiboStep && vBackstep!=ExtBackstep) {vBackstep=vDepth*1.618;}}
                 }
               endSearchPattern=true;
              }

            Depth = vDepth;
            vDepth+=IterationStepDepth;
           }

         if (flagExtGartleyTypeSearch2) {endSearchPattern=true; Depth=minBarsToNumberPattern;}
        }
      else
        {
         endCyklDirection=false;
        }

      minBarsX=Depth;
      
      // первый большой цикл
      for(shift=_maxbarZZ-Depth; shift>=ExtMinBar; shift--)
        {
         i=iLowest(NULL,0,MODE_LOW,Depth,shift);
         if (i==shift)
           {
            val=Low[i];
            if (!noBackstep)
              {
               if(val==lastlow) val=0.0;
               else 
                 { 
                  lastlow=val; 
                  for(back=1; back<=vBackstep; back++)
                    {
                     if(val<zzL[shift+back]) zzL[shift+back]=0.0; 
                    }
                 } 
              }
             zzL[shift]=val;
             if (ExtLabel>0) la[shift]=val;
            }

          i=iHighest(NULL,0,MODE_HIGH,Depth,shift);
          if (i==shift)
            {
             val=High[i];
            if (!noBackstep)
              {
                if(val==lasthigh) val=0.0;
                else 
                  {
                   lasthigh=val;
                   for(back=1; back<=vBackstep; back++)
                     {
                      if(val>zzH[shift+back]) zzH[shift+back]=0.0; 
                     }
                  }
               }
             zzH[shift]=val;
             if (ExtLabel>0) ha[shift]=val;
            }
        }

      // второй большой цикл 
      lasthigh=-1; lasthighpos=-1;
      lastlow=-1;  lastlowpos=-1;

      for(shift=_maxbarZZ-Depth; shift>=ExtMinBar; shift--)
        {
         curlow=zzL[shift];
         curhigh=zzH[shift];
         if((curlow==0)&&(curhigh==0)) continue;

         if(curhigh!=0)
           {
            if(lasthigh>0) 
              {
               if(lasthigh<curhigh) zzH[lasthighpos]=0;
               else zzH[shift]=0;
              }

            if(lasthigh<curhigh || lasthigh<0)
              {
               lasthigh=curhigh;
               lasthighpos=shift;
              }
            lastlow=-1;
           }

         if(curlow!=0)
           {
            if(lastlow>0)
              {
               if(lastlow>curlow) zzL[lastlowpos]=0;
               else zzL[shift]=0;
              }

            if((curlow<lastlow)||(lastlow<0))
              {
               lastlow=curlow;
               lastlowpos=shift;
              } 
            lasthigh=-1;
           }
        }

      // третий большой цикл
      lasthigh=-1; lasthighpos=-1;
      lastlow=-1;
      lastpos=-1;
      for(shift=_maxbarZZ-1; shift>=ExtMinBar; shift--)
        {
         zz[shift]=zzL[shift];
         if(shift>=_maxbarZZ-Depth) {zzH[shift]=0.0; zzL[shift]=0.0; zz[shift]=0.0;}
         else
           {
            if (!noBackstep)
              {
               if(zzH[shift]!=0.0) zz[shift]=zzH[shift];
              }
            else
              {
               if(zzH[shift]>0.0)
                 {
                  if (zz[shift]>0)
                    {
                     if (lasthigh>0 && iLow(NULL,0,shift)<iLow(NULL,0,lastpos) && iHigh(NULL,0,shift)>iHigh(NULL,0,lastpos)) zz[shift]=zzH[shift];
                    }
                  else zz[shift]=zzH[shift];
                 }
              }

            if (zz[shift]>0)
              {
               lastpos=shift;
               if (zzL[shift]==zz[shift])
                 {
                  curlow=zz[shift];
                  lasthigh=-1; curhigh=0; 
                  if (noBackstep)
                    {
                     if(lastlow>0)
                       {
                        if(lastlow>curlow) zz[lastlowpos]=0;
                        else zz[shift]=0;
                       }
                     //---
                     if(curlow<lastlow || lastlow<0)
                       {
                        lastlow=curlow;
                        lastlowpos=shift;
                       } 
                    }
                  continue;
                 }
               lastlow=-1;
               curhigh=zzH[shift];
               if(lasthigh>0) 
                 {
                  if(lasthigh<curhigh) zz[lasthighpos]=0;
                  else zz[shift]=0;
                 }

               if(lasthigh<curhigh || lasthigh<0)
                 {
                  lasthigh=curhigh;
                  lasthighpos=shift;
                 }
              }
           }
        }

      //----+ Восстановление экстремумов, удаленных параметром ExtBackstep. Начало.
      if (RecoverFiltr)
        {
         lasthigh=-1;
         lastlow= -1;
         for(shift=_maxbarZZ-Depth; shift>=ExtMinBar; shift--)
           {
            if (zz[shift]>0)
              {
               if (zzL[shift]==zz[shift])
                 {
                  lasthigh=-1;
                  lastlowpos=shift; lastlow=zz[shift];
                 }
               if (zzH[shift]==zz[shift])
                 {
                  lastlow=-1;
                  lasthighpos=shift; lasthigh=zz[shift];
                 }
              }

            if (lastlow>0)
              {
               if (lastlow>iLow(NULL,0,shift))
                 {
                  lastlow=iLow(NULL,0,shift);
                  zz[shift]=iLow(NULL,0,shift);
                  zz[lastlowpos]=0;
                  zzL[shift]=iLow(NULL,0,shift);
                  zzL[lastlowpos]=0;
                  lastlowpos=shift;
                 }
              }
            if (lasthigh>0)
              {
               if (lasthigh<iHigh(NULL,0,shift))
                 {
                  lasthigh=iHigh(NULL,0,shift);
                  zz[shift]=iHigh(NULL,0,shift);
                  zz[lasthighpos]=0;
                  zzH[shift]=iHigh(NULL,0,shift);
                  zzH[lasthighpos]=0;
                  lasthighpos=shift;
                 }
              }
           }
        }
      //----+ Восстановление экстремумов, удаленных параметром ExtBackstep. Конец.

      if (ExtIndicator!=11 && ExtLabel>0)  // расставляем метки на барах, где появился новый луч и на переломах зигзага
        {
         Metka();
        }

      // поиск паттернов
      if (ExtIndicator==11)
        {
         if (ExtLabel>0 && endSearchPattern)  // расставляем метки на барах, где появился новый луч и на переломах зигзага
           {
            Metka();
           }

         if (endSearchPattern)
           {
            if (NumberPattern!=0)
              {
               minBarsToNumberPattern=Depth;
               vBackstepToNumberPattern=vBackstep;
              }
            return;
           }

         _Gartley(StringConcatenate("ExtIndicator=11_0_",Depth,"/",vBackstep), Depth);

         if (saveParametersZZ)
           {
            saveParametersZZ=false;
            if (NumberPattern!=0)
              {
               minBarsToNumberPattern=Depth;
               vBackstepToNumberPattern=vBackstep;
              }
           }

         if (ExtGartleyTypeSearch==0 && vPatOnOff)
           {
            if (NumberPattern==0) endSearchPattern=true; //{vDepth=_minBars; vBackstep=_ExtBackstep; endSearchPattern=true;}
            else return;
           }

         if (FiboStep && !endSearchPattern) {vBackstep=vDepth*1.618;}
        }  // поиск паттернов конец
     }
  }
//--------------------------------------------------------
// ZigZag из МТ. Конец. 
//--------------------------------------------------------

//--------------------------------------------------------
// Расстановка меток. Начало.
//--------------------------------------------------------
void Metka()
  {
   int shift, metka=0; // =0 - до первого перелома ZZ. =1 - ищем метки максимумов. =2 - ищем метки минимумов.
   for(shift=Bars-1; shift>=0; shift--)
     {
      if (zz[shift]>0)
        {
         if (zzH[shift]>0)
           {
            metka=2; la[shift]=0; shift--;
           }
         else
           {
            metka=1; ha[shift]=0; shift--;
           }
        }

      if (metka==0)
        {
         ha[shift]=0; la[shift]=0;
        }
      else if (metka==1)
        {
         if (ha[shift]>0) metka=0;
         la[shift]=0;
        }
      else if (metka==2)
        {
         if (la[shift]>0) metka=0;
         ha[shift]=0;
        }
     }
  }
//--------------------------------------------------------
// Расстановка меток. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод потенциальных уровней точки D пятиточечных паттернов. 
// Начало.
//--------------------------------------------------------
void visibleLevelD(int i, string _vBullBear, int& iu, int & aXABCD[], double baza, double levelbaza, double AB, double BC, bool extremumAorC)
  {
// заносим уровень retXD в level_D[32] и level_nameD[32]
// передаваемые параметры i, vBullBear, iu, aXABCD[], baza, levelbaza, AB, BC, extremumAorC, typepatterns[i]

// retresmentXD[k-1][0]=i; // номер паттерна в списке
// retresmentXD[k-1][1]=j; // номера возможных ретресментов XD для данного паттерна
// retresmentBD[m-1][0]=i; // номер паттерна в списке
// retresmentBD[m-1][1]=j; // номера возможных ретресментов XB для данного паттерна
// arrXD_BD[0]=ArraySize(retresmentXD)/2; // размер массива retresmentXD
// arrXD_BD[1]=ArraySize(retresmentBD)/2; // размер массива retresmentBD

// double level_D[32];     // значение цены потенциального уровня точки D паттерна
// string level_nameD[32]; // наименование потенциального уровня точки D паттерна

   if (!levelD || ExtGartleyTypeSearch>0 || PotencialsLevels_retXD==0) return;

   double levelBx, levelDx, levelABCD, levelDmin, levelDmax;
   int    ii, j, m, n, savem;
   string txt;
   string vBear = "Bearish";
   double abcd[4]={1,1.272,1.618,2.618};
   string txtabcd[4]={"AB","1.272*AB","1.618*AB","2.618*AB"};
   string txtabcd1[4]={"AB=CD","1.272*AB=CD","1.618*AB=CD","2.618*AB=CD"};
   
   j=0; m=0;
   while (retresmentXD[j][0]<i) j++;
   while (retresmentBD[m][0]<i) m++;
   savem=m;

   while (j<arrXD_BD[0])
     {
      if (retresmentXD[j][0]==i)
        {
         levelDx=baza*retpatterns[retresmentXD[j][1]];

         if (_vBullBear==vBear)
           {
            levelDmin=levelbaza+levelDx*min_DeltaGartley;
            levelDmax=levelbaza+levelDx*max_DeltaGartley;
           }
         else
           {
            levelDmin=levelbaza+levelDx*max_DeltaGartley;
            levelDmax=levelbaza+levelDx*min_DeltaGartley;
           }
         levelDx=levelbaza+levelDx;

         if (extremumAorC)
           {

            for (ii=0;ii<4;ii++)
              {
               levelABCD=levelbaza-AB*abcd[ii]; // X*AB

               if (levelABCD>levelDmin && levelABCD<levelDmax)
                 {
                  for (n=0;n<32;n++)
                    {
                     if (level_D[n]==levelDx) break;
                     if (level_D[n]==0)
                       {
                        iu++;
                        level_D[iu]=levelDx;
                        level_nameD[iu]=StringConcatenate(namepatterns[i]," = ",retpatternstxt[retresmentXD[j][1]]);
                        break;
                       }
                    }

                  if (visibleLevelsABCD>1)
                    {
                     for (n=0;n<32;n++)
                       {
                        if (level_D[n]==levelABCD && level_nameD[n]==txtabcd[ii]) break;
                        if (level_D[n]==0)
                          {
                           iu++;
                           level_D[iu]=levelABCD;
                           level_nameD[iu]=txtabcd[ii];
                           break;
                          }
                       }
                    }
                 }

               levelABCD=zz[aXABCD[4]]-AB*abcd[ii]; // X*AB=CD

               if (levelABCD>levelDmin && levelABCD<levelDmax)
                 {
                  for (n=0;n<32;n++)
                    {
                     if (level_D[n]==levelDx) break;
                     if (level_D[n]==0)
                       {
                        iu++;
                        level_D[iu]=levelDx;
                        level_nameD[iu]=StringConcatenate(namepatterns[i]," = ",retpatternstxt[retresmentXD[j][1]]);
                        break;
                       }
                    }

                  if (visibleLevelsABCD>1)
                    {
                     for (n=0;n<32;n++)
                       {
                        if (level_D[n]==levelABCD && level_nameD[n]==txtabcd1[ii]) break;
                        if (level_D[n]==0)
                          {
                           iu++;
                           level_D[iu]=levelABCD;
                           level_nameD[iu]=txtabcd1[ii];
                           break;
                          }
                       }
                    }
                 }
              }
           }

         m=savem;
         while (m<arrXD_BD[1])
           {
            if (retresmentBD[m][0]>i) break;
            levelBx=zz[aXABCD[4]] + BC*retpatterns[retresmentBD[m][1]]; // zz[aXABCD[C]]
            if (levelBx>levelDmin && levelBx<levelDmax)
              {
               txt=StringConcatenate(namepatterns[i]," = ",retpatternstxt[retresmentXD[j][1]]);
               for (n=0;n<32;n++)
                 {
                  if (level_D[n]==levelDx && level_nameD[n]==txt) break;
                  if (level_D[n]==0)
                    {
                     iu++;
                     level_D[iu]=levelDx;
                     level_nameD[iu]=txt;
                     break;
                    }
                 }

               if (visibleLevelsABCD==1 || visibleLevelsABCD==3)
                 {
                  txt=StringConcatenate("Ret BD = ",retpatternstxt[retresmentBD[m][1]]);
                  for (n=0;n<32;n++)
                    {
                     if (level_D[n]==levelBx && level_nameD[n]==txt) break;
                     if (level_D[n]==0)
                       {
                        iu++;
                        level_D[iu]=levelBx;
                        level_nameD[iu]=txt;
                        break;
                       }
                    }
                 }
              }
            m++;
           }
        }
      else break;
      j++;
     }
  }                            
//--------------------------------------------------------
// Вывод потенциальных уровней точки D пятиточечных паттернов. 
// Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Чтение списка пятиточечных паттернов из файла. 
// Начало.
//--------------------------------------------------------
void mreadFromFileListPatterns()
  {
   int i, j, k, handle;
   string file, str;
   file=StringConcatenate("ZUP\ListPatterns\\",NameFileListPatterns,".csv");
   // открываем файл для чтения списка паттернов
   handle=FileOpen(file, FILE_CSV|FILE_READ);
   if (handle<0)
     {
      Print("File "+NameFileListPatterns+".csv not found");
      file="ZUP\ListPatterns\listpatternsdefault.csv";
      handle=FileOpen(file, FILE_CSV|FILE_READ);
      if (handle<0) {Print("File listpatternsdefault.csv not found"); return;}
      else Print("Read patterns from file listpatternsdefault.csv");
     }

   if (readFromFileListPatterns==1) {k=0; for (i=0;i<countPat;i++) namepatterns[i]=""; ArrayInitialize(pp,0);} // "обнуляем" массивы
   if (readFromFileListPatterns==2) {countPat=ArraySize(namepatterns); k=countPat; countPat++; ArrayResize(namepatterns,countPat); ArrayResize(pp,countPat);}

   j=0; str="0";
   while(true)
     {
      str=FileReadString(handle);
      if (j>0)
        {
         if (StringLen(str)==0) str="0";
         pp[k][j-1]=StrToDouble(str);
        }
      else
        {
         if (StringLen(str)==0)
           {
            FileClose(handle); // закрываем файл со списком паттернов
            ArrayResize(namepatterns,countPat); ArrayResize(pp,countPat);
            return;
           }
         if (k==countPat) {countPat++; ArrayResize(namepatterns,countPat); ArrayResize(pp,countPat);}
         namepatterns[k]=str;
        }
      j++;
      if (j==17) {j=0; k++;}
     }
   // закрываем файл со списком паттернов
   FileClose(handle);
  }
//--------------------------------------------------------
// Чтение списка пятиточечных паттернов из файла. 
// Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Запись списка пятиточечных паттернов в файл. 
// Начало.
//--------------------------------------------------------
void mwriteToFileListPatterns()
  {
   int i, handle;
   string file;
   if (readFromFileListPatterns==0) file="\\ZUP\ListPatterns\listpatternsdefault.csv";
   else if (readFromFileListPatterns==1) file="\\ZUP\ListPatterns\listpatternscustom.csv";
   else if (readFromFileListPatterns==2) file="\\ZUP\ListPatterns\listpatternsmixt.csv";
   // открываем файл для записи списка паттернов
   handle=FileOpen(file,FILE_CSV|FILE_WRITE,';');

   for (i=0;i<countPat;i++)
     {
      FileSeek(handle, 0, SEEK_END);
      FileWrite(handle, namepatterns[i], pp[i][0], pp[i][1], pp[i][2], pp[i][3], pp[i][4], pp[i][5], pp[i][6], pp[i][7], pp[i][8], pp[i][9], pp[i][10],
      pp[i][11], pp[i][12], pp[i][13], pp[i][14], pp[i][15]);
     }

   // закрываем файл для записи списка паттернов
   FileClose(handle);
  }
//--------------------------------------------------------
// Запись списка пятиточечных паттернов в файл. 
// Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Преобразование наименования таймфреймов. 
// Начало.
//--------------------------------------------------------
string _ChartTimeFrame (int Period__)
  {
   string chartTimeFrame="";
   
   if(Period__==1) chartTimeFrame="M1";
   else if(Period__==5) chartTimeFrame="M5";
   else if(Period__==15) chartTimeFrame="M15";
   else if(Period__==30) chartTimeFrame="M30";
   else if(Period__==60) chartTimeFrame="H1";
   else if(Period__==240) chartTimeFrame="H4";
   else if(Period__==1440) chartTimeFrame="D1";
   else if(Period__==10080) chartTimeFrame="W1";
   else if(Period__==43200) chartTimeFrame="MN1";
   
   return(chartTimeFrame);
  }
//--------------------------------------------------------
// Преобразование наименования таймфреймов. 
// Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод картинок с паттернами в файлы.
// Начало.
//--------------------------------------------------------
void writepicture()
  {
   string txt, file;
   int k;
   
   if (namefileSymbolPeriod)
     {
      file=StringConcatenate(Symbol(),"_",Period(),"_Patterns");
     }
   else
     {
      k  = StringFind(txt,"*");
      if (k>=0) txt = StringConcatenate(StringSubstr(txt,0,k),StringSubstr(txt,k+1));
  
      file = StringConcatenate("_",Symbol(),"_",_ChartTimeFrame(Period()),"_",vBullBearToNumberPattern);
      k  = StringFind(txt,"[");
     }

   if (k>0) file=StringSubstr(txt,0,k)+file;
   else file = txt+file;

   WindowScreenShot(StringConcatenate("ZUP\PicturePatterns\\",file,".gif"),900,600); // Write picture on MT4 files repository
  }
//--------------------------------------------------------
// Вывод картинок с паттернами в файлы.
// Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод информации о паттернах в файлы.
// Начало.
//--------------------------------------------------------
void WriteFilePattern(string BullBear,int patternNumber, int & aXABCD[],datetime tDragonE,double cDragonE, bool yes)
  {
	int handle, k;
	string FileName = "", txt, Name;
   k=StringFind(vNamePattern,"[",0);
   if (k>=0) txt=StringSubstr(vNamePattern,0,k-1); else txt=vNamePattern;

   if (namefileSymbolPeriod)
     {
      FileName = StringConcatenate(Symbol(),"_",Period(),"_Patterns");
     }
   else
     {
      FileName = StringConcatenate(txt,"_",Symbol(),"_",_ChartTimeFrame(Period()),"_",vBullBear);

      k  = StringFind(FileName,"*");
      if (k>=0) FileName = StringConcatenate(StringSubstr(FileName,0,k),StringSubstr(FileName,k+1));
     }

   if (!yes && namefileSymbolPeriod)
     {
      if (writeInfoPatternsToFileXML>0)
        {
      	Name = StringConcatenate("ZUP\\XML\\",FileName,".xml"); 
         FileDelete(Name);
        }

      if (writeInfoPatternsToFileCSV>0)
        {
      	Name = StringConcatenate("ZUP\CSV\\",FileName,".csv"); 
         FileDelete(Name);
        }
      return;
     }

   int O=0, X=1, A=2, B=3, C=4, D=5, numbarD;
   datetime TimeX, TimeA, TimeB, TimeC, TimeD;
   double cenaD;
   TimeX=iTime(Symbol(),Period(),aXABCD[X]);
   TimeA=iTime(Symbol(),Period(),aXABCD[A]);
   TimeB=iTime(Symbol(),Period(),aXABCD[B]);
   TimeC=iTime(Symbol(),Period(),aXABCD[C]);
   
   if (StringFind(vNamePattern,"Dragon",0)>=0)
     {
      TimeD=tDragonE;
      cenaD=cDragonE;
     }
   else
     {
      TimeD=iTime(Symbol(),Period(),aXABCD[D]);
      cenaD=zz[aXABCD[D]];
     }

   numbarD=iBarShift(Symbol(),Period(),TimeD,false);

   if (writeInfoPatternsToFileXML>0)
     {
   	Name = StringConcatenate("ZUP\\XML\\",FileName,".xml"); 
	   handle=FileOpen(Name,FILE_CSV|FILE_WRITE,' ');
   	
   	if(handle<1)
   	  {
   		Print("File ",Name," not found , the last error is ", GetLastError());
        }
   	else
   	  {
   		FileWrite(handle, "<Pattern>");
	     	FileWrite(handle, StringConcatenate("<Paire>",Symbol(),"</Paire>"));
		   FileWrite(handle, StringConcatenate("<TimeFrame>",_ChartTimeFrame(Period()),"</TimeFrame>"));
		   FileWrite(handle, StringConcatenate("<BullBear>",BullBear,"</BullBear>"));
   		FileWrite(handle, StringConcatenate("<Pattern>",txt,"</Pattern>"));		
   		FileWrite(handle, StringConcatenate("<X>",DoubleToStr(zz[aXABCD[X]],Digits),"</X>"));

         if (writeInfoPatternsToFileXML==1)
           {
        		FileWrite(handle, StringConcatenate("<X_Date>",TimeToStr(TimeX),"</X_Date>"));		
      		FileWrite(handle, StringConcatenate("<A>",DoubleToStr(zz[aXABCD[A]],Digits),"</A>"));
      		FileWrite(handle, StringConcatenate("<A_Date>",TimeToStr(TimeA),"</A_Date>"));		
   	    	FileWrite(handle, StringConcatenate("<B>",DoubleToStr(zz[aXABCD[B]],Digits),"</B>"));
   	     	FileWrite(handle, StringConcatenate("<B_Date>",TimeToStr(TimeB),"</B_Date>"));		
      		FileWrite(handle, StringConcatenate("<C>",DoubleToStr(zz[aXABCD[C]],Digits),"</C>"));
      		FileWrite(handle, StringConcatenate("<C_Date>",TimeToStr(TimeC),"</C_Date>"));		
      		FileWrite(handle, StringConcatenate("<D>",DoubleToStr(zz[aXABCD[D]],Digits),"</D>"));
      		FileWrite(handle, StringConcatenate("<D_Date>",TimeToStr(TimeD),"</D_Date>"));		
      		FileWrite(handle, StringConcatenate("<bar_D>",aXABCD[D],"</bar_D>"));
      		FileWrite(handle, StringConcatenate("<TimeForDmin>",TimeToStr(TimeForDmin),"</TimeForDmin>"));
      		FileWrite(handle, StringConcatenate("<LevelForDmin>",DoubleToStr(LevelForDmin,Digits),"</LevelForDmin>"));
      		FileWrite(handle, StringConcatenate("<TimeForDmax>",TimeToStr(TimeForDmax),"</TimeForDmax>"));
      		FileWrite(handle, StringConcatenate("<LevelForDmax>",DoubleToStr(LevelForDmax,Digits),"</LevelForDmax>"));
      		FileWrite(handle, "</Pattern>");
   		  }
   		else
   		  {
        		FileWrite(handle, StringConcatenate("<X_Date>",TimeX,"</X_Date>"));		
      		FileWrite(handle, StringConcatenate("<A>",DoubleToStr(zz[aXABCD[A]],Digits),"</A>"));
      		FileWrite(handle, StringConcatenate("<A_Date>",TimeA,"</A_Date>"));		
   	    	FileWrite(handle, StringConcatenate("<B>",DoubleToStr(zz[aXABCD[B]],Digits),"</B>"));
   	     	FileWrite(handle, StringConcatenate("<B_Date>",TimeB,"</B_Date>"));		
      		FileWrite(handle, StringConcatenate("<C>",DoubleToStr(zz[aXABCD[C]],Digits),"</C>"));
      		FileWrite(handle, StringConcatenate("<C_Date>",TimeC,"</C_Date>"));		
      		FileWrite(handle, StringConcatenate("<D>",DoubleToStr(zz[aXABCD[D]],Digits),"</D>"));
      		FileWrite(handle, StringConcatenate("<D_Date>",TimeD,"</D_Date>"));		
      		FileWrite(handle, StringConcatenate("<bar_D>",aXABCD[D],"</bar_D>"));
      		FileWrite(handle, StringConcatenate("<TimeForDmin>",TimeForDmin,"</TimeForDmin>"));
      		FileWrite(handle, StringConcatenate("<LevelForDmin>",DoubleToStr(LevelForDmin,Digits),"</LevelForDmin>"));
      		FileWrite(handle, StringConcatenate("<TimeForDmax>",TimeForDmax,"</TimeForDmax>"));
      		FileWrite(handle, StringConcatenate("<LevelForDmax>",DoubleToStr(LevelForDmax,Digits),"</LevelForDmax>"));
      		FileWrite(handle, "</Pattern>");
   		  }

   		FileClose(handle);
    	  }
	  }

   if (writeInfoPatternsToFileCSV>0)
     {
   	Name = StringConcatenate("ZUP\CSV\\",FileName,".csv"); 
	   handle=FileOpen(Name,FILE_CSV|FILE_WRITE,";");

   	if(handle<1)
   	  {
   		Print("File ",Name," not found, the last error is ", GetLastError());
        }
   	else
   	  {
         if (writeInfoPatternsToFileCSV==1)
           {
      		FileWrite(handle,Symbol(),patternNumber,numbarD,Period(),BullBear,txt,DoubleToStr(zz[aXABCD[X]],Digits),TimeToStr(TimeX),
   		          DoubleToStr(zz[aXABCD[A]],Digits),TimeToStr(TimeA),DoubleToStr(zz[aXABCD[B]],Digits),TimeToStr(TimeB),
   		          DoubleToStr(zz[aXABCD[C]],Digits),TimeToStr(TimeC),DoubleToStr(cenaD,Digits),TimeToStr(TimeD),aXABCD[D],
   		          TimeToStr(TimeForDmin),DoubleToStr(LevelForDmin,Digits),TimeToStr(TimeForDmax),DoubleToStr(LevelForDmax,Digits));
   		  }
   		else
   		  {
      		FileWrite(handle,Symbol(),patternNumber,numbarD,Period(),BullBear,txt,DoubleToStr(zz[aXABCD[X]],Digits),TimeX,
   		          DoubleToStr(zz[aXABCD[A]],Digits),TimeA,DoubleToStr(zz[aXABCD[B]],Digits),TimeB,
   		          DoubleToStr(zz[aXABCD[C]],Digits),TimeC,DoubleToStr(cenaD,Digits),TimeD,aXABCD[D],
   		          TimeForDmin,DoubleToStr(LevelForDmin,Digits),TimeForDmax,DoubleToStr(LevelForDmax,Digits));
   		  }

   		FileClose(handle);
        }
	  }

	return;
  }
//--------------------------------------------------------
// Вывод информации о паттернах в файлы.
// Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Поиск паттернов Gartley. Начало.
//--------------------------------------------------------
void _Gartley(string _Depth, int Depth)
  {
   int  i, in=0, ik[2], iu, j, k, m, shift, countRet;
//  0    1     2     3     4     5     6     7     8      9      10     11     12     13     14      15
//minXB,maxXB,minAC,maxAC,minBD,maxBD,minXD,maxXD,minXXA,maxXXA,minXCD,maxXCD,minXAB,maxXDC,TimeXXB,lineXB

   double   LevelForD;
   datetime timeLineD;
   double   bartoD=10000;
   double   vlXB=0, vhXB=0, vlAC=0, vhAC=0, vlBD=0, vhBD=0, vlXD=0, vhXD=0;
   double   vl618=min_DeltaGartley * 0.618;
   double   vh786=max_DeltaGartley * 0.786;
   double   vl886=min_DeltaGartley * 0.886;
   double   vh886=max_DeltaGartley * 0.886;
   double   vl1272=min_DeltaGartley * 1.272;
   double   vh1618=max_DeltaGartley * 1.618;

   int      countDots=5;
   int      patternNumber=-1;

   int      aXABCD[6]; // номера баров с точками O-X-A-B-C-D пятиточечных паттернов
   double   retXD, retXB, retBD, retAC, retOA;
   double   xxa, xcd, xab, xdc, xxb;
   double   OX, XA, BC, XC, BD, AB, AD, CD;
   double   baza, levelbaza;
   bool     extremumAorC; // A - true, C - false
   bool     PatternNews;
   bool     NoLevelD;
   
   double   vDelta0 = 0.00000001;
   int      O=0, X=1, A=2, B=3, C=4, D=5;
   string   nameObj1="", nameObj2="";
   string   vBull      = "Bullish";
   string   vBear      = "Bearish";
   string   v4Point    = "4-Point Continuation";
   string   vABCD      = "AB=CD";
   string   v3Drives   = "3 Drives";
   string   vDragon    = "Dragon";
   string   txt        = "";

   bool     v50        = false;
   datetime tDragonE   = 0;
   double   cDragonE   = 0;
   int      aNumBarPeak[];
   double   tangensXB;

   color    colorPattern=0;
   bool     filtrXB_;
   int      maxPeak = 0;

   LevelForDmin = 0;
   LevelForDmax = 0;
   vBullBear    = "";
   vNamePattern = "";

   if (ExtIndicator!=11) delete_objects3();
   if (PotencialsLevels_retXD>0) delete_FiboStrongPattern();

   if ((ExtGartleyTypeSearch==0 && ExtIndicator==11) || ExtIndicator!=11) vPatOnOff = false;

   ArrayResize(aNumBarPeak, ArraySize(zz));
   for(shift=0; shift<_maxbarZZ; shift++)
     {
      if (zz[shift]>0) {aNumBarPeak[maxPeak] = shift; maxPeak++;}
     }

   ArrayResize(aNumBarPeak, maxPeak);

   if (ExtIndicator>5 && ExtIndicator<11 && GrossPeriod>Period())
     {
      bartoD=maxBarToD;
     }
   else
     {
      if (patternInfluence==1)
        {
         bartoD=AllowedBandPatternInfluence*(aNumBarPeak[4]-aNumBarPeak[0]);
        }
      else if (patternInfluence==0)
        {
         bartoD=maxBarToD;
        }
     }

   ArrayInitialize(aXABCD,-1);
//   aXABCD[D] = aNumBarPeak[0];
   PatternNews=false;
   NoLevelD=(PatternNews && (ExtIndicator==11)) || ExtIndicator!=11;
   k = 0;
   while (k < maxPeak-6 && (aXABCD[D] < bartoD+2 || patternInfluence==2))
     {
      aXABCD[O] = aNumBarPeak[k + 5];
      aXABCD[X] = aNumBarPeak[k + 4];
      aXABCD[A] = aNumBarPeak[k + 3];
      aXABCD[B] = aNumBarPeak[k + 2];
      aXABCD[C] = aNumBarPeak[k + 1];
      if (k>=0) aXABCD[D] = aNumBarPeak[k]; else aXABCD[D] = aNumBarPeak[0];

      vBullBear    = "";
      vNamePattern = "";
      PatternNews=false;
      _InfoPointD = "";
      filtrXB_=false;
      countDots=0;
      tangensXB=(zz[aXABCD[B]]-zz[aXABCD[X]])/(aXABCD[X]-aXABCD[B]);

      if (zz[aXABCD[C]]>zz[aXABCD[D]])
        {
         vBullBear = vBull;
         if ((zz[aXABCD[B]]+(aXABCD[B]-aXABCD[D])*tangensXB)>zz[aXABCD[D]]) filtrXB_=true;
        }
      else if (zz[aXABCD[C]]<zz[aXABCD[D]])
        {
         vBullBear = vBear;
         if ((zz[aXABCD[B]]+(aXABCD[B]-aXABCD[D])*tangensXB)<zz[aXABCD[D]]) filtrXB_=true;
        }

      OX=0; XA=0; BC=0; XC=0; BD=0; AB=0; AD=0; CD=0; xxa=0; xcd=0; xab=0; xdc=0; xxb=0;
      iu=-1;
      // вычисляем размер лучей 
      OX  = zz[aXABCD[O]] - zz[aXABCD[X]];
      XA  = zz[aXABCD[X]] - zz[aXABCD[A]];
      BC  = zz[aXABCD[B]] - zz[aXABCD[C]];
      XC  = zz[aXABCD[X]] - zz[aXABCD[C]];
      BD  = zz[aXABCD[B]] - zz[aXABCD[D]];
      AB  = zz[aXABCD[A]] - zz[aXABCD[B]];
      AD  = zz[aXABCD[A]] - zz[aXABCD[D]];
      CD  = zz[aXABCD[C]] - zz[aXABCD[D]];

      if ((Ext_3Drives && OX==0) || XA==0 || AB==0 || BC==0) continue;

      if (vBullBear==vBull)
        {
         if (zz[aXABCD[A]]>zz[aXABCD[C]]) {baza=XA; levelbaza=zz[aXABCD[A]]; extremumAorC=true;}
         else {baza=XC; levelbaza=zz[aXABCD[C]]; extremumAorC=false;}
        }
      else if (zz[aXABCD[A]]<zz[aXABCD[C]]) {baza=XA; levelbaza=zz[aXABCD[A]]; extremumAorC=true;} else {baza=XC; levelbaza=zz[aXABCD[C]]; extremumAorC=false;}

      // определяем ретресменты
      if (Ext_3Drives) retOA = -XA/(OX);
      retXB = -AB/(XA);
      retAC = -BC/(AB);
      retBD = -CD/(BC);
      if ((zz[aXABCD[A]]>zz[aXABCD[C]] && vBullBear == vBull) || (zz[aXABCD[A]]<zz[aXABCD[C]] && vBullBear == vBear)) retXD = -AD/(XA); 
      else {if (XC==0) continue; retXD = -CD/(XC);}

      for (i=0;i<32;i++)
        {
         level_D[i]=0;
         level_nameD[i]="";
        }

      if (CustomPattern<2)
        {
         if (StringLen(vBullBear)>0)
           {
            // вычисляем коэффициенты
            xxa = XC/XA;
            xcd = AD/CD;
            xab = CD/AB;
            xdc = AB/CD;
//            xxb = ((iTime(NULL,0,aXABCD[D])-iTime(NULL,0,aXABCD[B]))*1.0)/((iTime(NULL,0,aXABCD[B])-iTime(NULL,0,aXABCD[X]))*1.0); // рассчет по времени
            xxb = ((aXABCD[D]-aXABCD[B])*1.0)/((aXABCD[B]-aXABCD[X])*1.0); // рассчет по количеству баров

            // определение точных ретресметов
            int kf[5];                          // счетчик количество фиб, попадающих в дельту
            int numberfiboP[4][2];              // номера фиб, попавших в дельту
            double df[5][2];                    // значения отклонений от фибы, попавшей в дельту

            ArrayInitialize(kf,0); ArrayInitialize(numberfiboP,-1); ArrayInitialize(df,-1); //ArrayInitialize(ret2,-1);
            for (i=1;i<6;i++) {ret[i,0]=-1; ret[i,1]=3;}

            vlXB = 0; vhXB = 0; vlAC = 0; vhAC = 0; vlBD = 0; vhBD = 0; vlXD = 0; vhXD = 0;
            for (i=1;i<20;i++)
              {
               if (kf[0]<2) if (retXD>=deltapatterns[2,i,0] && retXD<=deltapatterns[2,i,1]) {numberfiboP[0][kf[0]]=i; df[0][kf[0]]=MathAbs(retpatterns[i]-retXD); kf[0]++;}
               if (kf[1]<2) if (retXB>=deltapatterns[2,i,0] && retXB<=deltapatterns[2,i,1]) {numberfiboP[1][kf[1]]=i; df[1][kf[1]]=MathAbs(retpatterns[i]-retXB); kf[1]++;}
               if (kf[2]<2) if (retAC>=deltapatterns[2,i,0] && retAC<=deltapatterns[2,i,1]) {numberfiboP[2][kf[2]]=i; df[2][kf[2]]=MathAbs(retpatterns[i]-retAC); kf[2]++;}
               if (kf[3]<2) if (retBD>=deltapatterns[2,i,0] && retBD<=deltapatterns[2,i,1]) {numberfiboP[3][kf[3]]=i; df[3][kf[3]]=MathAbs(retpatterns[i]-retBD); kf[3]++;}
               if (Ext_3Drives) {if (kf[4]<2) if (retOA>=deltapatterns[2,i,0] && retOA<=deltapatterns[2,i,1]) {numberfiboP[4][kf[3]]=i; df[4][kf[4]]=MathAbs(retpatterns[i]-retOA); kf[4]++;}}
              }

            for (i=0; i<6; i++)
              {
               if (numberfiboP[i][1]>=0)
                 {
                  ret[i,1]=2;
                  if (df[i][0]<df[i][1]) ret[i,0]=numberfiboP[i][0]; else ret[i,0]=numberfiboP[i][1];
                 }
               else if (numberfiboP[i][0]>=0)
                 {
                  ret[i,1]=2;
                  ret[i][0]=numberfiboP[i][0];
                 }
              }
            if (ret[0,0]>=0)
              {
               if (retXD>=deltapatterns[0,ret[0,0],0] && retXD<=deltapatterns[0,ret[0,0],1]) ret[0,1]=0;
               else if (retXD>=deltapatterns[1,ret[0,0],0] && retXD<=deltapatterns[1,ret[0,0],1]) ret[0,1]=1;
               vlXD = deltapatterns[ret[0,1],ret[0,0],0]; vhXD = deltapatterns[ret[0,1],ret[0,0],1];
              }

            if (ret[1,0]>=0)
              {
               if (retXB>=deltapatterns[0,ret[1,0],0] && retXB<=deltapatterns[0,ret[1,0],1]) ret[1,1]=0;
               else if (retXB>=deltapatterns[1,ret[1,0],0] && retXB<=deltapatterns[1,ret[1,0],1]) ret[1,1]=1;
               vlXB = deltapatterns[ret[1,1],ret[1,0],0]; vhXB = deltapatterns[ret[1,1],ret[1,0],1];
              }

            if (ret[2,0]>=0)
              {
               if (retAC>=deltapatterns[0,ret[2,0],0] && retAC<=deltapatterns[0,ret[2,0],1]) ret[2,1]=0;
               else if (retAC>=deltapatterns[1,ret[2,0],0] && retAC<=deltapatterns[1,ret[2,0],1]) ret[2,1]=1;
               vlAC = deltapatterns[ret[2,1],ret[2,0],0]; vhAC = deltapatterns[ret[2,1],ret[2,0],1];
              }

            if (ret[3,0]>=0)
              {
               if (retBD>=deltapatterns[0,ret[3,0],0] && retBD<=deltapatterns[0,ret[3,0],1]) ret[3,1]=0;
               else if (retBD>=deltapatterns[1,ret[3,0],0] && retBD<=deltapatterns[1,ret[3,0],1]) ret[3,1]=1;
               vlBD = deltapatterns[ret[3,1],ret[3,0],0]; vhBD = deltapatterns[ret[3,1],ret[3,0],1];
              }

            if (ret[4,0]>=0)
              {
               if (retOA>=deltapatterns[0,ret[4,0],0] && retOA<=deltapatterns[0,ret[4,0],1]) ret[4,1]=0;
               else if (retOA>=deltapatterns[1,ret[4,0],0] && retOA<=deltapatterns[1,ret[4,0],1]) ret[4,1]=1;
//               vlOA = deltapatterns[ret[4,1],ret[4,0],0]; vhOA = deltapatterns[ret[4,1],ret[4,0],1];
              }

            countRet=0;
            if (ret[1,0]>0) {countRet=1; if (ret[2,0]>0) {countRet=2; if (ret[3,0]>0) {countRet=3; if (ret[0,0]>0) countRet=4;}}}

            if (SelectPattern<8) // отключен поиск пятиточечных паттернов из списка паттернов при SelectPattern=8
              {
               v50 = false; patternNumber=-1;
               for (i=0;i<countPat;i++)
                 {
                  if (!CustomPat_[i]) continue; 

                  // рассчитываем границы ретресментов для вычисления рамки точки D паттерна

                  if (ret[0,0]<vDelta0 || OldNewRangeForPointD)
                    {
                     vlXD = minXD_[i];
                     vhXD = maxXD_[i];
                    }

                  if (ret[3,0]<vDelta0 || OldNewRangeForPointD)
                    {
                     vlBD = minBD_[i];
                     vhBD = maxBD_[i];
                    }

                  switch (typepatterns[i])
                    {
                     case 0:  // классика и А классика , Total
                       if (((pp[i][15]>0 && filtrXB_) || pp[i][15]==0) && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i] && retBD>=minBD_[i] && retBD<=maxBD_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i])
                         {
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;
                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (retAC<1)
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                         LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                        }
                                      else
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                         LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                        }
                                     }
                                   else
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                         LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                        }
                                      else
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                         LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                        }
                                     }
                                  }
                               }

                             // заносим уровень retXD в level_D[32] и level_nameD[32]
                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             // заносим уровень retXD в level_D[32] и level_nameD[32]
                             if (!(iu>=0 && (StringFind(namepatterns[i],"TOTAL",0)>=0
                                     || StringFind(namepatterns[i],"Swan",0)>=0
                                     || (StringFind(namepatterns[i],"max",0)>=0 && StringFind(namepatterns[i],StringSubstr(vNamePattern,0,3),0)>=0))))
                               {
                                if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                               }
                            }
                         }
                       else if (countRet>1 && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i])
                         {
                          // заносим уровень retXD в level_D[32] и level_nameD[32]
                          if (!(iu>=0 && (StringFind(namepatterns[i],"TOTAL",0)>=0
                              || StringFind(namepatterns[i],"Swan",0)>=0
                              || (StringFind(namepatterns[i],"max",0)>=0 && StringFind(namepatterns[i],StringSubstr(vNamePattern,0,3),0)>=0))))
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       break;
                     case 1:  // Bat & Butterfly
                       if (((pp[i][15]>0 && filtrXB_) || pp[i][15]==0) && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i] && retBD>=minBD_[i] && retBD<=maxBD_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i] && xab>=minXAB_[i])
                         {
                          if (!PatternNews)
                            { // как для классики
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;
                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (retAC<1)
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                         LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                        }
                                      else
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                         LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                        }
                                     }
                                   else
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                         LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                        }
                                      else
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                         LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                        }
                                     }
                                  }
                               }

                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             if (!(iu>=0 && (StringFind(namepatterns[i],"max",0)>=0 && StringFind(namepatterns[i],StringSubstr(vNamePattern,0,3),0)>=0)))
                               {
                                if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                               }
                            }
                         }
                       else if (countRet>1 && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i])
                         {
                          if (!(iu>=0 && (StringFind(namepatterns[i],"max",0)>=0 && StringFind(namepatterns[i],StringSubstr(vNamePattern,0,3),0)>=0)))
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       break;
                     case 2:  // A Bat & A Butterfly
                       if (((pp[i][15]>0 && filtrXB_) || pp[i][15]==0) && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i] && retBD>=minBD_[i] && retBD<=maxBD_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i] && xdc<=maxXDC_[i])
                         { // как для классики
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;

                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (retAC<1)
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                         LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                        }
                                      else
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                         LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                        }
                                     }
                                   else
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                         LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                        }
                                      else
                                        {
                                         LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                         LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                        }
                                     }
                                  }
                               }

                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       else if (countRet>1 && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i])
                         {
                          if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                         }
                       break;
                     case 3:  // 5-0 и A 5-0
                       if (retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i] && retBD>=minBD_[i] && retBD<=maxBD_[i])
                         {
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;
                                v50=true;

                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (vBullBear==vBull)
                                     {
                                      LevelForDmin = zz[aXABCD[C]]+BC*vhBD;
                                      LevelForDmax = zz[aXABCD[C]]+BC*vlBD;
                                     }
                                   else
                                     {
                                      LevelForDmin = zz[aXABCD[C]]+BC*vlBD;
                                      LevelForDmax = zz[aXABCD[C]]+BC*vhBD;
                                     }
                                  }
                               }
                            }
                         }
                       break;
                     case 4:  // Cypher , Nen Star
                       if (((pp[i][15]>0 && filtrXB_) || pp[i][15]==0) && retXB>=minXB_[i] && retXB<=maxXB_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i] && xxa>=minXXA_[i] && xxa<=maxXXA_[i])
                         {
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;

                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (vBullBear==vBull)
                                     {
                                      LevelForDmin = zz[aXABCD[C]]+XC*vhXD;
                                      LevelForDmax = zz[aXABCD[C]]+XC*vlXD;
                                     }
                                   else
                                     {
                                      LevelForDmin = zz[aXABCD[C]]+XC*vlXD;
                                      LevelForDmax = zz[aXABCD[C]]+XC*vhXD;
                                     }
                                  }
                               }

                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       else if (retXB>=minXB_[i] && retXB<=maxXB_[i] && xxa>=minXXA_[i] && xxa<=maxXXA_[i])
                         {
                          if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                         }
                       break;
                     case 5:  // A Cypher
                       if (((pp[i][15]>0 && filtrXB_) || pp[i][15]==0) && retBD>=minBD_[i] && retBD<=maxBD_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i] && xcd>=minXCD_[i] && xcd<=maxXCD_[i])
                         {
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;

                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (vBullBear==vBull)
                                     {
                                      LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                      LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                     }
                                   else
                                     {
                                      LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                      LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                     }
                                  }
                               }

                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       break;
                     case 6:  // Shark
                       if (((pp[i][15]>0 && filtrXB_) || pp[i][15]==0) && retAC>=minAC_[i] && retAC<=maxAC_[i] && retBD>=minBD_[i] && retBD<=maxBD_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i])
                         {
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;

                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (vBullBear==vBull)
                                     {
                                      LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                      LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                     }
                                   else
                                     {
                                      LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                                      LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                                     }
                                  }
                               }

                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       break;
                     case 7:  // A Shark
                       if (((pp[i][15]>0 && filtrXB_) || pp[i][15]==0) && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i])
                         {
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;

                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (vBullBear==vBull)
                                     {
                                      LevelForDmin = zz[aXABCD[A]]+XA*vhXD;
                                      LevelForDmax = zz[aXABCD[A]]+XA*vlXD;
                                     }
                                   else
                                     {
                                      LevelForDmin = zz[aXABCD[A]]+XA*vlXD;
                                      LevelForDmax = zz[aXABCD[A]]+XA*vhXD;
                                     }
                                  }
                               }

                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       else if (countRet>1 && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i])
                         {
                          if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                         }
                       break;
                     case 8:  // Navarro
                       if (retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i] && retXD>=minXD_[i] && retXD<=maxXD_[i] && xxb>=pp[i][14]-0.1 && xxb<=pp[i][14]+0.1)
                         {
                          if (!PatternNews)
                            {
                             if (PotencialsLevels_retXD<2)
                               {
                                vNamePattern=NamePattern(i);
                                patternNumber=i;
                                countDots=5;

                                // рассчитываем зону развития точки D паттерна
                                if (RangeForPointD || patternTrue)
                                  {
                                   if (retAC<1)
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = zz[aXABCD[A]]+XA*vhXD;
                                         LevelForDmax = zz[aXABCD[A]]+XA*vlXD;
                                        }
                                      else
                                        {
                                         LevelForDmin = zz[aXABCD[A]]+XA*vlXD;
                                         LevelForDmax = zz[aXABCD[A]]+XA*vhXD;
                                        }
                                     }
                                   else
                                     {
                                      if (vBullBear==vBull)
                                        {
                                         LevelForDmin = zz[aXABCD[C]]+XC*vhXD;
                                         LevelForDmax = zz[aXABCD[C]]+XC*vlXD;
                                        }
                                      else
                                        {
                                         LevelForDmin = zz[aXABCD[C]]+XC*vlXD;
                                         LevelForDmax = zz[aXABCD[C]]+XC*vhXD;
                                        }
                                     }
                                  }
                               }

                             visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                          else
                            {
                             if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                            }
                         }
                       else if (countRet>1 && retXB>=minXB_[i] && retXB<=maxXB_[i] && retAC>=minAC_[i] && retAC<=maxAC_[i] && xxb<=pp[i][14]+0.1)
                         {
                          if (NoLevelD) visibleLevelD(i, vBullBear, iu, aXABCD, baza, levelbaza, AB, BC, extremumAorC);
                         }
                       break;
                     case -1:
                       break; // нет определения паттерна
//                     default:   // зарезервировано на всякий случай. В этой секции код не работает.
                    }

                  // фильтрация паттернов
                  PatternNews=filtrpatterns_1(k, aXABCD[D], vBull, aNumBarPeak, LevelForDmin, LevelForDmax);
                  NoLevelD=(PatternNews && ExtIndicator==11 && typepatterns[i]!=3) || ExtIndicator!=11;

                  // выключение поиска при нахождении первого паттерна
                  if (PatternNews && ExtGartleyTypeSearch>0) break;
                 }
              } // конец поиска пятиточечных паттернов из включенного в код списка паттернов

            if (Ext_3Drives && !PatternNews && PotencialsLevels_retXD<2)
              {
               if (ret[3,0]<0) {vlBD = vl1272; vhBD = vh1618;}

               // 3 Drives (6 point)
               if ((zz[aXABCD[C]]>zz[aXABCD[D]] && zz[aXABCD[O]]>zz[aXABCD[A]]) || (zz[aXABCD[C]]<zz[aXABCD[D]] && zz[aXABCD[O]]<zz[aXABCD[A]]))
                 {
                  if (retOA>=vl618 && retOA<=vh786 && retXB>=vl1272 && retXB<=vh1618 && retAC>=vl618 && retAC<=vh786 && retBD>=vl1272 && retBD<=vh1618
                           && (aXABCD[A]-aXABCD[C])>0.618*(aXABCD[O]-aXABCD[A]) && (aXABCD[A]-aXABCD[C])<1.382*(aXABCD[O]-aXABCD[A])
                           && (aXABCD[B]-aXABCD[D])>0.618*(aXABCD[X]-aXABCD[B]) && (aXABCD[B]-aXABCD[D])<1.382*(aXABCD[X]-aXABCD[B]))
                    {
                     vNamePattern=v3Drives;
                     countDots=6;
                     if (vBullBear==vBull)
                       {
                        LevelForDmin = zz[aXABCD[C]]+BC*vh1618;
                        LevelForDmax = zz[aXABCD[C]]+BC*vl1272;
                       }
                     else
                       {
                        LevelForDmin = zz[aXABCD[C]]+BC*vl1272;
                        LevelForDmax = zz[aXABCD[C]]+BC*vh1618;
                       }
                    }
                  // 3 Drives (5 point)
                  else if (retXB>=vl1272 && retXB<=vh1618 && retAC>=vl618 && retAC<=vh786 && retBD>=vl1272 && retBD<=vh1618
                            && (aXABCD[B]-aXABCD[D])>0.618*(aXABCD[X]-aXABCD[B]) && (aXABCD[B]-aXABCD[D])<1.382*(aXABCD[X]-aXABCD[B]))
                    {
                     vNamePattern=v3Drives;
                     countDots=5;
                     if (vBullBear==vBull)
                       {
                        LevelForDmin = zz[aXABCD[C]]+BC*vhBD;
                        LevelForDmax = zz[aXABCD[C]]+BC*vlBD;
                       }
                     else
                       {
                        LevelForDmin = zz[aXABCD[C]]+BC*vlBD;
                        LevelForDmax = zz[aXABCD[C]]+BC*vhBD;
                       }
                    }
                 }
 
               if (vNamePattern==v3Drives) // проверка на альтернативный 3 Drives
                 {
                  double fiboAlt3Dr[11]={0.618,0.707,0.786,0.886,1.128,1.272,1.414,1.618,2.236,2.618,3.14};
                  string txtfiboAlt3Dr[11]={".618",".707",".786",".886","1.128","1.272","1.414","1.618","2.236","2.618","3.14"};
                  int kd=k+6, id;
                  int arr3Dr[2]; // [0]-max, [1]-min  (точка O, точка x)
                  int ret3Dr, peakO;
                  double max3Dr=0, min3Dr=0, retxD, wrx, tangens3Dr, wrtg;
                  bool pereschet;

                  tangens3Dr=(zz[aXABCD[B]]-zz[aXABCD[D]])/(aXABCD[B]-aXABCD[D]);
                  wrtg=(zz[aXABCD[X]]-zz[aXABCD[D]])/(aXABCD[X]-aXABCD[D]);

                  if (vBullBear==vBull)
                    {
                     if (wrtg<tangens3Dr) tangens3Dr=wrtg;
                    }
                  else
                    {
                     if (wrtg>tangens3Dr) tangens3Dr=wrtg;
                    }

                  peakO=aXABCD[O];
                  if (vBullBear==vBull) {max3Dr=High[aXABCD[O]]; min3Dr=zz[aXABCD[D]]+tangens3Dr*(aNumBarPeak[kd]-aXABCD[D]); arr3Dr[0]=aXABCD[O]; arr3Dr[1]=aNumBarPeak[kd];} 
                  else {max3Dr=zz[aXABCD[D]]+tangens3Dr*(aNumBarPeak[kd]-aXABCD[D]); min3Dr=Low[aXABCD[O]]; arr3Dr[0]=aNumBarPeak[kd]; arr3Dr[1]=aXABCD[O];}
                  if (max3Dr==min3Dr) min3Dr=max3Dr-vDelta0;
                  
                  for (id=kd;id<maxPeak && aNumBarPeak[id]-peakO<Ext_xO*(peakO-aXABCD[D]);id++)
                    {
                     pereschet=false;
                     wrx=zz[aXABCD[D]]+tangens3Dr*(aNumBarPeak[id]-aXABCD[D]);

                     if (max3Dr<=zz[aNumBarPeak[id]])
                       {
                        if (vBullBear==vBull)
                          {
                           max3Dr=zz[aNumBarPeak[id]]; arr3Dr[0]=aNumBarPeak[id];
                           peakO=aNumBarPeak[id];
                          }
                        else
                          {
                           if (wrx<zz[aNumBarPeak[id]])
                             {
                              max3Dr=zz[aNumBarPeak[id]]; arr3Dr[0]=aNumBarPeak[id];
                              tangens3Dr=(zz[aNumBarPeak[id]]-zz[aXABCD[D]])/(aNumBarPeak[id]-aXABCD[D]);
                             }
                          }
                        pereschet=true; 
                       }

                     if (min3Dr>=zz[aNumBarPeak[id]])
                       {
                        if (vBullBear==vBear)
                          {
                           min3Dr=zz[aNumBarPeak[id]]; arr3Dr[1]=aNumBarPeak[id];
                           peakO=aNumBarPeak[id];
                          }
                        else
                          {
                           if (wrx>zz[aNumBarPeak[id]])
                             {
                              min3Dr=zz[aNumBarPeak[id]]; arr3Dr[1]=aNumBarPeak[id];
                              tangens3Dr=(zz[aNumBarPeak[id]]-zz[aXABCD[D]])/(aNumBarPeak[id]-aXABCD[D]);
                             }
                          }
                        pereschet=true; 
                       }

                     if (vBullBear==vBull)
                       {
                        if (arr3Dr[0]>arr3Dr[1])
                          {
                           min3Dr=zz[aXABCD[D]] + tangens3Dr*(aNumBarPeak[id]-aXABCD[D]); arr3Dr[1]=aNumBarPeak[id];
                           continue;
                          }
                       }
                     else
                       {
                        if (arr3Dr[1]>arr3Dr[0])
                          {
                           max3Dr=zz[aXABCD[D]] + tangens3Dr*(aNumBarPeak[id]-aXABCD[D]); arr3Dr[0]=aNumBarPeak[id];
                           continue;
                          }
                       }

                     if (pereschet)
                       {
                        for (i=0;i<11;i++)
                          {
                           if (vBullBear==vBull)
                             {
                              retxD=(max3Dr-zz[aXABCD[D]])/(max3Dr-min3Dr);
                              if (retxD>=min_DeltaGartley*fiboAlt3Dr[i] && retxD<=max_DeltaGartley*fiboAlt3Dr[i])
                                {
                                 if (zz[aXABCD[D]]>=max3Dr-(max3Dr-min3Dr)*max_DeltaGartley*fiboAlt3Dr[i] && zz[aXABCD[D]]<=max3Dr-(max3Dr-min3Dr)*min_DeltaGartley*fiboAlt3Dr[i])
                                   {
                                    ret3Dr=i;
                                    countDots=7;
                                    break;
                                   }
                                }
                             }
                           else
                             {
                              retxD=(zz[aXABCD[D]]-min3Dr)/(max3Dr-min3Dr);
                              if (retxD>=min_DeltaGartley*fiboAlt3Dr[i] && retxD<=max_DeltaGartley*fiboAlt3Dr[i])
                                {
                                 if (zz[aXABCD[D]]<=min3Dr+(max3Dr-min3Dr)*max_DeltaGartley*fiboAlt3Dr[i] && zz[aXABCD[D]]>=min3Dr+(max3Dr-min3Dr)*min_DeltaGartley*fiboAlt3Dr[i])
                                   {
                                    ret3Dr=i;
                                    countDots=7;
                                    break;
                                   }
                                }
                             }
                          }
                       }
                     if (countDots==7)
                       {
                        if (i<10)
                          {
                           if (vBullBear==vBull)
                             {
                              if (MathAbs(max3Dr-(max3Dr-min3Dr)*fiboAlt3Dr[i]-zz[aXABCD[D]])>MathAbs(max3Dr-(max3Dr-min3Dr)*fiboAlt3Dr[i+1]-zz[aXABCD[D]])) ret3Dr=i+1;
                             }
                           else
                             {
                              if (MathAbs(min3Dr+(max3Dr-min3Dr)*fiboAlt3Dr[i]-zz[aXABCD[D]])>MathAbs(min3Dr+(max3Dr-min3Dr)*fiboAlt3Dr[i+1]-zz[aXABCD[D]])) ret3Dr=i+1;
                             }
                          }

                        ret[4,0]=ret3Dr;
                        if (ret[4,0]>=0)
                          {
                           ret[4,1]=2;
                           if (retxD>=fiboAlt3Dr[ret3Dr]*(1 - ExtDeltaGartleyPRZ) && retxD<=fiboAlt3Dr[ret3Dr]*(1 + ExtDeltaGartleyPRZ)) ret[4,1]=0;
                           else if (retxD>=fiboAlt3Dr[ret3Dr]*(1 - ExtDelta) && retxD<=fiboAlt3Dr[ret3Dr]*(1 + ExtDelta)) ret[4,1]=1;
                          }
                        break;
                       }
                    }
                 }

               PatternNews=filtrpatterns_1(k, aXABCD[D], vBull, aNumBarPeak, LevelForDmin, LevelForDmax);
               if (PatternNews && countDots==7) vNamePattern=StringConcatenate("Alt ",vNamePattern," [",txtfiboAlt3Dr[ret3Dr],"]");
              }

            if (Dragon && !PatternNews && k<=PeakZZDragon && PotencialsLevels_retXD<2 && filtrXB_)
              {
               vlXB=min_DeltaGartley * 0.382;
               vhXB=max_DeltaGartley * 0.618;
               vlAC=min_DeltaGartley * 0.886;
               vhAC=max_DeltaGartley * 1.128;

               datetime save_tDragonE=0;
               double   save_cDragonE=0;

               if (retXB>=vlXB && retXB<=vhXB && retAC>=vlAC && retAC<=vhAC)
                 {
                  vNamePattern=vDragon;
                  countDots=5;
                  cDragonE=zz[aXABCD[X]]+(aXABCD[X]-aXABCD[C])*tangensXB;
                  if ((vBullBear==vBear && cDragonE<iLow(NULL,0,aXABCD[C])) || (vBullBear==vBull && cDragonE>iHigh(NULL,0,aXABCD[C]))) vNamePattern="";
                  else
                    {
                     tDragonE=0;
                     double _level=0;

                     if (vBullBear==vBull)
                       {
                        _level=MathMax(iHigh(NULL,0,aXABCD[A]),iHigh(NULL,0,aXABCD[C]));
                       }
                     else
                       {
                        _level=MathMin(iLow(NULL,0,aXABCD[A]),iLow(NULL,0,aXABCD[C]));
                       }

                     for (i=aXABCD[C];i>=0;i--)
                       {
                        if (tDragonE==0)
                          {
                           cDragonE=zz[aXABCD[X]]+(aXABCD[X]-i)*tangensXB;
                           if (vBullBear==vBull)
                             {
                              if ((cDragonE>=iLow(NULL,0,i) && cDragonE<=iHigh(NULL,0,i)) || cDragonE>iHigh(NULL,0,i))
                                {
                                 if (i==aXABCD[C])
                                   {
                                    save_tDragonE=iTime(NULL,0,i);
                                    save_cDragonE=cDragonE;
                                    continue;
                                   }
                                 tDragonE=iTime(NULL,0,i); i++;
                                }
                             }
                           else
                             {
                              if ((cDragonE>=iLow(NULL,0,i) && cDragonE<=iHigh(NULL,0,i)) || cDragonE<iLow(NULL,0,i))
                                {
                                 if (i==aXABCD[C])
                                   {
                                    save_tDragonE=iTime(NULL,0,i);
                                    save_cDragonE=cDragonE;
                                    continue;
                                   }
                                 tDragonE=iTime(NULL,0,i); i++;
                                }
                             }
                          }
                        else
                          {
                           break;
                          }
                       }

                     if (tDragonE==0)
                       {
                        tDragonE=save_tDragonE;
                        cDragonE=save_cDragonE;
                       }

                     if (vBullBear==vBear)
                       {
                        if (_level>iLow(NULL,0,i)) {vNamePattern=""; tDragonE=0; cDragonE=0;}
                       }
                     else
                       {
                        if (_level<iHigh(NULL,0,i)) {vNamePattern=""; tDragonE=0; cDragonE=0;}
                       }

                     LevelForDmin = cDragonE;
                     LevelForDmax = cDragonE;

                     if (vNamePattern==vDragon && tDragonE>0) PatternNews=true; else PatternNews=false;

                     PatternNews=filtrpatterns_1(k, aXABCD[D], vBear, aNumBarPeak, _level, _level);

                     if (!PatternNews) {vNamePattern=""; tDragonE=0; cDragonE=0;}
                    }
                 }
              }
           }
        }

      // CustomPattern
      if (CustomPattern>0 && !PatternNews && PotencialsLevels_retXD<2)
        {
         vlAC = minAC;
         vlBD = minBD;
         vlXB = minXB;
         vlXD = minXD;

         vhAC = maxAC;
         vhBD = maxBD;
         vhXB = maxXB;
         vhXD = maxXD;

         if (StringLen(vBullBear)>0)
           {
            if (((filtrXB_ && filtrEquilibrium) || !filtrEquilibrium) && retAC>vlAC && retAC<vhAC && retBD>vlBD && retBD<vhBD && retXB>vlXB && retXB<vhXB && retXD>vlXD && retXD<vhXD)
              {
               vNamePattern=NameCustomPattern; // Custom
               countDots=5;
               // рассчитываем зону развития точки D паттерна
               if (RangeForPointD || patternTrue)
                 {
                  if (retAC<1)
                    {
                     if (vBullBear==vBull)
                       {
                        LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                        LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                       }
                     else
                       {
                        LevelForDmin = MathMax(zz[aXABCD[A]]+XA*vlXD,zz[aXABCD[C]]+BC*vlBD);
                        LevelForDmax = MathMin(zz[aXABCD[A]]+XA*vhXD,zz[aXABCD[C]]+BC*vhBD);
                       }
                    }
                  else
                    {
                     if (vBullBear==vBull)
                       {
                        LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                        LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                       }
                     else
                       {
                        LevelForDmin = MathMax(zz[aXABCD[C]]+XC*vlXD,zz[aXABCD[C]]+BC*vlBD);
                        LevelForDmax = MathMin(zz[aXABCD[C]]+XC*vhXD,zz[aXABCD[C]]+BC*vhBD);
                       }
                    }
                 }

               // фильтрация паттернов
               PatternNews=filtrpatterns_1(k, aXABCD[D], vBull, aNumBarPeak, LevelForDmin, LevelForDmax);
              }
           }
        }

      // The 4-Point Continuation Pattern - Jim Kane
      if (CustomPattern<2 && Ext_4PointPattern && !PatternNews && PotencialsLevels_retXD<2)
        {
         vlAC=min_DeltaGartley * 0.786;
         vlBD=min_DeltaGartley * 0.786;

         vhAC = max_DeltaGartley * 0.886;
         vhBD = max_DeltaGartley * 0.886;

         if ((zz[aXABCD[A]] - zz[aXABCD[B]]) / (zz[aXABCD[A]] - zz[aXABCD[X]] + vDelta0)<_maxXB)
           {
            if (retAC>vlAC && retAC<vhAC && retBD>vlBD && retBD<vhBD)
              {
               vNamePattern=v4Point; // The 4-Point Continuation Pattern
               countDots=4;

               // рассчитываем зону развития точки D паттерна
               if (RangeForPointD || patternTrue)
                 {
                  if (vBullBear==vBull)
                    {
                     LevelForDmin = zz[aXABCD[C]]+BC*vhBD;
                     LevelForDmax = zz[aXABCD[C]]+BC*vlBD;
                    }
                  else
                    {
                     LevelForDmin = zz[aXABCD[C]]+BC*vlBD;
                     LevelForDmax = zz[aXABCD[C]]+BC*vhBD;
                    }

                  // фильтрация паттернов
                  PatternNews=filtrpatterns_1(k, aXABCD[D], vBull, aNumBarPeak, LevelForDmin, LevelForDmax);
                 }
              }
           }
        }

      // ABCD Pattern
      if (CustomPattern<2 && (ABCD>0 || searchABCDAlternate) && !PatternNews && PotencialsLevels_retXD<2)
        {
         AB=MathAbs(AB);
         CD=MathAbs(CD);
         int iABCD=2;
         if (ABCD>0)
           {
            if (ABCD==2) for (iABCD=2;iABCD<17;iABCD++) {if (retAC>deltapatterns[2,iABCD,0] && retAC<deltapatterns[2,iABCD,1]) break;}
            if (ABCD==1 || (ABCD==2 && iABCD<17))
              {
               if (CD>AB*min_DeltaGartley && CD<AB*max_DeltaGartley)
                 {
                  txt=" [";
                  if (ret[2,0]<0) txt=StringConcatenate(txt,"*");
                  else txt=StringConcatenate(txt,retpatternstxt[ret[2,0]]);
                  txt=StringConcatenate(txt,"/");
                  if (ret[2,0]<0) txt=StringConcatenate(txt,"*]");
                  else txt=StringConcatenate(txt,retpatternstxt[ret[3,0]],"]");
                  vNamePattern=StringConcatenate(vABCD,txt); 
                  countDots=4;
                  PatternNews=true;
                 }
              }
           }

         if (searchABCDAlternate && !PatternNews)
           {
            for (iABCD=0;iABCD<_ABCDsize;iABCD++)
              {
               if (CD>_ABCDtype[iABCD]*AB*min_DeltaGartley && CD<_ABCDtype[iABCD]*AB*max_DeltaGartley)
                 {
                  txt=" [";
                  if (ret[2,0]<0) txt=StringConcatenate(txt,"*");
                  else txt=StringConcatenate(txt,retpatternstxt[ret[2,0]]);
                  txt=StringConcatenate(txt,"/");
                  if (ret[2,0]<0) txt=StringConcatenate(txt,"*]");
                  else txt=StringConcatenate(txt,retpatternstxt[ret[3,0]],"]");
                  vNamePattern=StringConcatenate(_ABCDtypetxt[iABCD],"*",vABCD,txt);
                  countDots=4;
                  PatternNews=true;
                  break;
                 }
              }
           }

         if (PatternNews)
           {
            // рассчитываем зону развития точки D паттерна
            LevelForDmin = 0;
            LevelForDmax = 0;
            if (RangeForPointD || patternTrue)
              {
               if (StringFind(vNamePattern,vABCD,0)>-1)
                 {
                  if (vBullBear==vBull)
                    {
                     LevelForDmin = zz[aXABCD[C]]-AB*max_DeltaGartley;
                     LevelForDmax = zz[aXABCD[C]]-AB*min_DeltaGartley;
                    }
                  else
                    {
                     LevelForDmin = zz[aXABCD[C]]+AB*min_DeltaGartley;
                     LevelForDmax = zz[aXABCD[C]]+AB*max_DeltaGartley;
                    }
                 }
               else
                 {
                  if (vBullBear==vBull)
                    {
                     LevelForDmin = zz[aXABCD[C]]-_ABCDtype[iABCD]*AB*max_DeltaGartley;
                     LevelForDmax = zz[aXABCD[C]]-_ABCDtype[iABCD]*AB*min_DeltaGartley;
                    }
                  else
                    {
                     LevelForDmin = zz[aXABCD[C]]+_ABCDtype[iABCD]*AB*min_DeltaGartley;
                     LevelForDmax = zz[aXABCD[C]]+_ABCDtype[iABCD]*AB*max_DeltaGartley;
                    }
                 }

               // фильтрация паттернов
               PatternNews=filtrpatterns_1(k, aXABCD[D], vBull, aNumBarPeak, LevelForDmin, LevelForDmax);
              }
           }
        }

      if (CustomPattern<2 && countRet==4 && Ext_noname && ((filtrXB_ && filtrEquilibrium) || !filtrEquilibrium))
        {
         if (!PatternNews)
           {
            vNamePattern=StringConcatenate("noname [",retpatternstxt[ret[0,0]],"/",retpatternstxt[ret[1,0]],"/",retpatternstxt[ret[2,0]],"/",retpatternstxt[ret[3,0]],"]");
            countDots=5;

            // рассчитываем зону развития точки D паттерна
            if (RangeForPointD || patternTrue)
              {
               vlXD = deltapatterns[ret[0,1],ret[0,0],0]; vhXD = deltapatterns[ret[0,1],ret[0,0],1];

               LevelForDmin = 0;
               LevelForDmax = 0;
               if (retAC<1)
                 {
                  if (vBullBear==vBull)
                    {
                     LevelForDmin = zz[aXABCD[A]]+XA*vhXD;
                     LevelForDmax = zz[aXABCD[A]]+XA*vlXD;
                    }
                  else
                    {
                     LevelForDmin = zz[aXABCD[A]]+XA*vlXD;
                     LevelForDmax = zz[aXABCD[A]]+XA*vhXD;
                    }
                 }
               else
                 {
                  if (vBullBear==vBull)
                    {
                     LevelForDmin = zz[aXABCD[C]]+XC*vhXD;
                     LevelForDmax = zz[aXABCD[C]]+XC*vlXD;
                    }
                  else
                    {
                     LevelForDmin = zz[aXABCD[C]]+XC*vlXD;
                     LevelForDmax = zz[aXABCD[C]]+XC*vhXD;
                    }
                 }

               // фильтрация паттернов
               PatternNews=filtrpatterns_1(k, aXABCD[D], vBull, aNumBarPeak, LevelForDmin, LevelForDmax);
              }
           }
        }

      if (levelD && iu>0 && PotencialsLevels_retXD>0) // вывод на график потенциальных уровней точки D для пятиточечных паттернов из списка кроме 5-0
        {
         double fiboX, pointC=0, minVL=zz[aXABCD[C]], maxVL=zz[aXABCD[C]];
         int ii;
         nameObj=StringConcatenate("_",ExtComplekt,"StrongPattern_",k);
         pointC=zz[aXABCD[C]];

         if (vBullBear==vBull)
           {
            for(ii=0;ii<=iu;ii++) if (level_D[ii]<minVL) minVL=level_D[ii];
           }
         else
           {
            for(ii=0;ii<=iu;ii++) if (level_D[ii]>maxVL) maxVL=level_D[ii];
           }

         if (vBullBear==vBull) baza=minVL-maxVL; else baza=maxVL-minVL;
         if (vBullBear==vBull) ObjectCreate(nameObj,OBJ_FIBO,0,Time[aXABCD[C]],minVL,Time[aXABCD[C]],maxVL);
         else ObjectCreate(nameObj,OBJ_FIBO,0,Time[aXABCD[C]],maxVL,Time[aXABCD[C]],minVL);

         ObjectSet(nameObj,OBJPROP_FIBOLEVELS,iu+1);

         for(ii=0;ii<=iu;ii++)
           {
            fiboX=(level_D[ii]-pointC)/baza;
            ObjectSet(nameObj,OBJPROP_FIRSTLEVEL+ii,fiboX);
            ObjectSetFiboDescription(nameObj, ii, level_nameD[ii] + "  %$");
           }
         ObjectSet(nameObj,OBJPROP_LEVELCOLOR,colorLevelD);
         ObjectSet(nameObj,OBJPROP_COLOR,colorLevelD);
         ObjectSet(nameObj,OBJPROP_LEVELWIDTH,0);
         ObjectSet(nameObj,OBJPROP_LEVELSTYLE,2);
         ObjectSet(nameObj,OBJPROP_BACK,ExtBack);
         ObjectSet(nameObj,OBJPROP_RAY,false);
        }

      if (StringLen(vNamePattern)>0 && (aXABCD[D] < bartoD+2 || patternInfluence==2))
        {
         if (LevelForDmin>LevelForDmax)
           {
            LevelForD=LevelForDmin;
            LevelForDmin=LevelForDmax;
            LevelForDmax=LevelForD;
           }

         if (ExtGartleyTypeSearch>0 && ExtIndicator==11)
           {
            for (m=0;m<=countGartley;m++) // проверка на появление нового паттерна
              {
               if (vNamePattern==v4Point || StringFind(vNamePattern,vABCD,0)>-1)
                 {
                  if (PeakCenaX[m]==0 && PeakCenaA[m]==zz[aXABCD[A]] && PeakCenaB[m]==zz[aXABCD[B]] && PeakCenaC[m]==zz[aXABCD[C]] && PeakCenaD[m]==zz[aXABCD[D]])
                    {
                     if (PeakTimeX[m]==0 && PeakTimeA[m]==Time[aXABCD[A]] && PeakTimeB[m]==Time[aXABCD[B]] && PeakTimeC[m]==Time[aXABCD[C]] && PeakTimeD[m]==Time[aXABCD[D]]) {k++; break;}
                    }
                 }
               else if (vNamePattern==vDragon)
                 {
                  if (PeakCenaX[m]==zz[aXABCD[X]] && PeakCenaA[m]==zz[aXABCD[A]] && PeakCenaB[m]==zz[aXABCD[B]] && PeakCenaC[m]==zz[aXABCD[C]] && PeakCenaD[m]==0)
                    {
                     if (PeakTimeX[m]==Time[aXABCD[X]] && PeakTimeA[m]==Time[aXABCD[A]] && PeakTimeB[m]==Time[aXABCD[B]] && PeakTimeC[m]==Time[aXABCD[C]] && PeakTimeD[m]==0) {k++; break;}
                    }
                 }
               else
                 {
                  if (PeakCenaX[m]==zz[aXABCD[X]] && PeakCenaA[m]==zz[aXABCD[A]] && PeakCenaB[m]==zz[aXABCD[B]] && PeakCenaC[m]==zz[aXABCD[C]] && PeakCenaD[m]==zz[aXABCD[D]])
                    {
                     if (PeakTimeX[m]==Time[aXABCD[X]] && PeakTimeA[m]==Time[aXABCD[A]] && PeakTimeB[m]==Time[aXABCD[B]] && PeakTimeC[m]==Time[aXABCD[C]] && PeakTimeD[m]==Time[aXABCD[D]]) {k++; break;}
                    }
                 }
              }

            if (m<=countGartley)
              {
               continue;
              }

            if (ArraySize(PeakCenaX)<countGartley+1)
              {
               ArrayResize(PeakCenaX,countGartley+1);
               ArrayResize(PeakCenaA,countGartley+1);
               ArrayResize(PeakCenaB,countGartley+1);
               ArrayResize(PeakCenaC,countGartley+1);
               ArrayResize(PeakCenaD,countGartley+1);
               
               ArrayResize(PeakTimeX,countGartley+1);
               ArrayResize(PeakTimeA,countGartley+1);
               ArrayResize(PeakTimeB,countGartley+1);
               ArrayResize(PeakTimeC,countGartley+1);
               ArrayResize(PeakTimeD,countGartley+1);

               ArrayResize(__NamePatterns,countGartley+1);
               ArrayResize(__D,countGartley+1);
               ArrayResize(__PatColor,countGartley+1);
              }

            // запись координат нового паттерна в массивы
            if (vNamePattern==v4Point || StringFind(vNamePattern,vABCD,0)>-1)
              {
               PeakCenaX[countGartley]=0;
               PeakTimeX[countGartley]=0;
               PeakCenaD[countGartley]=zz[aXABCD[D]];
               PeakTimeD[countGartley]=Time[aXABCD[D]];
              }
            else if (vNamePattern==vDragon)
              {
               PeakCenaX[countGartley]=zz[aXABCD[X]];
               PeakTimeX[countGartley]=Time[aXABCD[X]];
               PeakCenaD[countGartley]=0;
               PeakTimeD[countGartley]=0;
              }
            else
              {
               PeakCenaX[countGartley]=zz[aXABCD[X]];
               PeakTimeX[countGartley]=Time[aXABCD[X]];
               PeakCenaD[countGartley]=zz[aXABCD[D]];
               PeakTimeD[countGartley]=Time[aXABCD[D]];
              }

            PeakCenaA[countGartley]=zz[aXABCD[A]];
            PeakCenaB[countGartley]=zz[aXABCD[B]];
            PeakCenaC[countGartley]=zz[aXABCD[C]];

            PeakTimeA[countGartley]=Time[aXABCD[A]];
            PeakTimeB[countGartley]=Time[aXABCD[B]];
            PeakTimeC[countGartley]=Time[aXABCD[C]];

            if (vNamePattern==vDragon) {if (vBullBear==vBull) vBullBear=vBear; else vBullBear=vBull;}
            __NamePatterns[countGartley][0]=vBullBear + " " + vNamePattern;
            
            // XD-XB-AC-BD
            if (StringFind(vNamePattern,vABCD,0)>=0) __NamePatterns[countGartley][1]=StringConcatenate("----","-",ret[2,1],"-",ret[3,1]);
            else if (StringFind(vNamePattern,vDragon,0)>=0) __NamePatterns[countGartley][1]=StringConcatenate("---",ret[1,1],"-",ret[2,1],"--");
//            else if (vNamePattern==v4Point) __NamePatterns[countGartley][1]=StringConcatenate(ret[0,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
            else if (StringFind(vNamePattern,v3Drives,0)>=0)
              {
               if (countDots==5) __NamePatterns[countGartley][1]=StringConcatenate("--",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
//               else if (countDots==6) __NamePatterns[countGartley][1]=StringConcatenate(ret[4,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
               else __NamePatterns[countGartley][1]=StringConcatenate(ret[4,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
              }
            else __NamePatterns[countGartley][1]=StringConcatenate(ret[0,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);

            if (StringFind(vNamePattern,vDragon,0)>=0) __D[countGartley][0]=iBarShift(NULL,Period(),tDragonE,false);
            else __D[countGartley][0]=aXABCD[D];
            if (AlgorithmSearchPatterns==0) // стандартный зигзаг
              {
               __D[countGartley][1]=Depth; // Depth
               if (noBackstep) __D[countGartley][2]=0;
               else __D[countGartley][2]=StrToInteger(StringSubstr(_Depth,StringFind(_Depth,"/",0)+1)); // Backstep
              }
            else if (AlgorithmSearchPatterns==1) // зигзаг Алекса, изменяется размер луча в пунктах
              {
               __D[countGartley][1]=StrToInteger(StringSubstr(_Depth,16,StringFind(_Depth,"/",0)-15)); // Size
               __D[countGartley][2]=0;
              }
            else if (AlgorithmSearchPatterns==2) // зигзаг Алекса, изменяется размер луча в процентах "ExtIndicator=11_",vSize,"/",vPercent
              {
               __D[countGartley][1]=MathRound(StrToDouble(StringSubstr(_Depth,StringFind(_Depth,"/",0)+1))*100); // Percent*100
               __D[countGartley][2]=0;
              }
            else if (AlgorithmSearchPatterns==3) // зигзаг Ensign, изменяется размер луча в пунктах
              {
               __D[countGartley][1]=StrToInteger(StringSubstr(_Depth,StringFind(_Depth,"/",0)+1)); // Size
               __D[countGartley][2]=0;
              }
            else if (AlgorithmSearchPatterns==4) // зигзаг tauber
              {
               __D[countGartley][1]=0; //
               __D[countGartley][2]=0;
              }
            else if (AlgorithmSearchPatterns==5) // зигзаг свинги Ганна
              {
               __D[countGartley][1]=StrToInteger(StringSubstr(_Depth,16)); // Bars
               __D[countGartley][2]=0;
              }
            else if (AlgorithmSearchPatterns==6) // зигзаг Talex
              {
               __D[countGartley][1]=StrToInteger(StringSubstr(_Depth,16)); // Bars
               __D[countGartley][2]=0;
              }

           __D[countGartley][3]=countGartley;

            if (NumberPattern-1==countGartley)
              {
               saveParametersZZ=true;

               LevelForDminToNumberPattern=LevelForDmin;
               LevelForDmaxToNumberPattern=LevelForDmax;

               vBullBearToNumberPattern = vBullBear;
               vNamePatternToNumberPattern = vNamePattern;
              }

            if (countColor==ColorSize) countColor=0;  // "перезаряжаем" счетчик цветов
            colorPattern=ColorList[countColor];

            __PatColor[countGartley]=colorPattern;

            countColor++;
            countGartley++;
           }
         else
           {
            saveParametersZZ=true;

            colorPattern=ExtColorPatterns;

            LevelForDminToNumberPattern=LevelForDmin;
            LevelForDmaxToNumberPattern=LevelForDmax;

            if (vNamePattern==vDragon) {if (vBullBear==vBull) vBullBear=vBear; else vBullBear=vBull;}
            vBullBearToNumberPattern = vBullBear;
            vNamePatternToNumberPattern = vNamePattern;

            if (picture || writeInfoPatternsToFileXML>0 || writeInfoPatternsToFileCSV>0)
              {
               m=0;
               if (vNamePattern==v4Point || StringFind(vNamePattern,vABCD,0)>-1)
                 {
                  if (PeakCenaX[m]==0 && PeakCenaA[m]==zz[aXABCD[A]] && PeakCenaB[m]==zz[aXABCD[B]] && PeakCenaC[m]==zz[aXABCD[C]] && PeakCenaD[m]==zz[aXABCD[D]])
                    {
                     if (PeakTimeX[m]==0 && PeakTimeA[m]==Time[aXABCD[A]] && PeakTimeB[m]==Time[aXABCD[B]] && PeakTimeC[m]==Time[aXABCD[C]] && PeakTimeD[m]==Time[aXABCD[D]]) m=1;
                    }
                 }
               else if (vNamePattern==vDragon)
                 {
                  if (PeakCenaX[m]==zz[aXABCD[X]] && PeakCenaA[m]==zz[aXABCD[A]] && PeakCenaB[m]==zz[aXABCD[B]] && PeakCenaC[m]==zz[aXABCD[C]] && PeakCenaD[m]==0)
                    {
                     if (PeakTimeX[m]==Time[aXABCD[X]] && PeakTimeA[m]==Time[aXABCD[A]] && PeakTimeB[m]==Time[aXABCD[B]] && PeakTimeC[m]==Time[aXABCD[C]] && PeakTimeD[m]==0) m=1;
                    }
                 }
               else
                 {
                  if (PeakCenaX[m]==zz[aXABCD[X]] && PeakCenaA[m]==zz[aXABCD[A]] && PeakCenaB[m]==zz[aXABCD[B]] && PeakCenaC[m]==zz[aXABCD[C]] && PeakCenaD[m]==zz[aXABCD[D]])
                    {
                     if (PeakTimeX[m]==Time[aXABCD[X]] && PeakTimeA[m]==Time[aXABCD[A]] && PeakTimeB[m]==Time[aXABCD[B]] && PeakTimeC[m]==Time[aXABCD[C]] && PeakTimeD[m]==Time[aXABCD[D]]) m=1;
                    }
                 }
              }

            if (m==1)
              {
               if (StringFind(vNamePattern,vDragon,0)>=0) __D[0][0]=iBarShift(NULL,Period(),tDragonE,false);
               else __D[0][0]=aXABCD[D];
              }

            // запись координат нового паттерна в массивы
            if(m==0)
              {
               if (vNamePattern==v4Point || StringFind(vNamePattern,vABCD,0)>-1)
                 {
                  PeakCenaX[0]=0;
                  PeakTimeX[0]=0;
                  PeakCenaD[0]=zz[aXABCD[D]];
                  PeakTimeD[0]=Time[aXABCD[D]];
                 }
               else if (vNamePattern==vDragon)
                 {
                  PeakCenaX[0]=zz[aXABCD[X]];
                  PeakTimeX[0]=Time[aXABCD[X]];
                  PeakCenaD[0]=0;
                  PeakTimeD[0]=0;
                 }
               else
                 {
                  PeakCenaX[0]=zz[aXABCD[X]];
                  PeakTimeX[0]=Time[aXABCD[X]];
                  PeakCenaD[0]=zz[aXABCD[D]];
                  PeakTimeD[0]=Time[aXABCD[D]];
                 }

               PeakCenaA[0]=zz[aXABCD[A]];
               PeakCenaB[0]=zz[aXABCD[B]];
               PeakCenaC[0]=zz[aXABCD[C]];

               PeakTimeA[0]=Time[aXABCD[A]];
               PeakTimeB[0]=Time[aXABCD[B]];
               PeakTimeC[0]=Time[aXABCD[C]];

               __NamePatterns[0][0]=StringConcatenate(vBullBear," ",vNamePattern);

               // XD-XB-AC-BD
               if (StringFind(vNamePattern,vABCD,0)>=0) __NamePatterns[0][1]=StringConcatenate("----","-",ret[2,1],"-",ret[3,1]);
               else if (StringFind(vNamePattern,vDragon,0)>=0) __NamePatterns[0][1]=StringConcatenate("---",ret[1,1],"-",ret[2,1],"--");
//            else if (vNamePattern==v4Point) __NamePatterns[0][1]=StringConcatenate(ret[0,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
               else if (StringFind(vNamePattern,v3Drives,0)>=0)
                 {
                  if (countDots==5) __NamePatterns[0][1]=StringConcatenate("--",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
//                  else if (countDots==6) __NamePatterns[0][1]=StringConcatenate(ret[4,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
                  else __NamePatterns[0][1]=StringConcatenate(ret[4,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);
                 }
               else __NamePatterns[0][1]=StringConcatenate(ret[0,1],"-",ret[1,1],"-",ret[2,1],"-",ret[3,1]);

               if (StringFind(vNamePattern,vDragon,0)>=0) __D[0][0]=iBarShift(NULL,Period(),tDragonE,false);
               else __D[0][0]=aXABCD[D];

               if (AlgorithmSearchPatterns==0) // стандартный зигзаг
                 {
                  __D[0][1]=Depth; // Depth
                  if (noBackstep) __D[0][2]=0;
                  else __D[0][2]=StrToInteger(StringSubstr(_Depth,StringFind(_Depth,"/",0)+1)); // Backstep
                 }
               else if (AlgorithmSearchPatterns==1) // зигзаг Алекса, изменяется размер луча в пунктах
                 {
                  __D[0][1]=StrToInteger(StringSubstr(_Depth,16,StringFind(_Depth,"/",0)-15)); // Size
                  __D[0][2]=0;
                 }
               else if (AlgorithmSearchPatterns==2) // зигзаг Алекса, изменяется размер луча в процентах
                 {
                  __D[0][1]=MathRound(StrToDouble(StringSubstr(_Depth,StringFind(_Depth,"/",0)+1))*100); // Percent*100
                  __D[0][2]=0;
                 }
               else if (AlgorithmSearchPatterns==3) // зигзаг Ensign, изменяется размер луча в пунктах
                 {
                  __D[0][1]=StrToInteger(StringSubstr(_Depth,StringFind(_Depth,"/",0)+1)); // Size
                  __D[0][2]=0;
                 }
               else if (AlgorithmSearchPatterns==4) // зигзаг tauber
                 {
                  __D[0][1]=0; //
                  __D[0][2]=0;
                 }
               else if (AlgorithmSearchPatterns==5) // зигзаг свинги Ганна
                 {
                  __D[0][1]=StrToInteger(StringSubstr(_Depth,16)); // Bars
                  __D[0][2]=0;
                 }
               else if (AlgorithmSearchPatterns==6) // зигзаг Talex
                 {
                  __D[0][1]=StrToInteger(StringSubstr(_Depth,16)); // Bars
                  __D[0][2]=0;
                 }

               __D[0][3]=0;

               __PatColor[0]=ExtColorPatterns;

               vWriteToFilePattern=true; vpicture=true;
              }
            countGartley=1;
           }

         if (Equilibrium && ExtGartleyTypeSearch==0 && !v50 && StringFind(vNamePattern,vABCD,0)==-1 && vNamePattern!=v4Point && StringFind(vNamePattern,v3Drives,0)==-1)
           {
            double tangens, h_ea=0, h_ec=0, delta;

            tangens=(zz[aXABCD[B]]-zz[aXABCD[X]])/(aXABCD[X]-aXABCD[B]);
            if (ReactionType)
              {
               h_ea=zz[aXABCD[A]]-(zz[aXABCD[X]]+(aXABCD[X]-aXABCD[A])*tangens);
               h_ec=zz[aXABCD[C]]-(zz[aXABCD[B]]+(aXABCD[B]-aXABCD[C])*tangens);
              }
            else
              {
               if (zz[aXABCD[X]]>zz[aXABCD[A]])
                 {
                  for (i=aXABCD[X]-1;i>=aXABCD[A];i--)
                    {
                     delta=Low[i]-(zz[aXABCD[X]]+(aXABCD[X]-i)*tangens);
                     if (delta<h_ea) h_ea=delta;
                    }

                  for (i=aXABCD[B]-1;i>=aXABCD[C];i--)
                    {
                     delta=Low[i]-(zz[aXABCD[B]]+(aXABCD[B]-i)*tangens);
                     if (delta<h_ec) h_ec=delta;
                    }
                 }
               else
                 {
                  for (i=aXABCD[X]-1;i>=aXABCD[A];i--)
                    {
                     delta=High[i]-(zz[aXABCD[X]]+(aXABCD[X]-i)*tangens);
                     if (delta>h_ea) h_ea=delta;
                    }

                  for (i=aXABCD[B]-1;i>=aXABCD[C];i--)
                    {
                     delta=High[i]-(zz[aXABCD[B]]+(aXABCD[B]-i)*tangens);
                     if (delta>h_ec) h_ec=delta;
                    }
                 }
              }

            nameObj=StringConcatenate("_",ExtComplekt,"Equilibrium_",countGartley);
            ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[X]],zz[aXABCD[X]],Time[aXABCD[B]],zz[aXABCD[B]]);
            ObjectSet(nameObj,OBJPROP_COLOR,ColorEquilibrium);
            ObjectSet(nameObj,OBJPROP_STYLE,EquilibriumStyle);
            ObjectSet(nameObj,OBJPROP_WIDTH,EquilibriumWidth);
            nameObj=StringConcatenate("_",ExtComplekt,"Reaction1_",countGartley);
            ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[C]],zz[aXABCD[B]]+tangens*(aXABCD[B]-aXABCD[C])-h_ec,Time[0],zz[aXABCD[B]]+tangens*aXABCD[B]-h_ec);
            ObjectSet(nameObj,OBJPROP_COLOR,ColorReaction);
            ObjectSet(nameObj,OBJPROP_STYLE,EquilibriumStyle);
            ObjectSet(nameObj,OBJPROP_WIDTH,EquilibriumWidth);
            nameObj=StringConcatenate("_",ExtComplekt,"Reaction2_",countGartley);
            ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[C]],zz[aXABCD[B]]+tangens*(aXABCD[B]-aXABCD[C])-h_ea,Time[0],zz[aXABCD[B]]+tangens*aXABCD[B]-h_ea);
            ObjectSet(nameObj,OBJPROP_COLOR,ColorReaction);
            ObjectSet(nameObj,OBJPROP_STYLE,EquilibriumStyle);
            ObjectSet(nameObj,OBJPROP_WIDTH,EquilibriumWidth);
           }

         vPatOnOff = true;

         //---------------------------------------------
         if(f==1 && ExtIndicator!=11)
           {
            f=0;
            if(ExtPlayAlert) 
              {
             Alert (Symbol() + " " + Period() + " pattern " + vBullBear + " " + vNamePattern + " " );// новый алерт тут (1)
               PlaySound("alert.wav");
              }
            if (ExtSendMail) _SendMail("There was a pattern",StringConcatenate("on  ",Symbol()," ",Period()," pattern ",vBullBear," ",vNamePattern));
           }
         //---------------------------------------------

         // Вывод паттернов
         if (StringLen(vNamePattern)>0)
           {
            if (visibleABCDrayZZ && StringFind(vNamePattern,vABCD,0)>-1)
              {
               nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"ABCDzz1_",countGartley,"_",_Depth ,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
               ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[A]],zz[aXABCD[A]],Time[aXABCD[B]],zz[aXABCD[B]]);
               ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
               ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
               ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
               ObjectSet(nameObj,OBJPROP_RAY, false); 
               nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"ABCDzz2_",countGartley,"_", _Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
               ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[C]],zz[aXABCD[C]]);
               ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
               ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
               ObjectSet(nameObj,OBJPROP_RAY, false); 
               ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
               nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"ABCDzz3_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
               ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[C]],zz[aXABCD[C]],Time[aXABCD[D]],zz[aXABCD[D]]);
               ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
               ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
               ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
               ObjectSet(nameObj,OBJPROP_RAY, false); 
              }
            else
              {
               if (StringFind(vNamePattern,v3Drives,0)>=0)
                 {
                  nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line1_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                  ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[C]],zz[aXABCD[C]],Time[aXABCD[D]],zz[aXABCD[D]]);
                  ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                  ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                  ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                  ObjectSet(nameObj,OBJPROP_RAY, false); 
                  nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line2_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                  ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[C]],zz[aXABCD[C]]);
                  ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                  ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                  ObjectSet(nameObj,OBJPROP_RAY, false); 
                  ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                  nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line3_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                  ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[A]],zz[aXABCD[A]],Time[aXABCD[B]],zz[aXABCD[B]]);
                  ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                  ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                  ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                  ObjectSet(nameObj,OBJPROP_RAY, false); 
                  nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line4_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                  ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[X]],zz[aXABCD[X]],Time[aXABCD[A]],zz[aXABCD[A]]);
                  ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                  ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                  ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                  ObjectSet(nameObj,OBJPROP_RAY, false); 
                  if (countDots==6)
                    {
                     nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line5_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                     ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[O]],zz[aXABCD[O]],Time[aXABCD[X]],zz[aXABCD[X]]);
                     ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                     ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                     ObjectSet(nameObj,OBJPROP_RAY, false); 
                     ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                    }

                  if (countDots==7)
                    {
                     if (vBullBear==vBull)
                       {
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line5_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[arr3Dr[0]],zz[arr3Dr[0]],Time[aXABCD[X]],zz[aXABCD[X]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line6_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[arr3Dr[1]],zz[arr3Dr[1]],Time[arr3Dr[0]],zz[arr3Dr[0]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line7_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[arr3Dr[1]],zz[arr3Dr[1]],Time[aXABCD[D]],zz[aXABCD[D]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                       }
                     else
                       {
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line5_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[arr3Dr[1]],zz[arr3Dr[1]],Time[aXABCD[X]],zz[aXABCD[X]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line6_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[arr3Dr[0]],zz[arr3Dr[0]],Time[arr3Dr[1]],zz[arr3Dr[1]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line7_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[arr3Dr[0]],zz[arr3Dr[0]],Time[aXABCD[D]],zz[aXABCD[D]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                       }
                    }
                 }
               else
                 {
                  if (visibleLineOrTriangle && StringFind(vNamePattern,vABCD,0)<0)
                    {
                     nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line1_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                     ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[X]],zz[aXABCD[X]],Time[aXABCD[A]],zz[aXABCD[A]]);
                     ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                     ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                     ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                     ObjectSet(nameObj,OBJPROP_RAY, false); 
                     nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line2_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                     ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[A]],zz[aXABCD[A]],Time[aXABCD[B]],zz[aXABCD[B]]);
                     ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                     ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                     ObjectSet(nameObj,OBJPROP_RAY, false); 
                     ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                     if (vNamePattern==v4Point)
                       {
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line3_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[A]],zz[aXABCD[A]],Time[aXABCD[C]],zz[aXABCD[C]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                       }
                     else
                       {
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line3_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[X]],zz[aXABCD[X]],Time[aXABCD[B]],zz[aXABCD[B]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                       }
                     nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line4_",countGartley,"_",_Depth,"_",aXABCD[D], "_",vBullBear," ",vNamePattern),0,63);
                     ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[C]],zz[aXABCD[C]]);
                     ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                     ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                     ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                     ObjectSet(nameObj,OBJPROP_RAY, false); 
                     if (vNamePattern==vDragon)
                       {
                        if (tDragonE>0)
                          {
                           nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line5_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                           ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[C]],zz[aXABCD[C]],tDragonE,cDragonE);
                           ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                           ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                           ObjectSet(nameObj,OBJPROP_RAY, false); 
                           ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                           nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line6_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                           ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[B]],zz[aXABCD[B]],tDragonE,cDragonE);
                           ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                           ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                           ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                           ObjectSet(nameObj,OBJPROP_RAY, false);
                          }
                       }
                     else
                       {
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line5_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[C]],zz[aXABCD[C]],Time[aXABCD[D]],zz[aXABCD[D]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_RAY, false); 
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        nameObj=StringSubstr(StringConcatenate("_",ExtComplekt,"Line6_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                        ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[D]],zz[aXABCD[D]]);
                        ObjectSet(nameObj,OBJPROP_COLOR,colorPattern);
                        ObjectSet(nameObj,OBJPROP_STYLE,PatternLineStyle);
                        ObjectSet(nameObj,OBJPROP_WIDTH,PatternLineWidth);
                        ObjectSet(nameObj,OBJPROP_RAY, false);
                       }
                    }
                  else
                    {
                     nameObj1=StringSubstr(StringConcatenate("_",ExtComplekt,"Triangle1_",countGartley,"_",_Depth,"_",aXABCD[D],"_",vBullBear," ",vNamePattern),0,63);
                     nameObj2=StringSubstr(StringConcatenate("_",ExtComplekt,"Triangle2_",countGartley,"_",_Depth,"_",aXABCD[D],"_", vBullBear," ",vNamePattern),0,63);

                     if (vNamePattern == v4Point || StringFind(vNamePattern,vABCD,0)>-1)
                       {
                        ObjectCreate(nameObj1,OBJ_TRIANGLE,0,Time[aXABCD[A]],zz[aXABCD[A]],Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[C]],zz[aXABCD[C]]);
                       }
                     else
                       {
                        ObjectCreate(nameObj1,OBJ_TRIANGLE,0,Time[aXABCD[X]],zz[aXABCD[X]],Time[aXABCD[A]],zz[aXABCD[A]],Time[aXABCD[B]],zz[aXABCD[B]]);
                       }
                     ObjectSet(nameObj1,OBJPROP_COLOR,colorPattern);

                     if (vNamePattern==vDragon)
                       {
                        ObjectCreate(nameObj2,OBJ_TRIANGLE,0,Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[C]],zz[aXABCD[C]],tDragonE,cDragonE);
                       }
                     else
                       {
                        ObjectCreate(nameObj2,OBJ_TRIANGLE,0,Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[C]],zz[aXABCD[C]],Time[aXABCD[D]],zz[aXABCD[D]]);
                       }
                     ObjectSet(nameObj2,OBJPROP_COLOR,colorPattern);
                    }
                 }

              }
           }

         // определение информации точки D для вывода крупным шрифтом для Николая
         if (ExtGartleyTypeSearch==0)
           {
            if (InfoPointD)
              {
               if (vNamePattern==vDragon)
                 {
                  txt = TimeToStr(tDragonE,TIME_DATE|TIME_MINUTES);
                  _InfoPointD = StringConcatenate("[",iBarShift(NULL, Period(),tDragonE, false),"] ",StringSubstr(txt,8,2),".",StringSubstr(txt,5,2),".",StringSubstr(txt,0,4)," ",StringSubstr(txt,10));
                 }
               else
                 {
                  txt = TimeToStr(Time[aXABCD[D]],TIME_DATE|TIME_MINUTES);
                  _InfoPointD = StringConcatenate("[",aXABCD[D],"] ",StringSubstr(txt,8,2),".",StringSubstr(txt,5,2),".",StringSubstr(txt,0,4)," ",StringSubstr(txt,10));
                 }
              }
            else
              {
               _InfoPointD = "";
              }
           }

         // Вывод прямоугольника для зоны точки D
         if (RangeForPointD && LevelForDmin>0)
           {
            // инициализация переменных для расчета рамки развития точки D паттерна
            TimeForDmin = 0;
            TimeForDmax = 0;

            for (j=aXABCD[C]-1;j>=aXABCD[D];j--)
              {
               if (vBullBear == vBull)
                 {
                  if (LevelForDmax>=Low[j])
                    {
                     if (TimeForDmax==0) TimeForDmax = Time[j];
                    }
                  else
                    {
                     TimeForDmax=0;
                    }
                 }
               else if (vBullBear == vBear)
                 {
                  if (LevelForDmin<=High[j])
                    {
                     if (TimeForDmin==0) TimeForDmin = Time[j];
                    }
                  else
                    {
                     TimeForDmin=0;
                    }
                 }
              }

            int jj;
            if (vBullBear == vBull)
              {
               j=iBarShift(NULL,Period(),TimeForDmax,true);
               jj=MathRound((LevelForDmax-LevelForDmin)/((zz[aXABCD[C]]-zz[aXABCD[D]])/(aXABCD[C]-aXABCD[D])));
               if (j-jj>=0) TimeForDmin = Time[j-jj]; else TimeForDmin = TimeForDmax+jj*Period()*60;
              }
            else if (vBullBear == vBear)
              {
               j=iBarShift(NULL,Period(),TimeForDmin,true);
               jj=MathRound((LevelForDmax-LevelForDmin)/((zz[aXABCD[D]]-zz[aXABCD[C]])/(aXABCD[C]-aXABCD[D])));
               if (j-jj>=0) TimeForDmax = Time[j-jj]; else TimeForDmax = TimeForDmin+jj*Period()*60;
              }

            if (TimeForDmin>TimeForDmax)
              {
               timeLineD=TimeForDmin;
               TimeForDmin=TimeForDmax;
               TimeForDmax=timeLineD;
              }

           if (vNamePattern==vDragon)
             {
               TimeForDmin=tDragonE;
               TimeForDmax=tDragonE;
             }

            if (VectorOfAMirrorTrend==1)
              {
               nameObj=StringConcatenate("_",ExtComplekt,"VectorOfAMirrorTrend_1_",countGartley);

               if (vBullBear == vBear) ObjectCreate(nameObj,OBJ_TREND,0,TimeForDmin,LevelForDmin,TimeForDmax,LevelForDmax);
               else  ObjectCreate(nameObj,OBJ_TREND,0,TimeForDmin,LevelForDmax,TimeForDmax,LevelForDmin);
                 
               ObjectSet(nameObj, OBJPROP_BACK, false);
               ObjectSet(nameObj, OBJPROP_RAY, true); 
               ObjectSet(nameObj, OBJPROP_COLOR, VectorOfAMirrorTrendColor); 
               ObjectSet(nameObj, OBJPROP_STYLE, VectorOfAMirrorTrendStyle); 
              }
            else if (VectorOfAMirrorTrend==2)
              {
               nameObj=StringConcatenate("_",ExtComplekt,"VectorOfAMirrorTrend_2_",countGartley);

               if (vBullBear == vBear) ObjectCreate(nameObj,OBJ_TREND,0,TimeForDmin,LevelForDmax,TimeForDmax,LevelForDmin);
               else  ObjectCreate(nameObj,OBJ_TREND,0,TimeForDmin,LevelForDmin,TimeForDmax,LevelForDmax);
                 
               ObjectSet(nameObj, OBJPROP_BACK, false);
               ObjectSet(nameObj, OBJPROP_RAY, true); 
               ObjectSet(nameObj, OBJPROP_COLOR, VectorOfAMirrorTrendColor); 
               ObjectSet(nameObj, OBJPROP_STYLE, VectorOfAMirrorTrendStyle); 
              }

            nameObj=StringConcatenate("_",ExtComplekt,"PointD_",countGartley);
            ObjectCreate(nameObj,OBJ_RECTANGLE,0,TimeForDmin,LevelForDmin,TimeForDmax,LevelForDmax);
            ObjectSet(nameObj, OBJPROP_BACK, false);
            ObjectSet(nameObj, OBJPROP_COLOR, ExtColorRangeForPointD); 

            if (ExtIndicator==11 && ExtHiddenPP==2)
              {
               k1=MathCeil((aXABCD[X]+aXABCD[B])/2);
               nameObj=StringConcatenate("_",ExtComplekt,"pgtxt",Time[aXABCD[B]],"_",Time[aXABCD[X]]);
               ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(zz[aXABCD[B]]+zz[aXABCD[X]])/2);
               ObjectSetText(nameObj,DoubleToStr(retXB,3),ExtSizeTxt,"Arial", ExtNotFibo);
               nameObj=StringConcatenate("_",ExtComplekt,"pg",Time[aXABCD[B]],"_",Time[aXABCD[X]]);
               ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[X]],zz[aXABCD[X]],Time[aXABCD[B]],zz[aXABCD[B]]);
               ObjectSet(nameObj,OBJPROP_RAY,false);
               ObjectSet(nameObj,OBJPROP_STYLE,STYLE_DOT);
               ObjectSet(nameObj,OBJPROP_COLOR,ExtLine);
               ObjectSet(nameObj,OBJPROP_BACK,ExtBack);
                
               k1=MathCeil((aXABCD[X]+aXABCD[D])/2);
               nameObj=StringConcatenate("_",ExtComplekt,"pgtxt",Time[aXABCD[D]],"_",Time[aXABCD[X]]);
               ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(zz[aXABCD[D]]+zz[aXABCD[X]])/2);
               ObjectSetText(nameObj,DoubleToStr(retXD,3),ExtSizeTxt,"Arial", ExtNotFibo);
               nameObj=StringConcatenate("_",ExtComplekt,"pg",Time[aXABCD[D]],"_",Time[aXABCD[X]]);
               ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[X]],zz[aXABCD[X]],Time[aXABCD[D]],zz[aXABCD[D]]);
               ObjectSet(nameObj,OBJPROP_RAY,false);
               ObjectSet(nameObj,OBJPROP_STYLE,STYLE_DOT);
               ObjectSet(nameObj,OBJPROP_COLOR,ExtLine);
               ObjectSet(nameObj,OBJPROP_BACK,ExtBack);
                
               k1=MathCeil((aXABCD[B]+aXABCD[D])/2);
               nameObj=StringConcatenate("_",ExtComplekt,"pgtxt",Time[aXABCD[D]],"_",Time[aXABCD[B]]);
               ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(zz[aXABCD[D]]+zz[aXABCD[B]])/2);
               ObjectSetText(nameObj,DoubleToStr(retBD,3),ExtSizeTxt,"Arial", ExtNotFibo);
               nameObj=StringConcatenate("_",ExtComplekt,"pg",Time[aXABCD[D]],"_",Time[aXABCD[B]]);
               ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[B]],zz[aXABCD[B]],Time[aXABCD[D]],zz[aXABCD[D]]);
               ObjectSet(nameObj,OBJPROP_RAY,false);
               ObjectSet(nameObj,OBJPROP_STYLE,STYLE_DOT);
               ObjectSet(nameObj,OBJPROP_COLOR,ExtLine);
               ObjectSet(nameObj,OBJPROP_BACK,ExtBack);
                  
               k1=MathCeil((aXABCD[A]+aXABCD[C])/2);
               nameObj=StringConcatenate("_",ExtComplekt,"pgtxt",Time[aXABCD[C]],"_",Time[aXABCD[A]]);
               ObjectCreate(nameObj,OBJ_TEXT,0,Time[k1],(zz[aXABCD[C]]+zz[aXABCD[A]])/2);
               ObjectSetText(nameObj,DoubleToStr(retAC,3),ExtSizeTxt,"Arial", ExtNotFibo);
               nameObj=StringConcatenate("_",ExtComplekt,"pg",Time[aXABCD[C]],"_",Time[aXABCD[A]]);
               ObjectCreate(nameObj,OBJ_TREND,0,Time[aXABCD[A]],zz[aXABCD[A]],Time[aXABCD[C]],zz[aXABCD[C]]);
               ObjectSet(nameObj,OBJPROP_RAY,false);
               ObjectSet(nameObj,OBJPROP_STYLE,STYLE_DOT);
               ObjectSet(nameObj,OBJPROP_COLOR,ExtLine);
               ObjectSet(nameObj,OBJPROP_BACK,ExtBack);
              }
           }

         // Вывод в файлы информациpatternNumberи о паттернах
         if ((writeInfoPatternsToFileXML>0 || writeInfoPatternsToFileCSV>0) && (save_cenaPointD!=zz[aXABCD[D]] || save_timePointD_0!=Time[0]))
           {
            if (PatternNews && ExtGartleyTypeSearch==0 && vWriteToFilePattern)
              {
               WriteFilePattern(vBullBear, patternNumber, aXABCD, tDragonE, cDragonE, true);
              }
            else if (!PatternNews && namefileSymbolPeriod)
              {
               WriteFilePattern(vBullBear, patternNumber, aXABCD, tDragonE, cDragonE, false);
              }
            save_cenaPointD=zz[aXABCD[D]]; save_timePointD_0=Time[0];
            vWriteToFilePattern=false;
           }

         return;
        }
      else 
        {
         vBullBear    = "";
         vNamePattern = "";
        }
      k++;

      if (patternInfluence==1)
        {
         if (!(ExtIndicator>5 && ExtIndicator<11 && GrossPeriod>Period()))
           {
            bartoD=AllowedBandPatternInfluence*(aNumBarPeak[k+4]-aNumBarPeak[k]);
           }
        }
     }
  }
//--------------------------------------------------------
// Поиск паттернов Gartley. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод монитора паттернов. Начало.
//--------------------------------------------------------
void _Monitor()
  {
   // Монитор паттернов
   if (MonitorPatterns && countGartley>0)
     {
      int j, j1=1, j2=-1, j3, save_D[1][3];
      color Cmonitor;

      if (ExtGartleyTypeSearch>0)
        {
         ArraySort(__D,countGartley,0,MODE_ASCEND);
         j3=__D[0][0];

         for (j=1;j<countGartley;j++) 
           {
            if (j3==__D[0][0])
              {
               j2++;
               if (j1<j2) j1=j2;
              }
            else
              {
               j3=__D[0][0];
               j2=0;
              }
           }

         for (j=1;j<countGartley && j1>0;j++)
           {
            if (__D[j][0]==__D[j-1][0])
              {
               if (__D[j][1]>__D[j-1][1])
                 {
                  save_D[0][0]=__D[j-1][1];
                  save_D[0][1]=__D[j-1][2];
                  save_D[0][2]=__D[j-1][3];
                  __D[j-1][1]=__D[j][1];
                  __D[j-1][2]=__D[j][2];
                  __D[j-1][3]=__D[j][3];
                  __D[j][1]=save_D[0][0];
                  __D[j][2]=save_D[0][1];
                  __D[j][3]=save_D[0][2];
                 }
              }

            if (j==countGartley-1)
              {
               j=0;
               j1--;
              }
           }
        }

      delete_objects_monitor();

      for (j=0;j<countGartley;j++)
        {
         if (StringFind(__NamePatterns[__D[j][3]][0],"Bullish",0)>=0) Cmonitor=clrBlue;
         else Cmonitor=clrRed;
               
         // номер бара
         nameObj=StringConcatenate("_",ExtComplekt,"_","MonitorPatterns_1",j);
         ObjectCreate(nameObj,OBJ_LABEL,0,0,0);
         ObjectSetText(nameObj,StringConcatenate("",__D[j][0]));
         ObjectSet(nameObj, OBJPROP_FONTSIZE, TextSize);
         ObjectSet(nameObj, OBJPROP_COLOR, __PatColor[__D[j][3]]);
         ObjectSet(nameObj, OBJPROP_CORNER, 0);
         ObjectSet(nameObj, OBJPROP_XDISTANCE, 10);
         ObjectSet(nameObj, OBJPROP_YDISTANCE, 50+j*(4+TextSize));

         // параметры зигзага
         nameObj=StringConcatenate("_",ExtComplekt,"_","MonitorPatterns_2",j);
         ObjectCreate(nameObj,OBJ_LABEL,0,0,0);
         if (AlgorithmSearchPatterns==0) ObjectSetText(nameObj,StringConcatenate("",__D[j][1],"/",__D[j][2]));
         else ObjectSetText(nameObj,StringConcatenate("",__D[j][1]));
         ObjectSet(nameObj, OBJPROP_FONTSIZE, TextSize);
         ObjectSet(nameObj, OBJPROP_COLOR, __PatColor[__D[j][3]]);
         ObjectSet(nameObj, OBJPROP_CORNER, 0);
         ObjectSet(nameObj, OBJPROP_XDISTANCE, 50);
         ObjectSet(nameObj, OBJPROP_YDISTANCE, 50+j*(4+TextSize));

         // ретресменты паттерна
         nameObj=StringConcatenate("_",ExtComplekt,"_","MonitorPatterns_3",j);
         ObjectCreate(nameObj,OBJ_LABEL,0,0,0);
         ObjectSetText(nameObj,__NamePatterns[__D[j][3]][1]);
         ObjectSet(nameObj, OBJPROP_FONTSIZE, TextSize);
         ObjectSet(nameObj, OBJPROP_COLOR, __PatColor[__D[j][3]]);
         ObjectSet(nameObj, OBJPROP_CORNER, 0);
         ObjectSet(nameObj, OBJPROP_XDISTANCE, 110);
         ObjectSet(nameObj, OBJPROP_YDISTANCE, 50+j*(4+TextSize));

         // наименование паттерна
         nameObj=StringConcatenate("_",ExtComplekt,"_","MonitorPatterns_4",j);
         ObjectCreate(nameObj,OBJ_LABEL,0,0,0);
         ObjectSetText(nameObj,__NamePatterns[__D[j][3]][0]);
         ObjectSet(nameObj, OBJPROP_FONTSIZE, TextSize);
         ObjectSet(nameObj, OBJPROP_COLOR, Cmonitor);
         ObjectSet(nameObj, OBJPROP_CORNER, 0);
         ObjectSet(nameObj, OBJPROP_XDISTANCE, 170);
         ObjectSet(nameObj, OBJPROP_YDISTANCE, 50+j*(4+TextSize));
        }
     }
  }
//--------------------------------------------------------
// Вывод монитора паттернов. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Создание названия пятиточечного паттерна. Начало.
//--------------------------------------------------------
string NamePattern(int i)
  {
   string str=" [";
   int j, k;
   
   for (j=0;j<4;j++)
     {
      if (j==0) k=3; else k=j-1;
      if (pp[i][2*k]==0 && pp[i][2*k+1]==0)
        {
         str=StringConcatenate(str,"-");
         if (j<3) str=StringConcatenate(str,"/");
         else str=StringConcatenate(str,"]");
        }
      else
        {
         if (ret[j,0]<0) str=StringConcatenate(str,"*");
         else str=StringConcatenate(str,retpatternstxt[ret[j,0]]);
         if (j<3) str=StringConcatenate(str,"/");
         else str=StringConcatenate(str,"]");
        }
     }

   if (shortNamePatterns) str=namepatterns[i]; else str=StringConcatenate(namepatterns[i],str);
   return (str);
  }
//--------------------------------------------------------
// Создание названия пятиточечного паттерна. Конец.
//--------------------------------------------------------

//--------------------------------------------------------
// Фильтрация паттернов Gartley на выход цены за рамку D. 
// Начало.
//--------------------------------------------------------
bool filtrpatterns_1(int k, int D, string vBull, int& aNumBarPeak[], double LevelForDmin1, double LevelForDmax1)
  {
   int ibreak;
   bool PatternNews=false;

   if (patternTrue && StringLen(vNamePattern)>0 && LevelForDmin1>0)
     {
      PatternNews=true;
      if (k<2)
        {
         if (vBullBear==vBull)
           {
            for (ibreak=D-1;ibreak>=0;ibreak--)
              {
               if (iLow(NULL,0,ibreak)<LevelForDmin1)
                 {
                  vNamePattern = "";
                  PatternNews=false;
                  break;
                 }
              }
           }
         else
           {
            for (ibreak=D-1;ibreak>=0;ibreak--)
              {
               if (iHigh(NULL,0,ibreak)>LevelForDmax1)
                 {
                  vNamePattern = "";
                  PatternNews=false;
                  break;
                 }
              }
           }
        }
      else
        {
         if (vNamePattern=="Dragon") k=k+1;

         if (vBullBear==vBull)
           {
            for (ibreak=k;ibreak>=2;ibreak--)
              {
               if (iLow(NULL,0,aNumBarPeak[ibreak-2])<LevelForDmin1)
                 {
                  vNamePattern = "";
                  PatternNews=false;
                  break;
                 }
              }
           }
         else
           {
            for (ibreak=k;ibreak>=2;ibreak--)
              {
               if (iHigh(NULL,0,aNumBarPeak[ibreak-2])>LevelForDmax1)
                 {
                  vNamePattern = "";
                  PatternNews=false;
                  break;
                 }
              }
           }
        }
     }
   return (PatternNews);
  }
//--------------------------------------------------------
// Фильтрация паттернов Gartley на выход цены за рамку D.
// Конец.
//--------------------------------------------------------

//----------------------------------------------------
// nen-ZigZag. Режим DT. Начало.
//----------------------------------------------------
void nenZigZag()
 {
  if (cbi>0)
    {
//     datetime nen_time=iTime(NULL,GrossPeriod,ExtMinBar);
     datetime nen_time=iTime(NULL,GrossPeriod,0);
     int i=0, j=0; // j - номер бара с максимальным максимумом (минимальным минимумом) в полоске nen-ZigZag
     double nen_dt=0, last_j=0, last_nen=0; //last_j - значение максимального максимума (минимального минимума) в полоске nen_ZigZag
     int limit, big_limit, bigshift=0;

     int i_metka=-1, i_metka_m=-1, k, m, jm;
     bool fl_metka=false;
     double last_jm=0, last_nen_m=0;

     if (ExtMaxBar>0) _maxbarZZ=ExtMaxBar; else _maxbarZZ=Bars;

     if (init_zz)
       {
        limit=_maxbarZZ-1;
        big_limit=iBars(NULL,GrossPeriod)-1;
       }
     else
       {
        limit=iBarShift(NULL,0,afr[2]);
        big_limit=iBarShift(NULL,GrossPeriod,afr[2]);
       }

     while (bigshift<big_limit && i<limit) // начальное заполнение буфера nen-ZigZag ("полоски")
       {
        if (Time[i]>=nen_time)
          {
           if (ExtIndicator==6)
             {
              if (ExtLabel>0)
                {
                 ha[i]=iCustom(NULL,GrossPeriod,"ZigZag_nen2",minBars,ExtBackstep,noBackstep,1,RecoverFiltr,1,bigshift);
                 la[i]=iCustom(NULL,GrossPeriod,"ZigZag_nen2",minBars,ExtBackstep,noBackstep,1,RecoverFiltr,2,bigshift);
                }
              nen_ZigZag[i]=iCustom(NULL,GrossPeriod,"ZigZag_nen2",minBars,ExtBackstep,noBackstep,0,RecoverFiltr,0,bigshift);
             }
           else  if (ExtIndicator==7)
             {
              if (ExtLabel>0)
                {
                 ha[i]=iCustom(NULL,GrossPeriod,"DT_ZZ_nen",minBars,1,1,bigshift);
                 la[i]=iCustom(NULL,GrossPeriod,"DT_ZZ_nen",minBars,1,2,bigshift);
                }
              nen_ZigZag[i]=iCustom(NULL,GrossPeriod,"DT_ZZ_nen",minBars,0,0,bigshift);
             }
           else  if (ExtIndicator==8) nen_ZigZag[i]=iCustom(NULL,GrossPeriod,"CZigZag",minBars,ExtDeviation,0,bigshift);
           else  if (ExtIndicator==10)
             {
              if (ExtLabel>0)
                {
                 ha[i]=iCustom(NULL,GrossPeriod,"Swing_ZZ_1",minBars,1,1,bigshift);
                 la[i]=iCustom(NULL,GrossPeriod,"Swing_ZZ_1",minBars,1,2,bigshift);
                }
              nen_ZigZag[i]=iCustom(NULL,GrossPeriod,"Swing_ZZ_1",minBars,1,0,bigshift);
             }
           i++;
          }
        else {bigshift++;nen_time=iTime(NULL,GrossPeriod,bigshift);}
       }

     if (init_zz) // обработка истории
       {
        double i1=0, i2=0;
        init_zz=false;

        for (i=limit;i>ExtMinBar;i--) // определение направления первого луча
          {
           if (nen_ZigZag[i]>0)
             {
              if (i1==0) i1=nen_ZigZag[i];
              else if (i1>0 && i1!=nen_ZigZag[i]) i2=nen_ZigZag[i];
              if (i2>0) 
                {
                 if (i1>i2) hi_nen=true;
                 else hi_nen=false;
                 break;
                }
             }
          }
       }
     else // режим реального времени
       {
        if (afrl[2]>0) hi_nen=false; else hi_nen=true;
       }

     for (i=limit;i>=0;i--)
       {
//        if (i<limit) 
        {zz[i]=0; zzH[i]=0; zzL[i]=0;}

        if (nen_ZigZag[i]>0)
          {
           if (ExtLabel==2)
             {
              if (i_metka_m>=0 && !fl_metka)
                {
                 m=i_metka_m-GrossPeriod/Period();

                 for (k=i_metka_m; k>m; k--)
                   {
                    ha[k]=0; la[k]=0;
                   }

                 if (hi_nen) ha[jm]=last_nen_m;
                 else la[jm]=last_nen_m;
                 jm=0; last_nen_m=0; last_jm=0; i_metka_m=-1;
                }

              if (i_metka<0) i_metka=i;
             }

           fl_metka=true;

           if (nen_dt>0 && nen_dt!=nen_ZigZag[i])
             {
              if (i_metka>=0 && fl_metka)
                {
                 m=i_metka-GrossPeriod/Period();
                 for (k=i_metka; k>m; k--)
                   {
                    ha[k]=0; la[k]=0;
                   }
                 if (hi_nen) ha[j]=last_nen;
                 else la[j]=last_nen;
                 i_metka=i;
                }

              if (hi_nen) {hi_nen=false;zzH[j]=last_nen;}
              else {hi_nen=true;zzL[j]=last_nen;}
              last_j=0;nen_dt=0;zz[j]=last_nen;
             }

           if (hi_nen)
             {
              nen_dt=nen_ZigZag[i];
              if (last_j<High[i]) {j=i;last_j=High[i];last_nen=nen_ZigZag[i];}
             }
           else
             {
              nen_dt=nen_ZigZag[i];
              if (last_j==0) {j=i;last_j=Low[i];last_nen=nen_ZigZag[i];}
              if (last_j>Low[i]) {j=i;last_j=Low[i];last_nen=nen_ZigZag[i];}
             }

           if (nen_dt>0 && i==0)  // определение перелома на нулевом баре GrossPeriod
             {
              if (i_metka>=0 && fl_metka)
                {
                 m=i_metka-GrossPeriod/Period();
                 for (k=i_metka; k>m; k--)
                   {
                    ha[k]=0; la[k]=0;
                   }
                 if (hi_nen) ha[j]=last_nen;
                 else la[j]=last_nen;
                 fl_metka=false;
                }

              zz[j]=last_nen;
              if (hi_nen) zzH[j]=last_nen; else zzL[j]=last_nen;
             }
          }
        else
          {
           if (last_j>0 && fl_metka)
             {
              if (i_metka>=0 && fl_metka)
                {
                 m=i_metka-GrossPeriod/Period();

                 for (k=i_metka; k>m; k--)
                   {
                    ha[k]=0; la[k]=0;
                   }
                 if (hi_nen) ha[j]=last_nen;
                 else la[j]=last_nen;
                }

              fl_metka=false;

              if (hi_nen) {hi_nen=false;zzH[j]=last_nen;}
              else {hi_nen=true;zzL[j]=last_nen;}
              last_j=0;nen_dt=0;zz[j]=last_nen;
              i_metka=-1;
             }

           if (ExtLabel==2)
             {
              if ((ha[i]>0 || la[i]>0) && !fl_metka)
                {

                 if (i_metka_m<0)
                   { 
                    i_metka_m=i; jm=i;
                    if (hi_nen)
                      {
                       last_jm=High[i];last_nen_m=ha[i];
                      }
                    else
                      {
                       last_jm=Low[i];last_nen_m=la[i];
                      }
                   }

                 if (hi_nen)
                   {
                    if (last_nen_m>last_jm) {jm=i;last_jm=High[i];}
                   }
                 else
                   {
                    if (last_nen_m<last_jm) {jm=i;last_jm=Low[i];}
                   }
                }

             }
          }
       }
    }
 }
//--------------------------------------------------------
// nen-ZigZag. Режим DT. Конец. 
//--------------------------------------------------------

//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//  SQZZ by tovaroved.lv.  Начало.  °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
double div(double a, double b){if(MathAbs(b)*10000>MathAbs(a)) return(a*1.0/b); else return(0);}
//=============================================================================================
double ray_value(double B1, double P1, double B2, double P2, double AAA){return(P1+( AAA -B1)*div(P2-P1,B2-B1));}
//=============================================================================================
datetime bar2time(int b){int t,TFsec=Period()*60; if(b<0) t=Time[0]-(b)*TFsec; else if(b>(Bars-1)) t=Time[Bars-1]-(b-Bars+1)*TFsec; else t=Time[b];  return(t);}
//=============================================================================================
int time2bar(datetime t){int b,t0=Time[0],TFsec=Period()*60; if(t>t0) b=(t0-t)/TFsec; else if(t<Time[Bars-2]) b=(Bars-2)+(Time[Bars-2]-t)/TFsec; else b=iBarShift(0,0,t); return(b);}
//=============================================================================================
void ZigZag_SQZZ(bool zzFill=true)
  {
   static int act_time=0,	H1=10000,L1=10000,H2=10000,H3=10000,H4=10000,L2=10000,L3=10000,L4=10000;	
	static double H1p=-1,H2p=-1,H3p=-1, H4p=-1,	L1p=10000,L2p=10000,L3p=10000,L4p=10000;
	int   mnm=1,tb, i, a, barz, b,c, ii, H,L;	double x,Lp,Hp,k=0.;   if(Bars<100) return; if(1==2)bar2time(0);
	barz=Bars-4;int bb=barz;
	if(minBars==0)minBars=minSize;	if(minSize==0)minSize=minBars*3; tb=MathSqrt(minSize*minBars);
	mnm=tb;
	a=time2bar(act_time);	b=barz;
	if(a>=0 && a<tb)
	  {
		ii=a;		a--;		L1+=a;		H1+=a;
		L2+=a;	H2+=a;	L3+=a;		H3+=a;
		if(!zzFill)
		  {
			for(i=barz; i>=a; i--) {zzH[i]=zzH[i-a];	zzL[i]=zzL[i-a];}
			for(;i>=0;i--) {zzH[i]=0;	zzL[i]=0;}
	     }
	  }
	else
	  {
		ii=barz;
		H1=ii+1; L1=ii;
		H2=ii+3; L2=ii+2;
		L2p=Low[L2];H2p=High[H2];	
		L1p=Low[L1];H1p=High[H1];
		H3=H2;	H3p=H2p;
		L3=L2;	L3p=L2p;
     }
	act_time=Time[1];

	for(c=0; ii>=0; c++, ii--)
	  {
		H=ii; L=ii;		Hp=	High[H];	Lp=	Low[L];
		//-------------------------------------------------------------------------------------
		if(H2<L2)
		  {// хай уже есть готовый
			if( Hp>=H1p )
			  {
			   H1=H;	H1p=Hp;
				if( H1p>H2p )
				  {
					zzH[H2]=0;
					H1=H;	H1p=Hp;
					H2=H1;	H2p=H1p;
					L1=H1;	L1p=H1p;
					zzH[H2]=H2p;
				  }
			  }
			else if( Lp<=L1p )
			  {
			   L1=L;	L1p=Lp;
				x=ray_value(L2,L2p,H2+(L2-H3)*0.5,H2p+(L2p-H3p)*0.5,L1);
				if( L1p<=L2p//также работает L1p<=L2p*0.75+H2p*0.25 или любые другие условия
				    || tb*tb*Point<(H2p-L1p)*(H2-L1))
				  { //сдвигаем все Low
					L4=L3;	L4p=L3p;
					L3=L2;	L3p=L2p;
					L2=L1;	L2p=L1p;
					H1=L1;	H1p=L1p;
					zzL[L2]=L2p;
				  }
			  }
	     }
		//--------------------------------------------------------------
		if(L2<H2) {// лоу уже есть готовый
			if( Lp<=L1p )
			  {L1=L;	L1p=Lp;
				if( L1p<=L2p )
				  {
					zzL[L2]=0;
					L1=L;	L1p=Lp;
					L2=L1;	L2p=L1p;
					H1=L1;	H1p=L1p;
					zzL[L2]=L2p;
				  }
			  }
			else if( Hp>=H1p )
			  {
			   H1=H;	H1p=Hp;
				x=ray_value(H2,H2p,L2+0.5*(H2-L3),L2p+0.5*(H2p-L3p),H1);
				if( H1p>=H2p//можно и так: H1p>=H2p*0.75+L2p*0.25
				    || tb*tb*Point<(H1p-L2p)*(L2-H1))
				  { //сдвигаем все High
					H4=H3;	H4p=H3p;
					H3=H2;	H3p=H2p;
					H2=H1;	H2p=H1p;
					L1=H1;	L1p=H1p;
					zzH[H2]=H2p;
				  }
			   }

    		}//--------------------------------------------------------------------------------
	  }//for
	for(ii=bb-1; ii>=0; ii--) zz[ii]=MathMax(zzL[ii],zzH[ii]);
  }
//=======================================================================
// SQZZ by tovaroved.lv. Конец. 
//=======================================================================

//--------------------------------------------------------
// ZZ_2L_nen . Начало.
//#property copyright "Copyright © 2007, wellx. ver 0.07 alpha"
//#property link      "aveliks@gmail.com"
//--------------------------------------------------------
void ZZ_2L_nen()
  {
   int count = IndicatorCounted();
   int k, shift, pos;
   int lasthighpos, lastlowpos;
   double lasthigh, lastlow;

   if (Bars-count-1>2) 
     {
      count=0; NewBarTime=0; countbars=0; realcnt=0;
      ArrayInitialize(zz,0); ArrayInitialize(zzL,0); ArrayInitialize(zzH,0);
     }
   
   for (k=(Bars-count-1);k>=0;k--)
     {
   
      if(( NewBarTime==Time[0]) || (realcnt==Bars))
           first=false; 
      else first=true;
     
   
      //--------------------------------------------------------------------  
      //Находим первую точку индикатора
      //--------------------------------------------------------------------
      if (first)    
       {
         lastlowpos=Bars-1;
         lasthighpos=Bars-1;
         zzL[Bars-1]=0.0;
         zzH[Bars-1]=0.0;
         zz[Bars-1]=0.0;
         realcnt=2;
      
         for(shift=(Bars-2); shift>=0; shift--)
          {
            if ((High[shift]>High[shift+1]) && (Low[shift]>=Low[shift+1])) 
               {
                  zzL[shift]=0.0;
                  zzH[shift]=High[shift];
                  zz[shift]=High[shift];
                  lasthighpos=shift;
                  lasthigh=High[shift];
                  lastlow=Low[Bars-1];
                  pos=shift;
                  first=false;
                  break;          
               }
            if ((High[shift]<=High[shift+1]) && (Low[shift]<Low[shift+1])) 
               {
                  zzL[shift]=Low[shift];
                  zzH[shift]=0.0;
                  zz[shift]=Low[shift];
                  lasthigh=High[Bars-1];
                  lastlowpos=shift;
                  lastlow=Low[shift];
                  pos=shift;
                  first=false;
                  break;
               }
            if ((High[shift]>High[shift+1]) && (Low[shift]<Low[shift+1])) 
               {
                 if ((High[shift]-High[shift+1])>(Low[shift+1]-Low[shift]))
                  {
                     zzL[shift]=0.0;
                     zzH[shift]=High[shift];
                     zz[shift]=High[shift];
                     zzL[shift]=0.0;
                     lasthighpos=shift;
                     lasthigh=High[shift];
                     lastlow=Low[Bars-1];
                     pos=shift;
                     first=false;
                     break;
                  }
            if ((High[shift]-High[shift+1])<(Low[shift+1]-Low[shift]))
               {
                  zzL[shift]=Low[shift];
                  zzH[shift]=0.0;
                  zz[shift]=Low[shift];
                  lasthighpos=shift;
                  lasthigh=High[shift];
                  lastlow=Low[Bars-1];
                  pos=shift;
                  first=false;
                  break;
               } 
            if ((High[shift]-High[shift+1])==(Low[shift+1]-Low[shift]))
               {
                  zzL[shift]=0.0;
                  zzH[shift]=0.0;
                  zz[shift]=0.0;
               } 
         }   
         if  ((High[shift]<High[shift+1]) && (Low[shift]>Low[shift+1])) 
           {
              zzL[shift]=0.0;
              zzH[shift]=0.0;
              zz[shift]=0.0;
         }  
         pos=shift;
         realcnt=realcnt+1;   
         }
      
         //-------------------------------------------------------------------------
         // здесь начинается отработка основного цикла ЗЗ
         //-------------------------------------------------------------------------
          
         for(shift=pos-1; shift>=0; shift--)
          {
           if ((High[shift]>High[shift+1]) && (Low[shift]>=Low[shift+1]))
            {
               if (lasthighpos<lastlowpos)
                {
                  if (High[shift]>High[lasthighpos])
                    {
                     zzL[shift]=0.0;
                     zzH[shift]=High[shift];
                     zz[shift]=High[shift];
                     zz[lasthighpos]=0.0;
                     if (shift!=0)
                        lasthighpos=shift;
                     lasthigh=High[shift];
                     if (lastlowpos!=Bars) 
                        {
                        // Надо рассчитать позднее длины лучей
                        }
                  }  
               } 
               if (lasthighpos>lastlowpos) 
                  {
                     if ((((High[shift]-Low[lastlowpos])>(StLevel*Point)) && ((lastlowpos-shift)>=minBars))  ||
                          ((High[shift]-Low[lastlowpos])>=(BigLevel*Point))) 
                     {
                        zzL[shift]=0.0;
                        zzH[shift]=High[shift];
                        zz[shift]=High[shift];
                        //zz[lasthighpos]=0.0;
                        if (shift!=0)
                           lasthighpos=shift;
                        lasthigh=High[shift]; 
                     }
                  }    
            }
           if ((High[shift]<=High[shift+1]) && (Low[shift]<Low[shift+1]))
            {
             if (lastlowpos<lasthighpos)
              {
               if (Low[shift]<Low[lastlowpos])
                { 
                  zzL[shift]=Low[shift];
                  zzH[shift]=0.0;
                  zz[shift]=Low[shift];
                  zz[lastlowpos]=0.0;
                  if (shift!=0)
                     lastlowpos=shift;
                  lastlow=Low[shift];
                }
             }
             if (lastlowpos>lasthighpos)
              {
               if ((((High[lasthighpos]-Low[shift])>(StLevel*Point)) && ((lasthighpos-shift)>=minBars))  ||
                    ((High[lasthighpos]-Low[shift])>=(BigLevel*Point))) 
                {
                  zzL[shift]=Low[shift];
                  zzH[shift]=0.0;
                  zz[shift]=Low[shift];
                  //zz[lastlowpos]=0.0;
                  if (shift!=0)
                     lastlowpos=shift;
                  lastlow=Low[shift]; 
               }
             } 
           }
           if ((High[shift]>High[shift+1]) && (Low[shift]<Low[shift+1]))
            {
             if (lastlowpos<lasthighpos)
              {
               if (Low[shift]<Low[lastlowpos])
                {
                  zzL[shift]=Low[shift];
                  zzH[shift]=0.0;
                  zz[shift]=Low[shift];
                  zz[lastlowpos]=0.0;
                  if (shift!=0) 
                     lastlowpos=shift;
                  lastlow=Low[shift];
               } 
             }
             if (lasthighpos<lastlowpos) 
              {
               if (High[shift]>High[lasthighpos])
                {
                  zzL[shift]=0.0;
                  zzH[shift]=High[shift];
                  zz[shift]=High[shift];
                  zz[lasthighpos]=0.0;
                  if (shift!=0)
                     lasthighpos=shift;
                  lasthigh=High[shift];
               }
             }
           } 
           realcnt=realcnt+1; 
           // if (shift<=0)
        }
        
       first=false; 
       countbars=Bars;
       NewBarTime=Time[0];
    }
    
    //****************************************************************************************************
    //
    //   Обработка нулевого бара
    //
    //****************************************************************************************************    
    else
    //if (!first) 
    
    { 
     if (realcnt!=Bars)
     {
      first=True;
      return;
     } 
        
     if (Close[0]>=lasthigh) 
      {
       if (lastlowpos<lasthighpos)
        {
          if (Low[0]>lastlow)
           {
            if ((((High[0]-Low[lastlowpos])>(StLevel*Point)) && ((lastlowpos)>=minBars))  ||
                 ((High[0]-Low[lastlowpos])>(BigLevel*Point))) 
              {
               zzL[0]=0.0;
               zzH[0]=High[0];
               zz[0]=High[0]; 
               lasthigh=High[0];
               // lasthighpos=0;
              }
           }
        }
       if (lastlowpos>lasthighpos)
        {
         if (High[0]>=lasthigh)
          {
           zz[lasthighpos]=0.0;
           zz[0]=High[0];
           zzL[0]=0.0;
           zzH[0]=High[0];
           lasthighpos=0;
           lasthigh=High[0];
          }
        }  
       //lasthigh=High[0];
      }
     if (Close[0]<=lastlow) 
      {
       if (lastlowpos<lasthighpos)
        {
           zz[lastlowpos]=0.0;
           zz[0]=Low[0];
           zzL[0]=Low[0];
           zzH[0]=0.0;
           lastlow=Low[0];
           lastlowpos=0;  
        //  }
        }
       if (lastlowpos>lasthighpos)
        {
         if (High[0]<lasthigh)
          {
           if ((((High[lasthighpos]-Low[shift])>(StLevel*Point)) && ((lasthighpos-shift)>=minBars))  ||
                  ((High[lasthighpos]-Low[shift])>(BigLevel*Point)))
            {
             zz[0]=Low[0];
             zzL[0]=Low[0];
             zzH[0]=0.0;
             lastlow=Low[0];
             // lastlowpos=0;
            } 
          }
        }  
       //lastlow=Low[0];
      }
    }  
     
   return;
  }

  }
//--------------------------------------------------------
// ZZ_2L_nen . Конец.
//#property copyright "Copyright © 2007, wellx. ver 0.07 alpha"
//#property link      "aveliks@gmail.com"
//--------------------------------------------------------

//--------------------------------------------------------
// Параметры разных таймфреймов и другая информация. Начало. 
//--------------------------------------------------------
void info_TF()
  {
   string info="", info1="", info2="", info3="", info4="", txt="", txt0="", txt1="", regim="", perc="", mp0="", mp1="";
   int i, j=0, k;
   double pips;

   openTF[0]=iOpen(NULL,PERIOD_MN1,0);
   closeTF[0]=iClose(NULL,PERIOD_MN1,0);
   lowTF[0]=iLow(NULL,PERIOD_MN1,0);
   highTF[0]=iHigh(NULL,PERIOD_MN1,0);
   
   openTF[1]=iOpen(NULL,PERIOD_W1,0);
   closeTF[1]=iClose(NULL,PERIOD_W1,0);
   lowTF[1]=iLow(NULL,PERIOD_W1,0);
   highTF[1]=iHigh(NULL,PERIOD_W1,0);
   
   openTF[2]=iOpen(NULL,PERIOD_D1,0);
   closeTF[2]=iClose(NULL,PERIOD_D1,0);
   lowTF[2]=iLow(NULL,PERIOD_D1,0);
   highTF[2]=iHigh(NULL,PERIOD_D1,0);
   
   openTF[3]=iOpen(NULL,PERIOD_H4,0);
   closeTF[3]=iClose(NULL,PERIOD_H4,0);
   lowTF[3]=iLow(NULL,PERIOD_H4,0);
   highTF[3]=iHigh(NULL,PERIOD_H4,0);
   
   openTF[4]=iOpen(NULL,PERIOD_H1,0);
   closeTF[4]=iClose(NULL,PERIOD_H1,0);
   lowTF[4]=iLow(NULL,PERIOD_H1,0);
   highTF[4]=iHigh(NULL,PERIOD_H1,0);
   
   if (StringSubstr(info_comment,2,1)=="1")
     {
      if (minPercent>0) perc=DoubleToStr(MathAbs(minPercent),1); else perc="0.0";
      switch (ExtIndicator)
        {
         case 0     : {
                       if (noBackstep)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minBarsToNumberPattern);
                         }
                       else
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minBarsToNumberPattern," / ",vBackstepToNumberPattern);
                         }
                       break;
                      }
         case 1     : {regim=StringConcatenate(" | ",ExtIndicator," / ",minSize," / ",perc," %"); break;}
         case 2     : {regim=StringConcatenate(" | ",ExtIndicator," / ",minBars,"/",minSize); break;}
         case 3     : {regim=StringConcatenate(" | ",ExtIndicator," / ",minBars); break;}
         case 4     : {regim=StringConcatenate(" | ",ExtIndicator," / ",minSize); break;}
         case 5     : {regim=StringConcatenate(" | ",ExtIndicator," / ",minBars); break;}
         case 6     : {
                       if (noBackstep)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",GrossPeriod," / ",minBarsToNumberPattern);
                         }
                       else
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",GrossPeriod," / ",minBarsToNumberPattern," / ",vBackstepToNumberPattern);
                         }
                       break;
                      }
         case 7     : {regim=StringConcatenate(" | ",ExtIndicator," / ",GrossPeriod," / ",minBars); break;}
         case 8     : {regim=StringConcatenate(" | ",ExtIndicator," / ",GrossPeriod," / ",minBars," / ",ExtDeviation); break;}
         case 10    : {regim=StringConcatenate(" | ",ExtIndicator," / ",GrossPeriod," / ",minBars); break;}
         case 11    : {
                       if (AlgorithmSearchPatterns==0)
                         {
                          if (noBackstep)
                            {
                             if (NumberPattern==0) regim=StringConcatenate(" | ",ExtIndicator," / ",_minBars);
                             else regim=StringConcatenate(" | ",ExtIndicator," / ",minBarsToNumberPattern);
                            }
                          else
                            {
                             if (NumberPattern==0) regim=StringConcatenate(" | ",ExtIndicator," / ",_minBars," / ",_ExtBackstep);
                             else
                               {
                                regim=StringConcatenate(" | ",ExtIndicator," / ",minBarsToNumberPattern," / ",vBackstepToNumberPattern);
                               }
                            }
                         }
                       else if (AlgorithmSearchPatterns==1)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minSizeToNumberPattern," / ",perc," %");
                         }
                       else if (AlgorithmSearchPatterns==2)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minSize,"/",minPercentToNumberPattern," %");
                         }
                       else if (AlgorithmSearchPatterns==3)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minBars,"/",minSizeToNumberPattern);
                         }
                       else if (AlgorithmSearchPatterns==4)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minSizeToNumberPattern);
                         }
                       else if (AlgorithmSearchPatterns==5)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minBarsToNumberPattern);
                         }
                       else if (AlgorithmSearchPatterns==6)
                         {
                          regim=StringConcatenate(" | ",ExtIndicator," / ",minSizeToNumberPattern);
                         }
                       break;
                      }
         case 12    : {regim=StringConcatenate(" | ",ExtIndicator," / ",minSize); break;}
         case 13    : {regim=StringConcatenate(" | ",ExtIndicator," / ",minBars," / ",minSize); break;}
         case 14    : {regim=StringConcatenate(" | ",ExtIndicator," / ",StLevel," / ",BigLevel," / ",minBars); break;}
        }
     }
 
   info="";

   if (StringSubstr(info_comment,0,1)=="1")
     {
      for (i=0;i<5;i++)
        {
         pips=(highTF[i]-lowTF[i])/Point;
         if (pips>0)
           {
            if (openTF[i]==closeTF[i]) {txt=" = ";}
            else if (openTF[i]!=closeTF[i] && MathAbs((highTF[i]-lowTF[i])/(openTF[i]-closeTF[i]))>=6.6) {txt=" -|- ";}
            else if (openTF[i]>closeTF[i]) {txt=" \/ ";}
            else if (openTF[i]<closeTF[i]) {txt=" /\ ";}
            info=StringConcatenate(info,TF[i],txt,DoubleToStr(pips,0),"   ",DoubleToStr((closeTF[i]-lowTF[i])/(pips*Point),3)," |  ");
           }
         else if (pips==0)
           {
            txt=" -|- ";
            info=StringConcatenate(info,TF[i],txt,DoubleToStr(pips,0)," |  ");
           }
        }
      info1=info;
     }

   if (StringSubstr(info_comment,1,1)=="1")
     {
      info1=info1+Period_tf;
      if (afrl[0]>0)
        {
         if (afrh[1]!=0) info1=StringConcatenate(info1,"  ",DoubleToStr(100*MathAbs(afrh[1]-afrl[0])/afrh[1],2)," %");
        }
      else
        {
         if (afrl[1]!=0) info1=StringConcatenate(info1,"  ",DoubleToStr(100*MathAbs(afrh[0]-afrl[1])/afrl[1],2)," %");
        }
     }

   info1=info1+regim;

   if (StringSubstr(info_comment,3,1)=="1")
     {
      if (StringLen(vNamePatternToNumberPattern)>0)
        {
         info2=StringConcatenate("It is found ",countGartley," patterns  -  for pattern N ",NumberPattern," - ",vBullBearToNumberPattern," ",vNamePatternToNumberPattern," - ",DoubleToStr(LevelForDminToNumberPattern,Digits)," < Range of the prices D < ",DoubleToStr(LevelForDmaxToNumberPattern,Digits));
          Alert (Symbol() + " " + Period() + " pattern " + vBullBear + " " + vNamePattern + " " );// эта часть кода вставлена для улучшения алерта 3.07.14 поручик 70 лет освобождения Беларуси от фашистов. Слава России!!!  Смерть укро-фашистам!!!
        }
      else info2="";
     }

   if (infoMerrillPattern)
     {
      for (k=4;k>=0;k--)
        {
         j=mPeak0[k][1];
         txt0=txt0+j;
         j=mPeak1[k][1];
         txt1=txt1+j;
        }

      for (k=0;k<32;k++)
        {
         if (txt0==mMerrillPatterns[k][0]) {mp0=StringConcatenate(mMerrillPatterns[k][1],"   ",mMerrillPatterns[k][2]);}
         if (txt1==mMerrillPatterns[k][0]) {mp1=StringConcatenate(mMerrillPatterns[k][1],"   ",mMerrillPatterns[k][2]);}
        }

      if (StringLen(mp1)>0 && StringLen(mp0)>0) info4=StringConcatenate("Static  ",mp1,"  /  ","Dinamic  ",mp0);
      else if (StringLen(mp1)>0) info4=StringConcatenate("Static  ",mp1);
      else if (StringLen(mp0)>0) info4=StringConcatenate("Dinamic  ",mp0);
     }

   Comment(info1,"\n",info2,"\n",""+info3,"\n",""+info4);
//      if (RangeForPointD && vNamePatternToNumberPattern != "")
   if (bigText)
     {
      if (infoMerrillPattern)
        {
         nameObj=StringConcatenate("#_TextPatternMP_#",ExtComplekt,"_");
         ObjectDelete(nameObj);
         ObjectCreate(nameObj,OBJ_LABEL,0,0,0);

         ObjectSetText(nameObj,info4);
         ObjectSet(nameObj, OBJPROP_FONTSIZE, bigTextSize);
         ObjectSet(nameObj, OBJPROP_COLOR, bigTextColor);

         ObjectSet(nameObj, OBJPROP_CORNER, 1);
         ObjectSet(nameObj, OBJPROP_XDISTANCE, bigTextX);
         ObjectSet(nameObj, OBJPROP_YDISTANCE, bigTextY+3+bigTextSize);
        }
     }
  }
//--------------------------------------------------------
// Параметры разных таймфреймов и другая информация. Конец. 
//--------------------------------------------------------

//--------------------------------------------------------
// Вывод названия паттерна крупным шрифтом и т.д.. Начало. 
//--------------------------------------------------------
void bigTextPattern_etc()
  {
   string txtGlobal=StringConcatenate("ZUP",Symbol(),Period());
   bool patternBull=false;

   if (vBullBearToNumberPattern=="Bullish") patternBull=true;

   if (bigText)
     {
      if (StringLen(vNamePatternToNumberPattern)>0)
        {
         nameObj=StringConcatenate("#_TextPattern_#",ExtComplekt,"_");
         ObjectDelete(nameObj);
         ObjectCreate(nameObj,OBJ_LABEL,0,0,0);

         ObjectSetText(nameObj,_InfoPointD + " " + vBullBearToNumberPattern + " " + vNamePatternToNumberPattern);
         ObjectSet(nameObj, OBJPROP_FONTSIZE, bigTextSize);
         if (patternBull) ObjectSet(nameObj, OBJPROP_COLOR, bigTextColor); else ObjectSet(nameObj, OBJPROP_COLOR, bigTextColorBearish);

         ObjectSet(nameObj, OBJPROP_CORNER, 1);
         ObjectSet(nameObj, OBJPROP_XDISTANCE, bigTextX);
         ObjectSet(nameObj, OBJPROP_YDISTANCE, bigTextY);
        }
     }

   if (ExtGlobalVariableSet)
     {
      if (StringLen(vNamePatternToNumberPattern)>0)
        {
         if (patternBull) GlobalVariableSet(txtGlobal,1);
         else GlobalVariableSet(txtGlobal,-1);
        }
      else
        {
         if (GlobalVariableCheck(txtGlobal)) GlobalVariableDel(txtGlobal);
        }
     }
  }
//--------------------------------------------------------
// Вывод названия паттерна крупным шрифтом и т.д.. Конец. 
//--------------------------------------------------------

//--------------------------------------------------------
// Создаем массивы с числами. Начало. 
//--------------------------------------------------------
void array_()
  {
   for (int i=0; i<64; i++)
     {
      numberFibo            [i]=0;
      numberPesavento       [i]=0;
      numberGartley         [i]=0;
      numberGilmorQuality   [i]=0;
      numberGilmorGeometric [i]=0;
      numberGilmorHarmonic  [i]=0;
      numberGilmorArithmetic[i]=0;
      numberGilmorGoldenMean[i]=0;
      numberSquare          [i]=0;
      numberCube            [i]=0;
      numberRectangle       [i]=0;
      numberExt             [i]=0;
     }

   number                [0]=0.111;
   numbertxt             [0]=".111";
   numberCube            [0]=1;

   number                [1]=0.125;
   numbertxt             [1]=".125";
   numberMix             [1]=1;
   numberGilmorHarmonic  [1]=1;

   number                [2]=0.146;
   numbertxt             [2]=".146";
   numberFibo            [2]=1;
   numberGilmorGeometric [2]=1;

   number                [3]=0.167;
   numbertxt             [3]=".167";
   numberGilmorArithmetic[3]=1;

   number                [4]=0.177;
   numbertxt             [4]=".177";
   numberGilmorHarmonic  [4]=1;
   numberSquare          [4]=1;

   number                [5]=0.186;
   numbertxt             [5]=".186";
   numberGilmorGeometric [5]=1;

   number                [6]=0.192;
   numbertxt             [6]=".192";
   numberCube            [6]=1;

   number                [7]=0.2;
   numbertxt             [7]=".2";
   numberRectangle       [7]=1;

   number                [8]=0.236;
   numbertxt             [8]=".236";
   numberFibo            [8]=1;
   numberMix             [8]=1;
   numberGilmorGeometric [8]=1;
   numberGilmorGoldenMean[8]=1;

   number                [9]=0.25;
   numbertxt             [9]=".25";
   numberPesavento       [9]=1;
   numberGilmorQuality   [9]=1;
   numberGilmorHarmonic  [9]=1;
   numberSquare          [9]=1;

   number                [10]=0.3;
   numbertxt             [10]=".3";
   numberGilmorGeometric [10]=1;
   numberGilmorGoldenMean[10]=1;

   number                [11]=0.333;
   numbertxt             [11]=".333";
   numberGilmorArithmetic[11]=1;
   numberCube            [11]=1;

   number                [12]=0.354;
   numbertxt             [12]=".354";
   numberGilmorHarmonic  [12]=1;
   numberSquare          [12]=1;

   number                [13]=0.382;
   numbertxt             [13]=".382";
   numberFibo            [13]=1;
   numberPesavento       [13]=1;
   numberGartley         [13]=1;
   numberGilmorQuality   [13]=1;
   numberGilmorGeometric [13]=1;

   number                [14]=0.447;
   numbertxt             [14]=".447";
   numberGartley         [14]=1;
   numberRectangle       [14]=1;

   number                [15]=0.486;
   numbertxt             [15]=".486";
   numberGilmorGeometric [15]=1;
   numberGilmorGoldenMean[15]=1;

   number                [16]=0.5;
   numbertxt             [16]=".5";
   numberFibo            [16]=1;
   numberPesavento       [16]=1;
   numberGartley         [16]=1;
   numberGilmorQuality   [16]=1;
   numberGilmorHarmonic  [16]=1;
   numberSquare          [16]=1;

   number                [17]=0.526;
   numbertxt             [17]=".526";
   numberGilmorGeometric [17]=1;

   number                [18]=0.577;
   numbertxt             [18]=".577";
   numberGilmorArithmetic[18]=1;
   numberCube            [18]=1;

   number                [19]=0.618;
   numbertxt             [19]=".618";
   numberFibo            [19]=1;
   numberPesavento       [19]=1;
   numberGartley         [19]=1;
   numberGilmorQuality   [19]=1;
   numberGilmorGeometric [19]=1;
   numberGilmorGoldenMean[19]=1;

   number                [20]=0.667;
   numbertxt             [20]=".667";
   numberGilmorQuality   [20]=1;
   numberGilmorArithmetic[20]=1;

   number                [21]=0.707;
   numbertxt             [21]=".707";
   numberPesavento       [21]=1;
   numberGartley         [21]=1;
   numberGilmorHarmonic  [21]=1;
   numberSquare          [21]=1;

   number                [22]=0.764;
   numbertxt             [22]=".764";
   numberFibo            [22]=1;

   number                [23]=0.786;
   numbertxt             [23]=".786";
   numberPesavento       [23]=1;
   numberGartley         [23]=1;
   numberGilmorQuality   [23]=1;
   numberGilmorGeometric [23]=1;
   numberGilmorGoldenMean[23]=1;

   number                [24]=0.809;
   numbertxt             [24]=".809";
   numberExt             [24]=1;

   number                [25]=0.841;
   numbertxt             [25]=".841";
   numberPesavento       [25]=1;

   number                [26]=0.854;
   numbertxt             [26]=".854";
   numberFibo            [26]=1;
   numberMix             [26]=1;

   number                [27]=0.874;
   numbertxt             [27]=".874";
   numberExt             [27]=1;

   number                [28]=0.886;
   numbertxt             [28]=".886";
   numberGartley         [28]=1;

   number                [29]=1.0;
   numbertxt             [29]="1.";
   numberFibo            [29]=1;
   numberPesavento       [29]=1;
   numberGartley         [29]=1;
   numberGilmorQuality   [29]=1;
   numberGilmorGeometric [29]=1;

   number                [30]=1.128;
   numbertxt             [30]="1.128";
   numberPesavento       [30]=1;
   numberGartley         [30]=1;

   number                [31]=1.236;
   numbertxt             [31]="1.236";
   numberFibo            [31]=1;

   number                [32]=1.272;
   numbertxt             [32]="1.272";
   numberPesavento       [32]=1;
   numberGartley         [32]=1;
   numberGilmorQuality   [32]=1;
   numberGilmorGeometric [32]=1;
   numberGilmorGoldenMean[32]=1;

   number                [33]=1.309;
   numbertxt             [33]="1.309";
   numberExt             [33]=1;

   number                [34]=1.414;
   numbertxt             [34]="1.414";
   numberPesavento       [34]=1;
   numberGartley         [34]=1;
   numberGilmorHarmonic  [34]=1;
   numberSquare          [34]=1;

   number                [35]=1.5;
   numbertxt             [35]="1.5";
//   numberPesavento       [35]=1;
   numberGilmorArithmetic[35]=1;

   number                [36]=phi;
   numbertxt             [36]="1.618";
   numberFibo            [36]=1;
   numberPesavento       [36]=1;
   numberGartley         [36]=1;
   numberGilmorQuality   [36]=1;
   numberGilmorGeometric [36]=1;
   numberGilmorGoldenMean[36]=1;

   number                [37]=1.732;
   numbertxt             [37]="1.732";
   numberMix             [37]=1;
   numberGilmorQuality   [37]=1;
   numberGilmorArithmetic[37]=1;
   numberCube            [37]=1;

   number                [38]=1.75;
   numbertxt             [38]="1.75";
   numberGilmorQuality   [38]=1;

   number                [39]=1.902;
   numbertxt             [39]="1.902";
   numberMix             [39]=1;
   numberGilmorGeometric [39]=1;

   number                [40]=2.0;
   numbertxt             [40]="2.";
   numberPesavento       [40]=1;
   numberGartley         [40]=1;
   numberGilmorQuality   [40]=1;
   numberGilmorHarmonic  [40]=1;
   numberSquare          [40]=1;

   number                [41]=2.058;
   numbertxt             [41]="2.058";
   numberGilmorGeometric [41]=1;
   numberGilmorGoldenMean[41]=1;

   number                [42]=2.236;
   numbertxt             [42]="2.236";
   numberGartley         [42]=1;
   numberGilmorQuality   [42]=1;
   numberRectangle       [42]=1;

   number                [43]=2.288;
   numbertxt             [43]="2.288";
   numberExt             [43]=1;

   number                [44]=2.5;
   numbertxt             [44]="2.5";
   numberGilmorQuality   [44]=1;

   number                [45]=2.618;
   numbertxt             [45]="2.618";
   numberPesavento       [45]=1;
   numberGartley         [45]=1;
   numberGilmorQuality   [45]=1;
   numberGilmorGeometric [45]=1;
   numberGilmorGoldenMean[45]=1;

   number                [46]=2.828;
   numbertxt             [46]="2.828";
   numberGilmorHarmonic  [46]=1;
   numberSquare          [46]=1;

   number                [47]=3.0;
   numbertxt             [47]="3.0";
   numberGilmorQuality   [47]=1;
   numberGilmorArithmetic[47]=1;
   numberCube            [47]=1;

   number                [48]=3.142;
   numbertxt             [48]="3.142";
   numberGartley         [48]=1;

   number                [49]=3.236;
   numbertxt             [49]="3.236";
   numberExt             [49]=1;

   number                [50]=3.33;
   numbertxt             [50]="3.33";
   numberGilmorQuality   [50]=1;
   numberGilmorGeometric [50]=1;
   numberGilmorGoldenMean[50]=1;
   numberExt             [50]=1;

   number                [51]=3.464;
   numbertxt             [51]="3.464";
   numberExt             [51]=1;

   number                [52]=3.618;
   numbertxt             [52]="3.618";
   numberGartley         [52]=1;

   number                [53]=4.0;
   numbertxt             [53]="4.";
   numberPesavento       [53]=1;
   numberGilmorHarmonic  [53]=1;
   numberSquare          [53]=1;

   number                [54]=4.236;
   numbertxt             [54]="4.236";
   numberFibo            [54]=1;
   numberGilmorQuality   [54]=1;
   numberGilmorGeometric [54]=1;
   numberExt             [54]=1;

   number                [55]=4.472;
   numbertxt             [55]="4.472";
   numberExt             [55]=1;

   number                [56]=5.0;
   numbertxt             [56]="5.";
   numberRectangle       [56]=1;

   number                [57]=5.2;
   numbertxt             [57]="5.2";
   numberCube            [57]=1;

   number                [58]=5.388;
   numbertxt             [58]="5.388";
   numberGilmorGeometric [58]=1;

   number                [59]=5.657;
   numbertxt             [59]="5.657";
   numberGilmorHarmonic  [59]=1;
   numberSquare          [59]=1;

   number                [60]=6.0;
   numbertxt             [60]="6.";
   numberGilmorArithmetic[60]=1;

   number                [61]=6.854;
   numbertxt             [61]="6.854";
   numberGilmorQuality   [61]=1;
   numberGilmorGeometric [61]=1;

   number                [62]=8.0;
   numbertxt             [62]="8.";
   numberGilmorHarmonic  [62]=1;

   number                [63]=9.0;
   numbertxt             [63]="9.";
   numberCube            [63]=1;
/*
   number                []=;
   numbertxt             []=;

// ExtFiboType=0
   numberFibo            []=;
// 0
   numberPesavento       []=;
// 1
   numberGartley         []=;
// 2
   numberMix             []=;
// 3
   numberGilmorQuality   []=;
// 4
   numberGilmorGeometric []=;
// 5
   numberGilmorHarmonic  []=;
// 6
   numberGilmorArithmetic[]=;
// 7
   numberGilmorGoldenMean[]=;
// 8
   numberSquare          []=;
// 9
   numberCube            []=;
// 10
   numberRectangle       []=;
// 11
   numberExt             []=;
*/
  }
//--------------------------------------------------------
// Создаем массивы с числами. Конец. 
//--------------------------------------------------------

//--------------------------------------------------------
// Определение значений и цвета чисел для паттернов Песавенто. Начало. 
//--------------------------------------------------------
void Pesavento_patterns()
  {
   if (ExtFiboType==1)
     {
      switch (ExtFiboChoice)
        {
         case 0  : {search_number(numberPesavento, ExtPesavento)        ;break;}
         case 1  : {search_number(numberGartley, ExtGartley886)         ;break;}
         case 2  : {search_number(numberGartley, ExtGartley886)         ;break;}
         case 3  : {search_number(numberGilmorQuality, ExtPesavento)    ;break;}
         case 4  : {search_number(numberGilmorGeometric, ExtPesavento)  ;break;}
         case 5  : {search_number(numberGilmorHarmonic, ExtPesavento)   ;break;}
         case 6  : {search_number(numberGilmorArithmetic, ExtPesavento) ;break;}
         case 7  : {search_number(numberGilmorGoldenMean, ExtPesavento) ;break;}
         case 8  : {search_number(numberSquare, ExtPesavento)           ;break;}
         case 9  : {search_number(numberCube, ExtPesavento)             ;break;}
         case 10 : {search_number(numberRectangle, ExtPesavento)        ;break;}
         case 11 : {search_number(numberExt, ExtPesavento)              ;break;}
        }
      }
    else
      {
       search_number(numberFibo, ExtPesavento);
      }

  }
//--------------------------------------------------------
// Определение значений и цвета чисел для паттернов Песавенто. Конец. 
//--------------------------------------------------------

//--------------------------------------------------------
// Поиск числа для паттернов Песавенто. Начало. 
//--------------------------------------------------------
void search_number(int & arr[], color cPattern)
  {
   int ki, kiPRZ=0, i=0, j[2]={0,0};
   double j1[2]={0,0}, delta;
   colorPPattern=ExtNotFibo;
   if (ExtFiboChoice!=2)
     {
      if (ExtDeltaType==2)
        {
         for (ki=kiPRZ;ki<64 && i<2;ki++)
           {
            if (arr[ki]>0)
              {
               delta=MathAbs((number[ki]-kj)/number[ki]);
               if (delta<=ExtDelta)
                 {
                  j[i]=ki; j1[i]=delta; i++;
                 }
              }
           }
        }

      if (ExtDeltaType==1)
        {
         for (ki=kiPRZ;ki<64 && i<2;ki++)
           {
            if (arr[ki]>0)
              {
               delta=MathAbs(number[ki]-kj);
               if (delta<=ExtDelta)
                 {
                  j[i]=ki; j1[i]=delta; i++;
                 }
              }
            }
         }

      if (j1[1]>0)
        {
         if (j1[0]<=j1[1]) ki=j[0]; else ki=j[1];
         kk=number[ki]; txtkk=numbertxt[ki];
         k2=-1; colorPPattern=cPattern;
        }
      else if(j1[0]>0)
        {
         kk=number[j[0]]; txtkk=numbertxt[j[0]];
         k2=-1; colorPPattern=cPattern;
        }
     }
   else
     {
      if (ExtDeltaType==2)
        {
         for (ki=kiPRZ;ki<64 && i<2;ki++)
           {
            if (arr[ki]>0)
              {
               delta=MathAbs((number[ki]-kj)/number[ki]);
               if (delta<=ExtDelta)
                 {
                  j[i]=ki; j1[i]=delta; i++;
                 }
              }
            else if (numberMix[ki]>0)
              {
               delta=MathAbs((number[ki]-kj)/number[ki]);
               if (delta<=ExtDelta)
                 {
                  j[i]=ki; j1[i]=delta; i++;
                 }
              }
           }
        }

      if (ExtDeltaType==1)
        {
         for (ki=kiPRZ;ki<64 && i<2;ki++)
           {
            if (arr[ki]>0)
              {
               delta=MathAbs(number[ki]-kj);
               if (delta<=ExtDelta)
                 {
                  j[i]=ki; j1[i]=delta; i++;
                 }
              }
            else if (numberMix[ki]>0)
              {
               delta=MathAbs(number[ki]-kj);
               if (delta<=ExtDelta)
                 {
                  j[i]=ki; j1[i]=delta; i++;
                 }
              }
           }
        }

      if (j1[1]>0)
        {
         if (j1[0]<=j1[1]) ki=j[0]; else ki=j[1];
         k2=-1; kk=number[ki]; txtkk=numbertxt[ki];
        }
      else if(j1[0]>0)
        {
         ki=j[0];
         k2=-1; kk=number[j[0]]; txtkk=numbertxt[j[0]];
        }
      if (arr[ki]>0) colorPPattern=cPattern; else if (numberMix[ki]>0) colorPPattern=ExtPesavento;
     }
  }
//--------------------------------------------------------
// Поиск числа для паттернов Песавенто. Конец. 
//--------------------------------------------------------

//--------------------------------------------------------
// Отправка сообщения на электронную почту. Начало. 
//--------------------------------------------------------
void _SendMail(string subject, string some_text)
  {
   SendMail(subject, some_text);
  }
//--------------------------------------------------------
// Отправка сообщения на электронную почту. Конец. 
//--------------------------------------------------------

//+------------------------------------------------------------------+
//| Перенос значений параметров из строки в числовой массив          |
//| типа double. Начало.                                             |
//+------------------------------------------------------------------+
void _stringtodoublearray (string str, double& arr[], string& arr1[], int& x, bool y)
  {
   int i=0,j=-1,k=0;
   j=StringFind(str, ",",0);
   for (x=0;j>=0;x++)
     {
      j=StringFind(str, ",",j+1);
     }

   if(x>0)
     {
      x++;
      ArrayResize(arr,x);
      ArrayResize(arr1,x);
      if (y) ArrayResize(fitxt100,x);
     }

   for (i=0;i<x;i++)
     {
      j=StringFind(str,",",k);
      if (j<0)
        {
         arr1[i]=StringTrimLeft(StringTrimRight(StringSubstr(str,k)));
         arr[i]=StrToDouble(arr1[i]);
         if (arr[i]<1) arr1[i]=StringSubstr(arr1[i],1);
         if (y) fitxt100[i]=DoubleToStr(100*arr[i],1);
         break;
        }
      arr1[i]=StringTrimLeft(StringTrimRight(StringSubstr(str,k,j-k)));
      arr[i]=StrToDouble(arr1[i]);
      if (arr[i]<1) arr1[i]=StringSubstr(arr1[i],1);
      if (y) fitxt100[i]=DoubleToStr(100*arr[i],1);
      k=j+1;
     }
  }
//+------------------------------------------------------------------+
//| Перенос значений параметров из строки в числовой массив          |
//| типа double. Конец.                                              |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| Перенос значений параметров из строки в числовой массив          |
//| типа color. Начало.                                              |
//+------------------------------------------------------------------+
void _stringtocolorarray (string str, int& arr[], int& x)
  {
   int i=0,j=-1,k=0;
   j=StringFind(str, ",",0);
   for (x=0;j>=0;x++)
     {
      j=StringFind(str, ",",j+1);
     }
   if(x>0) {x++;ArrayResize(arr,x);}

   for (i=0;i<x;i++)
     {
      j=StringFind(str,",",k);
      if (j<0) {arr[i]=fStrToColor(StringSubstr(str,k)); break;}
      arr[i]=fStrToColor(StringSubstr(str,k,j-k));
      k=j+1;
     }
  }
//+------------------------------------------------------------------+
//| Перенос значений параметров из строки в числовой массив          |
//| типа color. Конец.                                               |
//+------------------------------------------------------------------+

//--------------------------------------------------------
// Преобразование строки в цвет. Начало.
// Функцию написал Integer.  http://forum.mql4.com/ru/7134
//--------------------------------------------------------
color fStrToColor(string aName){
 
   color tColor[]={  clrBlack, clrDarkGreen, clrDarkSlateGray, clrOlive, clrGreen, clrTeal, clrNavy, clrPurple, 
                     clrMaroon, clrIndigo, clrMidnightBlue, clrDarkBlue, clrDarkOliveGreen, clrSaddleBrown, 
                     clrForestGreen, clrOliveDrab, clrSeaGreen, clrDarkGoldenrod, clrDarkSlateBlue, 
                     clrSienna, clrMediumBlue, clrBrown, clrDarkTurquoise, clrDimGray, clrLightSeaGreen, 
                     clrDarkViolet, clrFireBrick, clrMediumVioletRed, clrMediumSeaGreen, clrChocolate, 
                     clrCrimson, clrSteelBlue, clrGoldenrod, clrMediumSpringGreen, clrLawnGreen, 
                     clrCadetBlue, clrDarkOrchid, clrYellowGreen, clrLimeGreen, clrOrangeRed, clrDarkOrange, 
                     clrOrange, clrGold, clrYellow, clrChartreuse, clrLime, clrSpringGreen, clrAqua, clrDeepSkyBlue, 
                     clrBlue, clrMagenta, clrRed, clrGray, clrSlateGray, clrPeru, clrBlueViolet, clrLightSlateGray, 
                     clrDeepPink, clrMediumTurquoise, clrDodgerBlue, clrTurquoise, clrRoyalBlue, clrSlateBlue, 
                     clrDarkKhaki, clrIndianRed, clrMediumOrchid, clrGreenYellow, clrMediumAquamarine, 
                     clrDarkSeaGreen, clrTomato, clrRosyBrown, clrOrchid, clrMediumPurple, clrPaleVioletRed, 
                     clrCoral, clrCornflowerBlue, clrDarkGray, clrSandyBrown, clrMediumSlateBlue, clrTan, 
                     clrDarkSalmon, clrBurlyWood, clrHotPink, clrSalmon, clrViolet, clrLightCoral, clrSkyBlue, 
                     clrLightSalmon, clrPlum, clrKhaki, clrLightGreen, clrAquamarine, clrSilver, clrLightSkyBlue, 
                     clrLightSteelBlue, clrLightBlue, clrPaleGreen, clrThistle, clrPowderBlue, clrPaleGoldenrod, 
                     clrPaleTurquoise, clrLightGray, clrWheat, clrNavajoWhite, clrMoccasin, clrLightPink, 
                     clrGainsboro, clrPeachPuff, clrPink, clrBisque, clrLightGoldenrod, clrBlanchedAlmond, 
                     clrLemonChiffon, clrBeige, clrAntiqueWhite, clrPapayaWhip, clrCornsilk, clrLightYellow, 
                     clrLightCyan, clrLinen, clrLavender, clrMistyRose, clrOldLace, clrWhiteSmoke, clrSeashell, 
                     clrIvory, clrHoneydew, clrAliceBlue, clrLavenderBlush, clrMintCream, clrSnow, clrWhite
                  };  
   string tName[]={  "clrBlack", "clrDarkGreen", "clrDarkSlateGray", "clrOlive", "clrGreen", "clrTeal", "clrNavy", "clrPurple", 
                     "clrMaroon", "clrIndigo", "clrMidnightBlue", "clrDarkBlue", "clrDarkOliveGreen", "clrSaddleBrown", 
                     "clrForestGreen", "clrOliveDrab", "clrSeaGreen", "clrDarkGoldenrod", "clrDarkSlateBlue", 
                     "clrSienna", "clrMediumBlue", "clrBrown", "clrDarkTurquoise", "clrDimGray", "clrLightSeaGreen", 
                     "clrDarkViolet", "clrFireBrick", "clrMediumVioletRed", "clrMediumSeaGreen", "clrChocolate", 
                     "clrCrimson", "clrSteelBlue", "clrGoldenrod", "clrMediumSpringGreen", "clrLawnGreen", 
                     "clrCadetBlue", "clrDarkOrchid", "clrYellowGreen", "clrLimeGreen", "clrOrangeRed", "clrDarkOrange", 
                     "clrOrange", "clrGold", "clrYellow", "clrChartreuse", "clrLime", "clrSpringGreen", "clrAqua", "clrDeepSkyBlue", 
                     "clrBlue", "clrMagenta", "clrRed", "clrGray", "clrSlateGray", "clrPeru", "clrBlueViolet", "clrLightSlateGray", 
                     "clrDeepPink", "clrMediumTurquoise", "clrDodgerBlue", "clrTurquoise", "clrRoyalBlue", "clrSlateBlue", 
                     "clrDarkKhaki", "clrIndianRed", "clrMediumOrchid", "clrGreenYellow", "clrMediumAquamarine", 
                     "clrDarkSeaGreen", "clrTomato", "clrRosyBrown", "clrOrchid", "clrMediumPurple", "clrPaleVioletRed", 
                     "clrCoral", "clrCornflowerBlue", "clrDarkGray", "clrSandyBrown", "clrMediumSlateBlue", "clrTan", 
                     "clrDarkSalmon", "clrBurlyWood", "clrHotPink", "clrSalmon", "clrViolet", "clrLightCoral", "clrSkyBlue", 
                     "clrLightSalmon", "clrPlum", "clrKhaki", "clrLightGreen", "clrAquamarine", "clrSilver", "clrLightSkyBlue", 
                     "clrLightSteelBlue", "clrLightBlue", "clrPaleGreen", "clrThistle", "clrPowderBlue", "clrPaleGoldenrod", 
                     "clrPaleTurquoise", "clrLightGray", "clrWheat", "clrNavajoWhite", "clrMoccasin", "clrLightPink", 
                     "clrGainsboro", "clrPeachPuff", "clrPink", "clrBisque", "clrLightGoldenrod", "clrBlanchedAlmond", 
                     "clrLemonChiffon", "clrBeige", "clrAntiqueWhite", "clrPapayaWhip", "clrCornsilk", "clrLightYellow", 
                     "clrLightCyan", "clrLinen", "clrLavender", "clrMistyRose", "clrOldLace", "clrWhiteSmoke", "clrSeashell", 
                     "clrIvory", "clrHoneydew", "clrAliceBlue", "clrLavenderBlush", "clrMintCream", "clrSnow", "clrWhite", "clrNONE"
                  };
      aName=StringTrimLeft(StringTrimRight(aName));      
         for(int i=0;i<ArraySize(tName);i++){
            if(aName==tName[i])return(tColor[i]);
         }
      return(Red);                                     
                  
}
//--------------------------------------------------------
// Преобразование строки в цвет. Конец.
// Функцию написал Integer.  http://forum.mql4.com/ru/7134
//--------------------------------------------------------

